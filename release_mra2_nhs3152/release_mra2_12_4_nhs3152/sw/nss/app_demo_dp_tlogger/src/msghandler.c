/*
 * Copyright 2015-2020 NXP
 * This software is owned or controlled by NXP and may only be used strictly
 * in accordance with the applicable license terms.  By expressly accepting
 * such terms or by downloading, installing, activating and/or otherwise using
 * the software, you are agreeing that you have read, and that you agree to
 * comply with and are bound by, such license terms.  If you do not agree to
 * be bound by the applicable license terms, then you may not retain, install,
 * activate or otherwise use the software.
 */

#include <string.h>
#include "msg/msg.h"
#include "ndeft2t/ndeft2t.h"
#include "storage/storage.h"
#include "event/event.h"
#include "event_tag.h"
#include "temperature.h"
#include "memory.h"
#include "timer.h"
#include "text.h"
#include "validate.h"
#include "msghandler.h"
#include "msghandler_protocol.h"

/* ------------------------------------------------------------------------- */

static bool EventCb_GetEventsResponse(uint8_t tag, int offset, uint8_t len, unsigned int index, uint32_t timestamp, uint32_t context);
static int ExtractFullPeriodicData(uint8_t which, unsigned int offset, int count, uint8_t * pData);
static uint32_t GetMeasurementsHandler(uint8_t msgId, int len, const uint8_t* pPayload);
static uint32_t GetConfigHandler(uint8_t msgId, int len, const uint8_t* pPayload);
static uint32_t SetConfigHandler(uint8_t msgId, int len, const uint8_t* pPayload);
static uint32_t MeasureTemperatureHandler(uint8_t msgId, int len, const uint8_t* pPayload);
static uint32_t StartHandler(uint8_t msgId, int len, const uint8_t* pPayload);
static uint32_t GetEventsHandler(uint8_t msgId, int len, const uint8_t* pPayload);
static uint32_t GetPeriodicDataHandler(uint8_t msgId, int len, const uint8_t* pPayload);
static bool ResponseCb(int responseLength, const uint8_t* responseData);
bool CommandAcceptCb(uint8_t msgId, int payloadLen, const uint8_t * pPayload);

/* ------------------------------------------------------------------------- */

#if !defined(MIME)
    #error MIME not defined. Define MIME in your Project settings.
    #error Under LPCXPresso: Project > Properties > C/C++ Build > Settings > Tool Settings > MCU C Compiler > Symbols
    #error Add a define similar to "MIME=\"t/demo.nhs.nxp\"" (without surrounding unescaped quotes)
    #error Add this define to all build configurations.
#endif
static unsigned char sMime[18] = MIME;

/** Returns the maximum of two numbers. @warning: both arguments are evaluated twice. */
#define MAX(a, b) (((a) > (b)) ? (a) : (b))

/** Maximum size, in bytes, of a single-record NDEF MIME message, using #sMime as MIME string */
#define MAX_RECORD_PAYLOAD_SIZE (NFC_SHARED_MEM_BYTE_SIZE - NDEFT2T_MSG_OVERHEAD(false, NDEFT2T_MIME_RECORD_OVERHEAD(false, sizeof(sMime))))

/**
 * The size of the array #sBuffer, in bytes.
 * It must be big enough to contain the largest possible NDEF record payload, and big enough for use as
 * workspace in #ExtractFullPeriodicData.
 */
#define BUFFER_SIZE MAX(MAX_RECORD_PAYLOAD_SIZE, \
                        MAX(sizeof(APP_MSG_RESPONSE_GETMEASUREMENTS_T), \
                            sizeof(APP_MSG_RESPONSE_GETPERIODICDATA_T)) \
                        + (sizeof(STORAGE_TYPE) * APP_MSG_MAX_TEMPERATURE_VALUES_IN_RESPONSE))

/**
 * A free-to-use buffer for any .+Handler function to build up the response prior to handing it off to the msg / NDEFT2T
 * module. At each entry of each .+Handler function, this buffer space can be assumed to be unclaimed, and its contents
 * overwritten.
 */
__attribute__ ((section(".noinit"))) __attribute__((aligned (4)))
static uint8_t sBuffer[BUFFER_SIZE];

/**
 * Used to block multiple responses on one command. Communication must occur strictly according
 * to a command - response sequence. Multiple responses generated by one command are to be fetched
 * using #MSG_ID_GETRESPONSE - I'm thinking here of #APP_MSG_ID_MEASURETEMPERATURE in particular.
 */
static bool sAcceptResponse = false;

/** #MSG_RESPONSE_BUFFER is assigned to this array in app_sel.h */
__attribute__ ((section(".noinit")))
uint8_t App_ResponseBuffer[MSG_RESPONSE_BUFFER_SIZE];

MSG_CMD_HANDLER_T App_CmdHandler[APP_MSG_ID_COUNT] = {{APP_MSG_ID_GETMEASUREMENTS, GetMeasurementsHandler},
                                                      {APP_MSG_ID_GETCONFIG, GetConfigHandler},
                                                      {APP_MSG_ID_SETCONFIG, SetConfigHandler},
                                                      {APP_MSG_ID_MEASURETEMPERATURE, MeasureTemperatureHandler},
                                                      {APP_MSG_ID_START, StartHandler},
                                                      {APP_MSG_ID_GETEVENTS, GetEventsHandler},
                                                      {APP_MSG_ID_GETPERIODICDATA, GetPeriodicDataHandler}};

/**
 * Dummy variable to test whether the diversity setting #MSG_APP_HANDLERS_COUNT matches APP_MSG_ID_COUNT.
 * If not equal, the dummy variable will have a negative array size and the compiler will raise an error
 * similar to:
 *   ../src/msghandler.c:71:13: error: size of array 'sTestValuesOf.' is negative
 * @{
 */
static char sTestValuesOfMsgAppHandlerCount[((int)MSG_APP_HANDLERS_COUNT == APP_MSG_ID_COUNT) - 1] __attribute__((unused));

/* ------------------------------------------------------------------------- */

/**
 * This callback is to be called by the events module for reporting events, supporting #GetEventsHandler.
 * @param tag See the @c tag argument description of #pEvent_Cb_t
 * @param offset See the @c offset argument description of #pEvent_Cb_t
 * @param len See the @c len argument description of #pEvent_Cb_t
 * @param index See the @c index argument description of #pEvent_Cb_t
 * @param timestamp See the @c timestamp argument description of #pEvent_Cb_t
 * @param context Pointer to the #APP_MSG_RESPONSE_GETEVENTS_T structure that contains information about the events
 *  to be reported, and after which the event data must be copied to. The maximum payload #MAX_RECORD_PAYLOAD_SIZE is
 *  checked for: the bit #EVENT_INFO_MORE is set when this limit would have been exceeded without this check.
 * @return @c true until #EVENT_INFO_MORE is set.
 * @pre The @c index, @c eventMask and @c info fields of the #APP_MSG_RESPONSE_GETEVENTS_T structure pointed to by
 *  @c context must have been filled in.
 * @pre The event module must be compiled in using non-zero values of #EVENT_CB_OPENING_CALL and
 *  #EVENT_CB_CLOSING_INDEX.
 * @post The @c index field of the #APP_MSG_RESPONSE_GETEVENTS_T structure pointed to by @c context is overwritten with
 *  the full response size - in bytes. This includes the size of the structure @b and the size of the additional event
 *  data appended after the structure.
 * @warning The @c index field of the #APP_MSG_RESPONSE_GETEVENTS_T structure pointed to by @c context is 'misused' to
 *  notify the total size of the response back to #GetEventsHandler. #GetEventsHandler must set the correct value a
 *  second time before sending the response.
 * @see Event_SetCb
 */
static bool EventCb_GetEventsResponse(uint8_t tag, int offset, uint8_t len, unsigned int index, uint32_t timestamp, uint32_t context)
{
    ASSERT(context != 0);
    APP_MSG_RESPONSE_GETEVENTS_T * pResponse = (APP_MSG_RESPONSE_GETEVENTS_T *)context;
    static int sCallCount = 0;
    static uint16_t sOffsetInResponse = 0;
    static uint8_t * sData = NULL;

    switch (index) {
        case EVENT_CB_OPENING_INDEX:
            sData = (uint8_t *)pResponse;
            sCallCount = 0;
            pResponse->count = 0;
            sOffsetInResponse = sizeof(APP_MSG_RESPONSE_GETEVENTS_T);
            break;

        case EVENT_CB_CLOSING_INDEX:
            sData = NULL;
            sCallCount = 0;
            pResponse->index = sOffsetInResponse; /* misusing the index field to transfer information back to the initiator. */
            sOffsetInResponse = 0;
            break;

        default:
            ASSERT(sData != NULL);
            ASSERT((sOffsetInResponse > 0) && (sOffsetInResponse <= (int)MAX_RECORD_PAYLOAD_SIZE));
            if (offset < 0) {
                len = 0;
            }
            if ((1U << tag) & pResponse->eventMask) {
                sCallCount++;
                if (sCallCount <= pResponse->index) { /* Also exclude when equal: the increment has already been done. */
                    /* Skip this event */
                }
                else {
                    /* First check if enough space is available */
                    int eventInfoLen = 0;
                    if (pResponse->info & EVENT_INFO_INDEX) {
                        eventInfoLen += 2;
                    }
                    if (pResponse->info & EVENT_INFO_TIMESTAMP) {
                        eventInfoLen += 4;
                    }
                    if (pResponse->info & EVENT_INFO_ENUM) {
                        eventInfoLen += 1;
                    }
                    if ((pResponse->info & EVENT_INFO_DATA) && (len)) {
                        eventInfoLen += len;
                    }
                    if (sOffsetInResponse + eventInfoLen <= (int)MAX_RECORD_PAYLOAD_SIZE) {
                        pResponse->count++;
                        /* The order in which the bits in response->info are checked must be respected. */
                        if (pResponse->info & EVENT_INFO_INDEX) {
                            sData[sOffsetInResponse + 0] = (uint8_t)(index & 0x00FF);
                            sData[sOffsetInResponse + 1] = (uint8_t)((index >> 8) & 0x00FF);
                            sOffsetInResponse = (uint16_t)(sOffsetInResponse + 2);
                        }
                        if (pResponse->info & EVENT_INFO_TIMESTAMP) {
                            sData[sOffsetInResponse + 0] = (uint8_t)(timestamp & 0x00FF);
                            sData[sOffsetInResponse + 1] = (uint8_t)((timestamp >> 8) & 0x00FF);
                            sData[sOffsetInResponse + 2] = (uint8_t)((timestamp >> 16) & 0x00FF);
                            sData[sOffsetInResponse + 3] = (uint8_t)((timestamp >> 24) & 0x00FF);
                            sOffsetInResponse = (uint16_t)(sOffsetInResponse + 4);
                        }
                        if (pResponse->info & EVENT_INFO_ENUM) {
                            sData[sOffsetInResponse + 0] = tag;
                            sOffsetInResponse = (uint16_t)(sOffsetInResponse + 1);
                        }
                        if ((pResponse->info & EVENT_INFO_DATA) && (len)) {
                            Chip_EEPROM_Read(NSS_EEPROM, offset, sData + sOffsetInResponse, len);
                            sOffsetInResponse = (uint16_t)(sOffsetInResponse + len);
                        }
                    }
                    else {
                        pResponse->eventMask |= EVENT_INFO_MORE;
                    }
                }
            }
            break;
    }

    return (pResponse->info & EVENT_INFO_MORE) ? false : true;
}

/**
 * Retrieves a number periodically taken sampled values.
 * The format will be according to #APP_MSG_RESPONSE_GETPERIODICDATA_T, #APP_MSG_PERIODICDATA_FORMAT_FULL
 * is chosen in the field @c format.
 * @param which A bitmask of OR'd values of type #APP_MSG_PERIODICDATA_TYPE_T
 * @param offset The number of pairs to skip before fetching the periodically taken measurements.
 * @param count The number of samples requested, of each selected type of periodic data.
 * @param pData Used as both workspace and as container for the requested data. May not be @c NULL. The size of the
 *  buffer must be at least @code sizeof(STORAGE_TYPE) * count @endcode bytes.
 * @return The number of bytes occupied in pBuffer.
 */
static int ExtractFullPeriodicData(uint8_t which, unsigned int offset, int count, uint8_t * pData)
{
    ASSERT(which == APP_MSG_PERIODICDATA_TYPE_TEMPERATURE);
    (void)which; /* suppress [-Wunused-parameter]: which is assumed to be APP_MSG_PERIODICDATA_TYPE_TEMPERATURE, checked in the assert above. */
    int size = 0;
    STORAGE_TYPE * samples = (STORAGE_TYPE *)pData;
    if (Storage_Seek((int)offset)) {
        count = Storage_Read(samples, count);
        /* samples is now filled with count values of type STORAGE_TYPE. */
        size = count * (int)sizeof(int16_t);
    }
    return size;
}

/* ------------------------------------------------------------------------- */

/**
 * An extra check on the value of #APP_MSG_MAX_TEMPERATURE_VALUES_IN_RESPONSE.
 * If this construct doesn't compile, an error similar to
 * @code ../src/msghandler.c:66:22: error: size of array 'sTestGetMeasurementsDefine' is negative @endcode
 * will be given. It either indicates the define @c MIME is too long; or the define
 * #APP_MSG_MAX_TEMPERATURE_VALUES_IN_RESPONSE is too large.
 */
static char sTestGetMeasurementsDefine[(sizeof(APP_MSG_RESPONSE_GETMEASUREMENTS_T) + (2*APP_MSG_MAX_TEMPERATURE_VALUES_IN_RESPONSE) > MAX_RECORD_PAYLOAD_SIZE) ? -1 : 1] __attribute__((unused));

/**
 * Dummy variables to test whether the enum #APP_MSG_TSEN_RESOLUTION_T is in sync with #TSEN_RESOLUTION_T.
 * If not in sync, one of the dummy variables will have a negative array size and the compiler will raise an error
 * similar to:
 *   ../src/msghandler.c:71:13: error: size of array 'sTestValuesOfTsen.' is negative
 * @{
 */
static char sTestValuesOfTsenA[2*((int)TSEN_7BITS == APP_MSG_TSEN_RESOLUTION_7BITS) - 1] __attribute__((unused));
static char sTestValuesOfTsenB[2*((int)TSEN_8BITS == APP_MSG_TSEN_RESOLUTION_8BITS) - 1] __attribute__((unused));
static char sTestValuesOfTsenC[2*((int)TSEN_9BITS == APP_MSG_TSEN_RESOLUTION_9BITS) - 1] __attribute__((unused));
static char sTestValuesOfTsenD[2*((int)TSEN_10BITS == APP_MSG_TSEN_RESOLUTION_10BITS) - 1] __attribute__((unused));
static char sTestValuesOfTsenE[2*((int)TSEN_11BITS == APP_MSG_TSEN_RESOLUTION_11BITS) - 1] __attribute__((unused));
static char sTestValuesOfTsenF[2*((int)TSEN_12BITS == APP_MSG_TSEN_RESOLUTION_12BITS) - 1] __attribute__((unused));
/** @} */

/* ------------------------------------------------------------------------- */

static uint32_t GetMeasurementsHandler(uint8_t msgId, int len, const uint8_t * pPayload)
{
    uint32_t errorCode;
    if (len == sizeof(APP_MSG_CMD_GETMEASUREMENTS_T)) {
        const APP_MSG_CMD_GETMEASUREMENTS_T * command = (const APP_MSG_CMD_GETMEASUREMENTS_T *)pPayload;
        APP_MSG_RESPONSE_GETMEASUREMENTS_T * response = (APP_MSG_RESPONSE_GETMEASUREMENTS_T *)sBuffer;
        response->result = MSG_OK;
        response->offset = command->offset;
        memset(response->zero, 0, sizeof(response->zero));
        /* Append as many measured values as possible. */
        uint8_t * pData = &sBuffer[sizeof(APP_MSG_RESPONSE_GETMEASUREMENTS_T)];
        int size = ExtractFullPeriodicData(APP_MSG_PERIODICDATA_TYPE_TEMPERATURE, command->offset,
                                           APP_MSG_MAX_TEMPERATURE_VALUES_IN_RESPONSE, pData);
        response->count = (uint8_t)(size / (int)sizeof(int16_t));
        Msg_AddResponse(msgId, (int)sizeof(APP_MSG_RESPONSE_GETMEASUREMENTS_T) + size, (uint8_t *)response);
    }
    else {
        errorCode = MSG_ERR_INVALID_COMMAND_SIZE;
    }
    return errorCode;
}

static uint32_t GetConfigHandler(uint8_t msgId, int len, const uint8_t * pPayload)
{
    (void)len; /* suppress [-Wunused-parameter]: no argument is expected, but if present redundantly, just ignore. */
    (void)pPayload; /* suppress [-Wunused-parameter]: no argument is expected, but if present redundantly, just ignore. */
    const MEMORY_CONFIG_T * config = Memory_GetConfig();
    APP_MSG_RESPONSE_GETCONFIG_T response = {.result = MSG_OK,
                                             .configTime = config->cmd.currentTime,
                                             .interval = config->cmd.interval,
                                             .startDelay = config->cmd.startDelay,
                                             .runningTime = config->cmd.runningTime,
                                             .validMinimum = config->cmd.validMinimum,
                                             .validMaximum = config->cmd.validMaximum,
                                             .status = config->status,
                                             .attainedMinimum = config->attainedMinimum,
                                             .attainedMaximum = config->attainedMaximum};
    response.count = (uint16_t)Storage_GetCount();
    uint32_t startTime = 0; /* Default value if no event found. */
    Event_GetFirstByTag(EVENT_TAG_LOGGING, NULL, NULL, NULL, &startTime);
    response.startTime = startTime;
    response.currentTime = (uint32_t)Chip_RTC_Time_GetValue(NSS_RTC);
    Msg_AddResponse(msgId, sizeof(response), (uint8_t*)&response);
    return MSG_OK;
}

static uint32_t SetConfigHandler(uint8_t msgId, int len, const uint8_t* pPayload)
{
    uint32_t errorCode;
    if (len == sizeof(APP_MSG_CMD_SETCONFIG_T)) {
        const APP_MSG_CMD_SETCONFIG_T * command = (const APP_MSG_CMD_SETCONFIG_T *)pPayload;

        /* First priority: handle the RTC adjustments and stop the measurement timer. */
        int tickValue = (int)command->currentTime;
        if (tickValue == 0) {
            /* A value of 0 _may_ result in a logging session not being started. If 0:
             * - The time is set to 0 below (Chip_RTC_Time_SetValue) and
             * - read out again (via Memory_ResetConfig) in Event_Init (META_T.baseTimestamp).
             *  This may still be 0 at that time.
             * - The next time Event_Init is called, all events are cleared again since the baseTimestamp is 0.
             * - ...
             * To avoid this, just set it to a non-zero value. How can the current time be 0, anyway?
             */
            tickValue = 1;
        }
        Chip_RTC_Time_SetValue(NSS_RTC, tickValue);
        Timer_StopMeasurementTimeout();

        /* Second priority: generate a response. */
        MSG_RESPONSE_RESULTONLY_T response = {.result = MSG_OK};
        Msg_AddResponse(msgId, sizeof(response), (uint8_t*)&response);

        /* Third priority: housekeeping & configure the next measurement. */
        Storage_Reset(true);
        Validate_Reset();
        Memory_ResetConfig(command); /* Also resets all events, which also re-fetches the newly set RTC time. */
        if (command->interval) {
            Memory_AddToState(APP_MSG_EVENT_CONFIGURED, true);
            if (command->startDelay == APP_MSG_DELAY_START_INDEFINITELY) {
                /* We do not know when to start. */
#ifdef BOARD_ENABLE_WAKEUP
                NVIC_EnableIRQ(PIO0_0_IRQn); /* PIO0_0_IRQHandler is called when this interrupt fires. */
                Chip_SysCon_StartLogic_SetEnabledMask(SYSCON_STARTSOURCE_PIO0_0);
#endif
            }
            else {
                Memory_AddToState(APP_MSG_EVENT_STARTING, true);
                /* Configure the time to make a first measurement: start the RTC-down counter.
                 * Cheat a bit: assume 'within 1 second' is as good as 'immediately'.
                 */
                Timer_StartMeasurementTimeout(command->startDelay ? (int)command->startDelay : 1);
            }
        }
        errorCode = MSG_OK;
    }
    else {
        errorCode = MSG_ERR_INVALID_COMMAND_SIZE;
    }
    return errorCode;
}

static uint32_t MeasureTemperatureHandler(uint8_t msgId, int len, const uint8_t* pPayload)
{
    uint32_t errorCode;
    if (len == sizeof(APP_MSG_CMD_MEASURETEMPERATURE_T)) {
        const APP_MSG_CMD_MEASURETEMPERATURE_T * command = (const APP_MSG_CMD_MEASURETEMPERATURE_T *)pPayload;
        if ((command->resolution >= TSEN_7BITS) && (command->resolution <= TSEN_12BITS)) {
            MSG_RESPONSE_RESULTONLY_T response;
            response.result = (uint32_t)Temperature_Measure(command->resolution, true);
            Msg_AddResponse(msgId, sizeof(response), (uint8_t*)&response);
            errorCode = MSG_OK;
        }
        else {
            errorCode = MSG_ERR_INVALID_PARAMETER;
        }
    }
    else {
        errorCode = MSG_ERR_INVALID_COMMAND_SIZE;
    }
    return errorCode;
}

static uint32_t StartHandler(uint8_t msgId, int len, const uint8_t* pPayload)
{
    (void)len; /* suppress [-Wunused-parameter]: no argument is expected, but if present redundantly, just ignore. */
    (void)pPayload; /* suppress [-Wunused-parameter]: no argument is expected, but if present redundantly, just ignore. */
    MSG_RESPONSE_RESULTONLY_T response = { MSG_ERR_INVALID_PRECONDITION };
    if (Memory_IsReadyToStart()) {
        Memory_AddToState(APP_MSG_EVENT_STARTING, true);
        /* Configure the time to make a first measurement: start the RTC-down counter.
         * Cheat a bit: assume 'within 1 second' is as good as 'immediately'.
         */
        Timer_StartMeasurementTimeout(1);
        response.result = MSG_OK;
        Msg_AddResponse(msgId, sizeof(response), (uint8_t*)&response);
    }
    return response.result;
}

static uint32_t GetEventsHandler(uint8_t msgId, int len, const uint8_t* pPayload)
{
    uint32_t errorCode;
    if (len == sizeof(APP_MSG_CMD_GETEVENTS_T)) {
        const APP_MSG_CMD_GETEVENTS_T * command = (const APP_MSG_CMD_GETEVENTS_T *)pPayload;

        /* Fill in the response structure. */
        APP_MSG_RESPONSE_GETEVENTS_T * response = (APP_MSG_RESPONSE_GETEVENTS_T *)sBuffer;
        response->index = command->index;
        response->eventMask = command->eventMask ? command->eventMask : ((1 << APP_MSG_EVENT_COUNT) - 1);
        response->info = command->info; // possibly EVENT_INFO_MORE is additionally set in EventCb_GetEventsResponse
        //response->count = set in EventCb_GetEventsResponse

        /* Append with the requested event information data. */
        pEvent_Cb_t previousCb = Event_SetCb(EventCb_GetEventsResponse);
        (void)Event_GetByIndex(command->index, 0xFFFFFFFF, (uint32_t)response);
        (void)Event_SetCb(previousCb);

        int payloadLen = response->index; /* Misuse of index field: it now contains the full response size. */
        response->index = command->index; /* Re-copying the correct value. */
        Msg_AddResponse(msgId, payloadLen, (uint8_t*)response);
        errorCode = MSG_OK;
    }
    else {
        errorCode = MSG_ERR_INVALID_COMMAND_SIZE;
    }
    return errorCode;
}

static uint32_t GetPeriodicDataHandler(uint8_t msgId, int len, const uint8_t* pPayload)
{
    uint32_t errorCode;
    if (len == sizeof(APP_MSG_CMD_GETPERIODICDATA_T)) {
        const APP_MSG_CMD_GETPERIODICDATA_T * command = (const APP_MSG_CMD_GETPERIODICDATA_T *)pPayload;
        if (command->which != APP_MSG_PERIODICDATA_TYPE_TEMPERATURE) {
            errorCode = MSG_ERR_INVALID_PARAMETER;
        }
        else if (command->format != APP_MSG_PERIODICDATA_FORMAT_FULL) {
            errorCode = MSG_ERR_INVALID_NYI;
        }
        else {
            APP_MSG_RESPONSE_GETPERIODICDATA_T * response = (APP_MSG_RESPONSE_GETPERIODICDATA_T *)sBuffer;
            response->result = MSG_OK;
            response->which = command->which;
            response->format = command->format;
            response->offset = command->offset;
            /* Append as many measured values as possible. */
            uint8_t * pData = &sBuffer[sizeof(APP_MSG_RESPONSE_GETPERIODICDATA_T)];
            int size = ExtractFullPeriodicData(command->which, command->offset,
                                               APP_MSG_MAX_TEMPERATURE_VALUES_IN_RESPONSE, pData);
            Msg_AddResponse(msgId, (int)sizeof(APP_MSG_RESPONSE_GETPERIODICDATA_T) + size, sBuffer);
            errorCode = MSG_OK;
        }
    }
    else {
        errorCode = MSG_ERR_INVALID_COMMAND_SIZE;
    }
    return errorCode;
}

/* -------------------------------------------------------------------------------- */

bool CommandAcceptCb(uint8_t msgId, int payloadLen, const uint8_t * pPayload)
{
    bool accept;
    (void)payloadLen; /* suppress [-Wunused-parameter]: only the msgid is looked at to decide to accept or not. */
    (void)pPayload; /* suppress [-Wunused-parameter]: only the msgid is looked at to decide to accept or not. */

    switch (msgId)
    {
        case MSG_ID_CHECKBATTERY:
            accept = !Memory_IsMonitoring();
            break;

        default:
            accept = true;
            break;
    }

    return accept;
}

static bool ResponseCb(int responseLength, const uint8_t* responseData)
{
    static unsigned char sLocale[] = "en";

    __attribute__ ((section(".noinit")))
    static uint8_t sGetVersionResponse[2 + sizeof(MSG_RESPONSE_GETVERSION_T)];

    __attribute__ ((section(".noinit")))
    static uint8_t sGetNfcUidResponse[2 + sizeof(MSG_RESPONSE_GETNFCUID_T)];

    __attribute__ ((section(".noinit"))) __attribute__((aligned (4)))
    static uint8_t sNdefInstance[NDEFT2T_INSTANCE_SIZE];

    __attribute__ ((section(".noinit"))) __attribute__((aligned (4)))
    static uint8_t sData[NFC_SHARED_MEM_BYTE_SIZE];

    NDEFT2T_CREATE_RECORD_INFO_T recordInfo;
    bool success = sAcceptResponse;
    const char * pData;
    int size;

    /* A GetConfig response is always accompanied by a get version response, a get nfc uid response, and some text
     * record(s).
     * This is a deviation from the strict command/response foreseen when using the msg mod, but helps to provide an
     * initial message with all status info at once - both textual (used without an APP) and binary (used with an APP),
     * without the need for the tag reader to write into the NFC shared memory.
     * During init - AppMsgInit() - it is ensured a get version response is generated. That response is stored here,
     * to be used for all subsequent received get config responses.
     */
    if ((MSG_ID_T)responseData[0] == MSG_ID_GETVERSION) {
        ASSERT(responseLength == 2 + sizeof(MSG_RESPONSE_GETVERSION_T));
        memcpy(&sGetVersionResponse, responseData, (size_t)responseLength);
        success = true; /* Avoid this to be stored in the internal response buffer of mod msg. */
    }
    else if ((MSG_ID_T)responseData[0] == MSG_ID_GETNFCUID) {
        ASSERT(responseLength == 2 + sizeof(MSG_RESPONSE_GETNFCUID_T));
        memcpy(&sGetNfcUidResponse, responseData, (size_t)responseLength);
        success = true; /* Avoid this to be stored in the internal response buffer of mod msg. */
    }

    if (sAcceptResponse) {
        sAcceptResponse = false;
        NDEFT2T_CreateMessage(sNdefInstance, sData, sizeof(sData), false);

        if ((APP_MSG_ID_T)responseData[0] == APP_MSG_ID_GETCONFIG) {
            /* Append a mime record with the stored version info. */
            recordInfo.shortRecord = true;
            recordInfo.pString = sMime;
            if (NDEFT2T_CreateMimeRecord(sNdefInstance, &recordInfo)) {
                if (NDEFT2T_WriteRecordPayload(sNdefInstance, sGetVersionResponse, sizeof(sGetVersionResponse))) {
                    NDEFT2T_CommitRecord(sNdefInstance);
                }
            }

            /* Append a text record, shown by the Android OS if no APP is handling the NDEF message. */
            recordInfo.shortRecord = true;
            recordInfo.pString = sLocale;

            pData = Text_GetStatus(&size);
            if (size > 0) {
                if (NDEFT2T_CreateTextRecord(sNdefInstance, &recordInfo)) {
                    if (NDEFT2T_WriteRecordPayload(sNdefInstance, pData, size)) {
                        NDEFT2T_CommitRecord(sNdefInstance);
                    }
                }
            }
            pData = Text_GetFailures(&size);
            if (size > 0) {
                if (NDEFT2T_CreateTextRecord(sNdefInstance, &recordInfo)) {
                    if (NDEFT2T_WriteRecordPayload(sNdefInstance, pData, size)) {
                        NDEFT2T_CommitRecord(sNdefInstance);
                    }
                }
            }
            pData = Text_GetTemperature(&size);
            if (size > 0) {
                if (NDEFT2T_CreateTextRecord(sNdefInstance, &recordInfo)) {
                    if (NDEFT2T_WriteRecordPayload(sNdefInstance, pData, size)) {
                        NDEFT2T_CommitRecord(sNdefInstance);
                    }
                }
            }

            /* Append a mime record containing the NFC ID. Vital for iOS, redundant for all other platforms. */
            recordInfo.shortRecord = true;
            recordInfo.pString = (uint8_t *)"n/p";
            if (NDEFT2T_CreateMimeRecord(sNdefInstance, &recordInfo)) {
                if (NDEFT2T_WriteRecordPayload(sNdefInstance, sGetNfcUidResponse, sizeof(sGetNfcUidResponse))) {
                    NDEFT2T_CommitRecord(sNdefInstance);
                }
            }
        }

        /* Append a mime record with the just received response */
        recordInfo.shortRecord = false;
        recordInfo.pString = (uint8_t *)"n/p";
        if (NDEFT2T_CreateMimeRecord(sNdefInstance, &recordInfo)) {
            if (NDEFT2T_WriteRecordPayload(sNdefInstance, responseData, responseLength)) {
                NDEFT2T_CommitRecord(sNdefInstance);
            }
        }

        NDEFT2T_CommitMessage(sNdefInstance);
    }

    return success;
}

/* ------------------------------------------------------------------------- */

void AppMsgInit(bool reuseKeys)
{
    (void)reuseKeys; /* Ignore argument; there is nothing to reuse. */
    Msg_Init();
    Msg_SetResponseCb(ResponseCb);

    /* Generate two responses which are not yet sent out, but are taken along when a APP_MSG_ID_GETCONFIG response
     * arrives in ResponseCb. */
    uint8_t command[2] = {0, 0};
    command[0] = MSG_ID_GETVERSION;
    Msg_HandleCommand(2, command);
    command[0] = MSG_ID_GETNFCUID;
    Msg_HandleCommand(2, command);
}

void AppMsgHandleCommand(int cmdLength, const uint8_t* cmdData)
{
    sAcceptResponse = true;
    Msg_HandleCommand(cmdLength, cmdData);
}

void AppMsgHandlerSendMeasureTemperatureResponse(bool success, int16_t temperature)
{
    APP_MSG_RESPONSE_MEASURETEMPERATURE_T response;
    response.result = success ? MSG_OK : APP_MSG_ERR_TSEN;
    response.temperature = temperature;
    Msg_AddResponse(APP_MSG_ID_MEASURETEMPERATURE, sizeof(response), (uint8_t*)&response);
}
