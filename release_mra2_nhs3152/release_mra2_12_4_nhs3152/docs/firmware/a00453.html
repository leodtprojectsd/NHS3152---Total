<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NHS31xx SW API: i2c: I2C driver</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="nxp-logo_small.jpg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NHS31xx SW API
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('a00453.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">i2c: I2C driver<div class="ingroups"><a class="el" href="a00427.html">Drivers</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>This driver provides APIs for the configuration and operation of the I2C hardware block. The I2C interface provides four operating modes:</p><ol type="1">
<li>master transmitter mode</li>
<li>master receiver mode</li>
<li>slave transmitter mode</li>
<li>slave receiver mode</li>
</ol>
<p>The I2C-bus interface is byte oriented. This driver supports both polled or interrupt based operation. <br />
This I2C block is capable of addressing four slaves.</p>
<dl class="section user"><dt>IOCON configuration for I2C:</dt><dd>The I2C-bus pins (<a class="el" href="a00456.html#gga42905d0e658c71f0b5a26aac076744ccadc5e393f0b084a938e709e39b1f9de94">IOCON_PIO0_4</a> and <a class="el" href="a00456.html#gga42905d0e658c71f0b5a26aac076744ccaf2094661f822d1299bd851ea1e6c0b01">IOCON_PIO0_5</a>) must be configured for the I2C Standard/ Fast-mode (<a class="el" href="a00456.html#ga21f911561fcda012327bf35bae68dcb6">IOCON_FUNC_1</a>). See IO Configuration driver <a class="el" href="a00456.html">iocon: IO Configuration driver</a> for details.</dd></dl>
<p><a class="anchor" id="I2CClockRates_anchor"></a></p><dl class="section user"><dt>I2C Clock rates:</dt><dd>Details on clock rates that can be used for I2C communication can be referred from <a class="el" href="a00767.html">SW Clock Restrictions</a>. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>During driver initialization (<a class="el" href="a00453.html#gab79263d278814945df2cd44c5db7b514">Chip_I2C_Init</a>), there is no implicit check that the system clock/bitrate combination meets the clock restriction requirements. It is up to the caller to ensure that the respective restrictions are met. </dd>
<dd>
The I2C clock is derived from system clock. Changing the system clock frequency affects the I2C bitrate, hence it must be re-set using <a class="el" href="a00453.html#ga17fac5d72058db8eed11d247e78b74ed">Chip_I2C_SetClockRate</a> to ensure the required rate is set.</dd></dl>
<dl class="section user"><dt>I2C Master Event Handling:</dt><dd>The I2C master supports two event handling mechanisms which can be configured using <a class="el" href="a00453.html#ga1fc3fc0946344e9551d9eef0bbf610b9">Chip_I2C_SetMasterEventHandler</a>:<ol type="1">
<li>Interrupt based handling makes use of <a class="el" href="a00453.html#ga06b84fe3fad7ffd4ccb93f2683781936">Chip_I2C_EventHandler</a> handler.</li>
<li>Polling based handling makes use of <a class="el" href="a00453.html#gaaa89a66d658a41325b3c5e56bc059401">Chip_I2C_EventHandlerPolling</a> handler.</li>
</ol>
The user can also implement an own handler using <a class="el" href="a00453.html#ga1fc3fc0946344e9551d9eef0bbf610b9">Chip_I2C_SetMasterEventHandler</a> to perform specific actions for specific events (<a class="el" href="a00453.html#gacb2cd4e03ea48339d327e4f387441bf3">I2C_EVENT_T</a>).</dd></dl>
<dl class="section user"><dt>To use this driver:</dt><dd><b> I2C Driver is initialized as follows: </b><ol type="1">
<li>I2C pin functions and the I2C mode are configured using <a class="el" href="a00456.html#ga426cc484a31e59241f87215e5e452c56">Chip_IOCON_SetPinConfig</a>.</li>
<li>I2C block reset signal is de-asserted using <a class="el" href="a00461.html#ga8a51b8eff23cfdea04a8da6af66c5a5f">Chip_SysCon_Peripheral_DeassertReset</a>.</li>
<li>I2C driver is initialized using <a class="el" href="a00453.html#gab79263d278814945df2cd44c5db7b514">Chip_I2C_Init</a>.</li>
<li>I2C clock rate is set using <a class="el" href="a00453.html#ga17fac5d72058db8eed11d247e78b74ed">Chip_I2C_SetClockRate</a>.</li>
</ol>
<b> For I2C Master transfers: </b><ol type="1">
<li>Set the event handling mechanism using <a class="el" href="a00453.html#ga1fc3fc0946344e9551d9eef0bbf610b9">Chip_I2C_SetMasterEventHandler</a> for the master.</li>
<li>Enable the I2C interrupt in NVIC using <a class="el" href="a00446.html#gaa7a55182d0998e1ea13efd6875167cf0" title="Enable External Interrupt. ">NVIC_EnableIRQ</a> for interrupt based event handling.</li>
<li>Fill in <a class="el" href="a00453.html#a00642">I2C_XFER_T</a> structure if <a class="el" href="a00453.html#ga05710be20b72b425aac66bb3def57aaf">Chip_I2C_MasterTransfer</a> API is used for I2C master transfer.</li>
<li>Use one of the appropriate Master transfer API based on the type of transfer required.<ul>
<li><a class="el" href="a00453.html#ga05710be20b72b425aac66bb3def57aaf">Chip_I2C_MasterTransfer</a></li>
<li><a class="el" href="a00453.html#ga889826ff1209ef05d260ac2cbc7d0069">Chip_I2C_MasterSend</a></li>
<li><a class="el" href="a00453.html#gae816049843eb162c803b5058ebd9a25c">Chip_I2C_MasterRead</a></li>
<li><a class="el" href="a00453.html#gad31b605d03e23e050b7b85b1d2ad0d8c">Chip_I2C_MasterCmdRead</a></li>
</ul>
</li>
</ol>
<b> For I2C Slave transfers: </b><ol type="1">
<li>Fill in <a class="el" href="a00453.html#a00642">I2C_XFER_T</a> structure for the slave transfer.</li>
<li>Use the <a class="el" href="a00453.html#gaf6ea40668dde26e406f76ff3ddeda527">Chip_I2C_SlaveSetup</a> to setup the I2C slave.</li>
<li>Enable the I2C interrupt in NVIC using <a class="el" href="a00446.html#gaa7a55182d0998e1ea13efd6875167cf0" title="Enable External Interrupt. ">NVIC_EnableIRQ</a>.</li>
</ol>
</dd></dl>
<dl class="section user"><dt>Example 1 - Configuring I2C as Master and use transfer (send/receive) API</dt><dd><ul>
<li>Master mode</li>
<li>System clock: 4000000 and I2C clock: 100000</li>
<li>Target SlaveAddr: 0x7f</li>
<li>Operating mode: Interrupt based</li>
<li>API used for send and receive: <a class="el" href="a00453.html#ga05710be20b72b425aac66bb3def57aaf">Chip_I2C_MasterTransfer</a></li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>User can select appropriate System and I2C clocks as mentioned at <a class="el" href="a00453.html#I2CClockRates_anchor">I2C clock rates</a>.</dd></dl>
<p>Tx and Rx data structures: </p><div class="fragment"><div class="line">uint8_t masterTxData[4] = {0x31, 0x34, 0x61, 0x95};</div><div class="line">uint8_t masterRxData[4] = {0, 0, 0, 0};</div></div><!-- fragment --><p> Setup and transfer of data: </p><div class="fragment"><div class="line">    <a class="code" href="a00456.html#ga84a821f0ee6888a3b284646a8cd126ae">Chip_IOCON_Init</a>(<a class="code" href="a00433.html#ga9f6e80f81c74d0d95a79e92ed670f1b3">NSS_IOCON</a>); <span class="comment">/* Is normally already called during board initialization. */</span></div><div class="line">    <a class="code" href="a00456.html#ga426cc484a31e59241f87215e5e452c56">Chip_IOCON_SetPinConfig</a>(<a class="code" href="a00433.html#ga9f6e80f81c74d0d95a79e92ed670f1b3">NSS_IOCON</a>, <a class="code" href="a00456.html#gga42905d0e658c71f0b5a26aac076744ccadc5e393f0b084a938e709e39b1f9de94">IOCON_PIO0_4</a>, <a class="code" href="a00456.html#ga21f911561fcda012327bf35bae68dcb6">IOCON_FUNC_1</a> | <a class="code" href="a00456.html#gae31150b0ceb2084d0a2986bbd83a5550">IOCON_I2CMODE_STDFAST</a>);</div><div class="line">    <a class="code" href="a00456.html#ga426cc484a31e59241f87215e5e452c56">Chip_IOCON_SetPinConfig</a>(<a class="code" href="a00433.html#ga9f6e80f81c74d0d95a79e92ed670f1b3">NSS_IOCON</a>, <a class="code" href="a00456.html#gga42905d0e658c71f0b5a26aac076744ccaf2094661f822d1299bd851ea1e6c0b01">IOCON_PIO0_5</a>, <a class="code" href="a00456.html#ga21f911561fcda012327bf35bae68dcb6">IOCON_FUNC_1</a> | <a class="code" href="a00456.html#gae31150b0ceb2084d0a2986bbd83a5550">IOCON_I2CMODE_STDFAST</a>);</div><div class="line"></div><div class="line">    <a class="code" href="a00434.html#ga8de42eae27a7e7c300f1f57da9e56bb2">Chip_Clock_System_SetClockFreq</a>(4000000);</div><div class="line"></div><div class="line">    <a class="code" href="a00461.html#ga8a51b8eff23cfdea04a8da6af66c5a5f">Chip_SysCon_Peripheral_DeassertReset</a>(<a class="code" href="a00461.html#gga647a7639a3ebb94d5910d8c8afd9650eaed19381076d27c818ecad41d243a5ac8">SYSCON_PERIPHERAL_RESET_I2C0</a>);</div><div class="line"></div><div class="line">    <a class="code" href="a00453.html#gab79263d278814945df2cd44c5db7b514">Chip_I2C_Init</a>(<a class="code" href="a00453.html#gga1c03245782af1bec5eaaf1f54207cfc2a8b606b29817406621b85b78b1ee9e653">I2C0</a>);</div><div class="line">    <a class="code" href="a00453.html#ga17fac5d72058db8eed11d247e78b74ed">Chip_I2C_SetClockRate</a>(<a class="code" href="a00453.html#gga1c03245782af1bec5eaaf1f54207cfc2a8b606b29817406621b85b78b1ee9e653">I2C0</a>, 100000);</div><div class="line"></div><div class="line">    <a class="code" href="a00453.html#ga1fc3fc0946344e9551d9eef0bbf610b9">Chip_I2C_SetMasterEventHandler</a>(<a class="code" href="a00453.html#gga1c03245782af1bec5eaaf1f54207cfc2a8b606b29817406621b85b78b1ee9e653">I2C0</a>, <a class="code" href="a00453.html#ga06b84fe3fad7ffd4ccb93f2683781936">Chip_I2C_EventHandler</a>); <span class="comment">/* Using the default I2C event handler */</span></div><div class="line">    <a class="code" href="a00446.html#gaa7a55182d0998e1ea13efd6875167cf0">NVIC_EnableIRQ</a>(<a class="code" href="a00435.html#gga7e1129cd8a196f4284d41db3e82ad5c8a0f1945c7372a6de732306ea3801c8e2a">I2C0_IRQn</a>);</div><div class="line"></div><div class="line">    <a class="code" href="a00453.html#a00642">I2C_XFER_T</a> masterXfer;</div><div class="line">    masterXfer.<a class="code" href="a00453.html#a771bfcb0b066269afae6905ce5804c89">slaveAddr</a> = 0x7F;</div><div class="line">    masterXfer.<a class="code" href="a00453.html#a0aa410ff8cbc01a00b2fa2189e1c2938">rxBuff</a> = masterRxData;</div><div class="line">    masterXfer.<a class="code" href="a00453.html#a745e2b08d1a5413929a13d9aa30137c5">rxSz</a> = <span class="keyword">sizeof</span>(masterRxData);</div><div class="line">    masterXfer.<a class="code" href="a00453.html#aa273a5a6ef5e2426562692030769f5d8">txBuff</a> = masterTxData;</div><div class="line">    masterXfer.<a class="code" href="a00453.html#a3d14f9d3bba338401b8f8b0ff6ec0ea0">txSz</a> = <span class="keyword">sizeof</span>(masterTxData);</div><div class="line"></div><div class="line">    <a class="code" href="a00453.html#ga05710be20b72b425aac66bb3def57aaf">Chip_I2C_MasterTransfer</a>(<a class="code" href="a00453.html#gga1c03245782af1bec5eaaf1f54207cfc2a8b606b29817406621b85b78b1ee9e653">I2C0</a>, &amp;masterXfer);</div></div><!-- fragment --> <dl class="section user"><dt>I2C IRQ Handler</dt><dd><div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="a00481.html#ga8e817e99d2a59e5f48e4ff0c79e7eef5">I2C0_IRQHandler</a>(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <span class="keywordflow">if</span> (<a class="code" href="a00453.html#ga5fdf29aff7847c93373cf02da41285e1">Chip_I2C_IsMasterActive</a>(<a class="code" href="a00453.html#gga1c03245782af1bec5eaaf1f54207cfc2a8b606b29817406621b85b78b1ee9e653">I2C0</a>)) {</div><div class="line">        <a class="code" href="a00453.html#ga179362e42a3de931ff7f57ca698254fa">Chip_I2C_MasterStateHandler</a>(<a class="code" href="a00453.html#gga1c03245782af1bec5eaaf1f54207cfc2a8b606b29817406621b85b78b1ee9e653">I2C0</a>);</div><div class="line">    }</div><div class="line">    <span class="keywordflow">else</span> {</div><div class="line">        <a class="code" href="a00453.html#ga650618a5f4717c46ae3ea304142ddc03">Chip_I2C_SlaveStateHandler</a>(<a class="code" href="a00453.html#gga1c03245782af1bec5eaaf1f54207cfc2a8b606b29817406621b85b78b1ee9e653">I2C0</a>);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This IRQ Handler is common for Example 1 and Example 2.</dd></dl>
<dl class="section user"><dt>Example 2 - Configuring I2C as Slave and transfer data</dt><dd><ul>
<li>Slave mode</li>
<li>System clock: 4000000 and I2C clock: 100000</li>
<li>SlaveAddr: 0x7f</li>
<li>Operating mode: Interrupt based</li>
<li>API used for slave setup: <a class="el" href="a00453.html#gaf6ea40668dde26e406f76ff3ddeda527">Chip_I2C_SlaveSetup</a></li>
<li>Slave event handler: Example2_I2cSlaveEventHandler</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>User can select appropriate System and I2C clocks as mentioned at <a class="el" href="a00453.html#I2CClockRates_anchor">I2C clock rates</a>.</dd></dl>
<p>Tx, Rx and I2C transfer data structures: </p><div class="fragment"><div class="line">uint8_t slaveTxData[4] = {0xA8, 0x01, 0xC5, 0x9D};</div><div class="line">uint8_t slaveRxData[4] = {0, 0, 0, 0};</div></div><!-- fragment --><p> Slave event handler: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> Example2_I2cSlaveEventHandler(<a class="code" href="a00453.html#ga1c03245782af1bec5eaaf1f54207cfc2">I2C_ID_T</a> <span class="keywordtype">id</span>, <a class="code" href="a00453.html#gacb2cd4e03ea48339d327e4f387441bf3">I2C_EVENT_T</a> event)</div><div class="line">{</div><div class="line">    <span class="comment">/* Perform custom slave event handling */</span></div><div class="line">}</div></div><!-- fragment --><p> Setup and transfer of data: </p><div class="fragment"><div class="line">    <a class="code" href="a00456.html#ga84a821f0ee6888a3b284646a8cd126ae">Chip_IOCON_Init</a>(<a class="code" href="a00433.html#ga9f6e80f81c74d0d95a79e92ed670f1b3">NSS_IOCON</a>); <span class="comment">/* Is normally already called during board initialization. */</span></div><div class="line">    <a class="code" href="a00456.html#ga426cc484a31e59241f87215e5e452c56">Chip_IOCON_SetPinConfig</a>(<a class="code" href="a00433.html#ga9f6e80f81c74d0d95a79e92ed670f1b3">NSS_IOCON</a>, <a class="code" href="a00456.html#gga42905d0e658c71f0b5a26aac076744ccadc5e393f0b084a938e709e39b1f9de94">IOCON_PIO0_4</a>, <a class="code" href="a00456.html#ga21f911561fcda012327bf35bae68dcb6">IOCON_FUNC_1</a> | <a class="code" href="a00456.html#gae31150b0ceb2084d0a2986bbd83a5550">IOCON_I2CMODE_STDFAST</a>);</div><div class="line">    <a class="code" href="a00456.html#ga426cc484a31e59241f87215e5e452c56">Chip_IOCON_SetPinConfig</a>(<a class="code" href="a00433.html#ga9f6e80f81c74d0d95a79e92ed670f1b3">NSS_IOCON</a>, <a class="code" href="a00456.html#gga42905d0e658c71f0b5a26aac076744ccaf2094661f822d1299bd851ea1e6c0b01">IOCON_PIO0_5</a>, <a class="code" href="a00456.html#ga21f911561fcda012327bf35bae68dcb6">IOCON_FUNC_1</a> | <a class="code" href="a00456.html#gae31150b0ceb2084d0a2986bbd83a5550">IOCON_I2CMODE_STDFAST</a>);</div><div class="line"></div><div class="line">    <a class="code" href="a00434.html#ga8de42eae27a7e7c300f1f57da9e56bb2">Chip_Clock_System_SetClockFreq</a>(4000000);</div><div class="line"></div><div class="line">    <a class="code" href="a00461.html#ga8a51b8eff23cfdea04a8da6af66c5a5f">Chip_SysCon_Peripheral_DeassertReset</a>(<a class="code" href="a00461.html#gga647a7639a3ebb94d5910d8c8afd9650eaed19381076d27c818ecad41d243a5ac8">SYSCON_PERIPHERAL_RESET_I2C0</a>);</div><div class="line"></div><div class="line">    <a class="code" href="a00453.html#gab79263d278814945df2cd44c5db7b514">Chip_I2C_Init</a>(<a class="code" href="a00453.html#gga1c03245782af1bec5eaaf1f54207cfc2a8b606b29817406621b85b78b1ee9e653">I2C0</a>);</div><div class="line">    <a class="code" href="a00453.html#ga17fac5d72058db8eed11d247e78b74ed">Chip_I2C_SetClockRate</a>(<a class="code" href="a00453.html#gga1c03245782af1bec5eaaf1f54207cfc2a8b606b29817406621b85b78b1ee9e653">I2C0</a>, 100000);</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <a class="code" href="a00453.html#a00642">I2C_XFER_T</a> slaveXfer;</div><div class="line">    slaveXfer.<a class="code" href="a00453.html#a771bfcb0b066269afae6905ce5804c89">slaveAddr</a> = 0x7F &lt;&lt; 1;</div><div class="line">    slaveXfer.<a class="code" href="a00453.html#a0aa410ff8cbc01a00b2fa2189e1c2938">rxBuff</a> = &amp;slaveRxData[0];</div><div class="line">    slaveXfer.<a class="code" href="a00453.html#a745e2b08d1a5413929a13d9aa30137c5">rxSz</a> = <span class="keyword">sizeof</span>(slaveRxData) + 1; <span class="comment">/* +1: the address byte is counted but not copied to rxBuff */</span></div><div class="line">    slaveXfer.<a class="code" href="a00453.html#aa273a5a6ef5e2426562692030769f5d8">txBuff</a> = &amp;slaveTxData[0];</div><div class="line">    slaveXfer.<a class="code" href="a00453.html#a3d14f9d3bba338401b8f8b0ff6ec0ea0">txSz</a> = <span class="keyword">sizeof</span>(slaveTxData);</div><div class="line"></div><div class="line">    <a class="code" href="a00453.html#gaf6ea40668dde26e406f76ff3ddeda527">Chip_I2C_SlaveSetup</a>(<a class="code" href="a00453.html#gga1c03245782af1bec5eaaf1f54207cfc2a8b606b29817406621b85b78b1ee9e653">I2C0</a>, <a class="code" href="a00453.html#gga5fb1ba338fb3822bb6ca012adc4194bfad17f6d6b2d217b84307c502108a6fed6">I2C_SLAVE_0</a>, &amp;slaveXfer, Example2_I2cSlaveEventHandler, 0);</div><div class="line"></div><div class="line">    <a class="code" href="a00446.html#gaa7a55182d0998e1ea13efd6875167cf0">NVIC_EnableIRQ</a>(<a class="code" href="a00435.html#gga7e1129cd8a196f4284d41db3e82ad5c8a0f1945c7372a6de732306ea3801c8e2a">I2C0_IRQn</a>);</div></div><!-- fragment --><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:a00638"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00453.html#a00638">NSS_I2C_T</a></td></tr>
<tr class="separator:a00638"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00642"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00453.html#a00642">I2C_XFER_T</a></td></tr>
<tr class="separator:a00642"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gaef152f4dc1487d90573810007489082e"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00453.html#gaef152f4dc1487d90573810007489082e">I2C_EVENTHANDLER_T</a>) (<a class="el" href="a00453.html#ga1c03245782af1bec5eaaf1f54207cfc2">I2C_ID_T</a>, <a class="el" href="a00453.html#gacb2cd4e03ea48339d327e4f387441bf3">I2C_EVENT_T</a>)</td></tr>
<tr class="separator:gaef152f4dc1487d90573810007489082e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga5fb1ba338fb3822bb6ca012adc4194bf"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00453.html#ga5fb1ba338fb3822bb6ca012adc4194bf">I2C_SLAVE_ID</a> { <br />
&#160;&#160;<a class="el" href="a00453.html#gga5fb1ba338fb3822bb6ca012adc4194bfa7d2284af5f49b5b9df2582a31fff6370">I2C_SLAVE_GENERAL</a>, 
<br />
&#160;&#160;<a class="el" href="a00453.html#gga5fb1ba338fb3822bb6ca012adc4194bfad17f6d6b2d217b84307c502108a6fed6">I2C_SLAVE_0</a>, 
<br />
&#160;&#160;<a class="el" href="a00453.html#gga5fb1ba338fb3822bb6ca012adc4194bfa8a4d6db2156bad4cf8c21226be564fe2">I2C_SLAVE_1</a>, 
<br />
&#160;&#160;<a class="el" href="a00453.html#gga5fb1ba338fb3822bb6ca012adc4194bfab6d7a585cfa1106eb290fa9f302c5783">I2C_SLAVE_2</a>, 
<br />
&#160;&#160;<a class="el" href="a00453.html#gga5fb1ba338fb3822bb6ca012adc4194bfaf5cff98e9db3da7cc50edd21d3873efd">I2C_SLAVE_3</a>, 
<br />
&#160;&#160;<a class="el" href="a00453.html#gga5fb1ba338fb3822bb6ca012adc4194bfabdb0d442b75f2dbdb63aed5a307de077">I2C_SLAVE_NUM_INTERFACE</a>
<br />
 }</td></tr>
<tr class="separator:ga5fb1ba338fb3822bb6ca012adc4194bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga21aa839302786105dcf6a96be0e6e8bc"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00453.html#ga21aa839302786105dcf6a96be0e6e8bc">I2C_STATUS_T</a> { <br />
&#160;&#160;<a class="el" href="a00453.html#gga21aa839302786105dcf6a96be0e6e8bca9f5024a35710b260041d351d794afa9a">I2C_STATUS_DONE</a>, 
<br />
&#160;&#160;<a class="el" href="a00453.html#gga21aa839302786105dcf6a96be0e6e8bcac41be4d0689494327d4dae20504c854d">I2C_STATUS_NAK</a>, 
<br />
&#160;&#160;<a class="el" href="a00453.html#gga21aa839302786105dcf6a96be0e6e8bca674732e92811621ed2ca34b9e40ca724">I2C_STATUS_ARBLOST</a>, 
<br />
&#160;&#160;<a class="el" href="a00453.html#gga21aa839302786105dcf6a96be0e6e8bca803d8563e2b11514ba4549763ad441f5">I2C_STATUS_BUSERR</a>, 
<br />
&#160;&#160;<a class="el" href="a00453.html#gga21aa839302786105dcf6a96be0e6e8bcab3dd2c4a10e92ca1a5cb580501bad817">I2C_STATUS_BUSY</a>
<br />
 }</td></tr>
<tr class="separator:ga21aa839302786105dcf6a96be0e6e8bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c03245782af1bec5eaaf1f54207cfc2"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00453.html#ga1c03245782af1bec5eaaf1f54207cfc2">I2C_ID_T</a> { <br />
&#160;&#160;<a class="el" href="a00453.html#gga1c03245782af1bec5eaaf1f54207cfc2a8b606b29817406621b85b78b1ee9e653">I2C0</a>, 
<br />
&#160;&#160;<a class="el" href="a00453.html#gga1c03245782af1bec5eaaf1f54207cfc2a84f3a2e3885474dda12c3d223eef5304">I2C_NUM_INTERFACE</a>
<br />
 }</td></tr>
<tr class="separator:ga1c03245782af1bec5eaaf1f54207cfc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb2cd4e03ea48339d327e4f387441bf3"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00453.html#gacb2cd4e03ea48339d327e4f387441bf3">I2C_EVENT_T</a> { <br />
&#160;&#160;<a class="el" href="a00453.html#ggacb2cd4e03ea48339d327e4f387441bf3a565d2f9e44285e1965deb390497f62ac">I2C_EVENT_WAIT</a> = 1, 
<br />
&#160;&#160;<a class="el" href="a00453.html#ggacb2cd4e03ea48339d327e4f387441bf3a43d00f7d92100d4af6df5514e4ccf1d1">I2C_EVENT_DONE</a>, 
<br />
&#160;&#160;<a class="el" href="a00453.html#ggacb2cd4e03ea48339d327e4f387441bf3acec197aede70fe12008a68435bf5f339">I2C_EVENT_LOCK</a>, 
<br />
&#160;&#160;<a class="el" href="a00453.html#ggacb2cd4e03ea48339d327e4f387441bf3aae6af45644ff5abf7016b5a8e8f41393">I2C_EVENT_UNLOCK</a>, 
<br />
&#160;&#160;<a class="el" href="a00453.html#ggacb2cd4e03ea48339d327e4f387441bf3a290fcc1bb657102af26daa1b84472848">I2C_EVENT_SLAVE_RX</a>, 
<br />
&#160;&#160;<a class="el" href="a00453.html#ggacb2cd4e03ea48339d327e4f387441bf3a3911d9b6505f77f0bed3f21b2710ca58">I2C_EVENT_SLAVE_TX</a>
<br />
 }</td></tr>
<tr class="separator:gacb2cd4e03ea48339d327e4f387441bf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gab79263d278814945df2cd44c5db7b514"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00453.html#gab79263d278814945df2cd44c5db7b514">Chip_I2C_Init</a> (<a class="el" href="a00453.html#ga1c03245782af1bec5eaaf1f54207cfc2">I2C_ID_T</a> id)</td></tr>
<tr class="separator:gab79263d278814945df2cd44c5db7b514"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga334c2c12edda443a7e949a1ea4a6a646"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00453.html#ga334c2c12edda443a7e949a1ea4a6a646">Chip_I2C_DeInit</a> (<a class="el" href="a00453.html#ga1c03245782af1bec5eaaf1f54207cfc2">I2C_ID_T</a> id)</td></tr>
<tr class="separator:ga334c2c12edda443a7e949a1ea4a6a646"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga17fac5d72058db8eed11d247e78b74ed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00453.html#ga17fac5d72058db8eed11d247e78b74ed">Chip_I2C_SetClockRate</a> (<a class="el" href="a00453.html#ga1c03245782af1bec5eaaf1f54207cfc2">I2C_ID_T</a> id, uint32_t clockrate)</td></tr>
<tr class="separator:ga17fac5d72058db8eed11d247e78b74ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b13511432337d21b8cd325651cc5b63"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00453.html#ga6b13511432337d21b8cd325651cc5b63">Chip_I2C_GetClockRate</a> (<a class="el" href="a00453.html#ga1c03245782af1bec5eaaf1f54207cfc2">I2C_ID_T</a> id)</td></tr>
<tr class="separator:ga6b13511432337d21b8cd325651cc5b63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga05710be20b72b425aac66bb3def57aaf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00453.html#ga21aa839302786105dcf6a96be0e6e8bc">I2C_STATUS_T</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00453.html#ga05710be20b72b425aac66bb3def57aaf">Chip_I2C_MasterTransfer</a> (<a class="el" href="a00453.html#ga1c03245782af1bec5eaaf1f54207cfc2">I2C_ID_T</a> id, <a class="el" href="a00453.html#a00642">I2C_XFER_T</a> *xfer)</td></tr>
<tr class="separator:ga05710be20b72b425aac66bb3def57aaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga889826ff1209ef05d260ac2cbc7d0069"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00453.html#ga889826ff1209ef05d260ac2cbc7d0069">Chip_I2C_MasterSend</a> (<a class="el" href="a00453.html#ga1c03245782af1bec5eaaf1f54207cfc2">I2C_ID_T</a> id, uint8_t slaveAddr, const uint8_t *buff, int len)</td></tr>
<tr class="separator:ga889826ff1209ef05d260ac2cbc7d0069"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad31b605d03e23e050b7b85b1d2ad0d8c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00453.html#gad31b605d03e23e050b7b85b1d2ad0d8c">Chip_I2C_MasterCmdRead</a> (<a class="el" href="a00453.html#ga1c03245782af1bec5eaaf1f54207cfc2">I2C_ID_T</a> id, uint8_t slaveAddr, uint8_t *cmdBuff, uint8_t *buff, int len)</td></tr>
<tr class="separator:gad31b605d03e23e050b7b85b1d2ad0d8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafad03b4f6c0ecb3f59f014ab63bfda5c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00453.html#gaef152f4dc1487d90573810007489082e">I2C_EVENTHANDLER_T</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00453.html#gafad03b4f6c0ecb3f59f014ab63bfda5c">Chip_I2C_GetMasterEventHandler</a> (<a class="el" href="a00453.html#ga1c03245782af1bec5eaaf1f54207cfc2">I2C_ID_T</a> id)</td></tr>
<tr class="separator:gafad03b4f6c0ecb3f59f014ab63bfda5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1fc3fc0946344e9551d9eef0bbf610b9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00453.html#ga1fc3fc0946344e9551d9eef0bbf610b9">Chip_I2C_SetMasterEventHandler</a> (<a class="el" href="a00453.html#ga1c03245782af1bec5eaaf1f54207cfc2">I2C_ID_T</a> id, <a class="el" href="a00453.html#gaef152f4dc1487d90573810007489082e">I2C_EVENTHANDLER_T</a> event)</td></tr>
<tr class="separator:ga1fc3fc0946344e9551d9eef0bbf610b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae816049843eb162c803b5058ebd9a25c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00453.html#gae816049843eb162c803b5058ebd9a25c">Chip_I2C_MasterRead</a> (<a class="el" href="a00453.html#ga1c03245782af1bec5eaaf1f54207cfc2">I2C_ID_T</a> id, uint8_t slaveAddr, uint8_t *buff, int len)</td></tr>
<tr class="separator:gae816049843eb162c803b5058ebd9a25c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa89a66d658a41325b3c5e56bc059401"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00453.html#gaaa89a66d658a41325b3c5e56bc059401">Chip_I2C_EventHandlerPolling</a> (<a class="el" href="a00453.html#ga1c03245782af1bec5eaaf1f54207cfc2">I2C_ID_T</a> id, <a class="el" href="a00453.html#gacb2cd4e03ea48339d327e4f387441bf3">I2C_EVENT_T</a> event)</td></tr>
<tr class="separator:gaaa89a66d658a41325b3c5e56bc059401"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06b84fe3fad7ffd4ccb93f2683781936"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00453.html#ga06b84fe3fad7ffd4ccb93f2683781936">Chip_I2C_EventHandler</a> (<a class="el" href="a00453.html#ga1c03245782af1bec5eaaf1f54207cfc2">I2C_ID_T</a> id, <a class="el" href="a00453.html#gacb2cd4e03ea48339d327e4f387441bf3">I2C_EVENT_T</a> event)</td></tr>
<tr class="separator:ga06b84fe3fad7ffd4ccb93f2683781936"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga179362e42a3de931ff7f57ca698254fa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00453.html#ga179362e42a3de931ff7f57ca698254fa">Chip_I2C_MasterStateHandler</a> (<a class="el" href="a00453.html#ga1c03245782af1bec5eaaf1f54207cfc2">I2C_ID_T</a> id)</td></tr>
<tr class="separator:ga179362e42a3de931ff7f57ca698254fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga68f1d630224edab35ba796373c5867c0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00453.html#ga68f1d630224edab35ba796373c5867c0">Chip_I2C_Disable</a> (<a class="el" href="a00453.html#ga1c03245782af1bec5eaaf1f54207cfc2">I2C_ID_T</a> id)</td></tr>
<tr class="separator:ga68f1d630224edab35ba796373c5867c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5fdf29aff7847c93373cf02da41285e1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00453.html#ga5fdf29aff7847c93373cf02da41285e1">Chip_I2C_IsMasterActive</a> (<a class="el" href="a00453.html#ga1c03245782af1bec5eaaf1f54207cfc2">I2C_ID_T</a> id)</td></tr>
<tr class="separator:ga5fdf29aff7847c93373cf02da41285e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf6ea40668dde26e406f76ff3ddeda527"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00453.html#gaf6ea40668dde26e406f76ff3ddeda527">Chip_I2C_SlaveSetup</a> (<a class="el" href="a00453.html#ga1c03245782af1bec5eaaf1f54207cfc2">I2C_ID_T</a> id, <a class="el" href="a00453.html#ga5fb1ba338fb3822bb6ca012adc4194bf">I2C_SLAVE_ID</a> sid, <a class="el" href="a00453.html#a00642">I2C_XFER_T</a> *xfer, <a class="el" href="a00453.html#gaef152f4dc1487d90573810007489082e">I2C_EVENTHANDLER_T</a> event, uint8_t addrMask)</td></tr>
<tr class="separator:gaf6ea40668dde26e406f76ff3ddeda527"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga650618a5f4717c46ae3ea304142ddc03"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00453.html#ga650618a5f4717c46ae3ea304142ddc03">Chip_I2C_SlaveStateHandler</a> (<a class="el" href="a00453.html#ga1c03245782af1bec5eaaf1f54207cfc2">I2C_ID_T</a> id)</td></tr>
<tr class="separator:ga650618a5f4717c46ae3ea304142ddc03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4240d03d5dda43ddc8afd527b3172318"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00453.html#ga4240d03d5dda43ddc8afd527b3172318">Chip_I2C_IsStateChanged</a> (<a class="el" href="a00453.html#ga1c03245782af1bec5eaaf1f54207cfc2">I2C_ID_T</a> id)</td></tr>
<tr class="separator:ga4240d03d5dda43ddc8afd527b3172318"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<hr/><h2 class="groupheader">Data Structure Documentation</h2>
<a name="a00638" id="a00638"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00638">&#9670;&nbsp;</a></span>NSS_I2C_T</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct NSS_I2C_T</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>I2C register block structure. </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a48a487253b2e87b303396c5082690aa2"></a><a class="el" href="a00437.html#gaec43007d9998a0a0e01faede4133d6be">__IO</a> uint32_t</td>
<td class="fieldname">
CONSET</td>
<td class="fielddoc">
<p>I2C Control Set Register. When a one is written to a bit of this register, the corresponding bit in the I2C control register is set. Writing a zero has no effect on the corresponding bit in the I2C control register. </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a9d37b00631f37ab3e4a127a7fee46da7"></a><a class="el" href="a00437.html#gaf63697ed9952cc71e1225efe205f6cd3">__I</a> uint32_t</td>
<td class="fieldname">
STAT</td>
<td class="fielddoc">
<p>I2C Status Register. During I2C operation, this register provides detailed status codes that allow software to determine the next action needed. </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a936ba4d835b77f18994c86e64b2392b1"></a><a class="el" href="a00437.html#gaec43007d9998a0a0e01faede4133d6be">__IO</a> uint32_t</td>
<td class="fieldname">
DAT</td>
<td class="fielddoc">
<p>I2C Data Register. During master or slave transmit mode, data to be transmitted is written to this register. During master or slave receive mode, data that has been received can be read from this register. </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a9270d13a7f2f6699e6850efd2da81408"></a><a class="el" href="a00437.html#gaec43007d9998a0a0e01faede4133d6be">__IO</a> uint32_t</td>
<td class="fieldname">
ADR0</td>
<td class="fielddoc">
<p>I2C Slave Address Register 0. Contains the 7-bit slave address for operation of the I2C interface in slave mode, and is not used in master mode. The least significant bit determines whether a slave responds to the General Call address. </p>
</td></tr>
<tr><td class="fieldtype">
<a id="ac1ffb2722b08c7d2ab4545500a362577"></a><a class="el" href="a00437.html#gaec43007d9998a0a0e01faede4133d6be">__IO</a> uint32_t</td>
<td class="fieldname">
SCLH</td>
<td class="fielddoc">
<p>SCH Duty Cycle Register High Half Word. Determines the high time of the I2C clock. </p>
</td></tr>
<tr><td class="fieldtype">
<a id="aee8ea0794273366a8a6998e45ca00929"></a><a class="el" href="a00437.html#gaec43007d9998a0a0e01faede4133d6be">__IO</a> uint32_t</td>
<td class="fieldname">
SCLL</td>
<td class="fielddoc">
<p>SCL Duty Cycle Register Low Half Word. Determines the low time of the I2C clock. SCLL and SCLH together determine the clock frequency generated by an I2C master and certain times used in slave mode. </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a7ff250ae8c92fad81187b4568ca394a3"></a><a class="el" href="a00437.html#ga7e25d9380f9ef903923964322e71f2f6">__O</a> uint32_t</td>
<td class="fieldname">
CONCLR</td>
<td class="fielddoc">
<p>I2C Control Clear Register. When a one is written to a bit of this register, the corresponding bit in the I2C control register is cleared. Writing a zero has no effect on the corresponding bit in the I2C control register. </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a7b8c95de23b4a42be73bcfe8f434b61e"></a><a class="el" href="a00437.html#gaec43007d9998a0a0e01faede4133d6be">__IO</a> uint32_t</td>
<td class="fieldname">
MMCTRL</td>
<td class="fielddoc">
<p>Monitor mode control register. </p>
</td></tr>
<tr><td class="fieldtype">
<a id="af3d33330dee9193734ffbca23c7ed379"></a><a class="el" href="a00437.html#gaec43007d9998a0a0e01faede4133d6be">__IO</a> uint32_t</td>
<td class="fieldname">
ADR1</td>
<td class="fielddoc">
<p>I2C Slave Address Register. Contains the 7-bit slave address for operation of the I2C interface in slave mode, and is not used in master mode. The least significant bit determines whether a slave responds to the General Call address. </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a84a95bb11dc53608632b82f437bfd5a8"></a><a class="el" href="a00437.html#gaec43007d9998a0a0e01faede4133d6be">__IO</a> uint32_t</td>
<td class="fieldname">
ADR2</td>
<td class="fielddoc">
<p>I2C Slave Address Register. Contains the 7-bit slave address for operation of the I2C interface in slave mode, and is not used in master mode. The least significant bit determines whether a slave responds to the General Call address. </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a9822c81e3eadedb60b684dd57631fb7b"></a><a class="el" href="a00437.html#gaec43007d9998a0a0e01faede4133d6be">__IO</a> uint32_t</td>
<td class="fieldname">
ADR3</td>
<td class="fielddoc">
<p>I2C Slave Address Register. Contains the 7-bit slave address for operation of the I2C interface in slave mode, and is not used in master mode. The least significant bit determines whether a slave responds to the General Call address. </p>
</td></tr>
<tr><td class="fieldtype">
<a id="ad18c5b32acbd5ecf72346ba4ca775b6f"></a><a class="el" href="a00437.html#gaf63697ed9952cc71e1225efe205f6cd3">__I</a> uint32_t</td>
<td class="fieldname">
DATA_BUFFER</td>
<td class="fielddoc">
<p>Data buffer register. The contents of the 8 MSBs of the DAT shift register will be transferred to the DATA_BUFFER automatically after every nine bits (8 bits of data plus ACK or NACK) has been received on the bus. </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a1f3bff85f542af4618c6016817bb7b52"></a><a class="el" href="a00437.html#gaec43007d9998a0a0e01faede4133d6be">__IO</a> uint32_t</td>
<td class="fieldname">
MASK[4]</td>
<td class="fielddoc">
<p>I2C Slave address mask register </p>
</td></tr>
</table>

</div>
</div>
<a name="a00642" id="a00642"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00642">&#9670;&nbsp;</a></span>I2C_XFER_T</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct I2C_XFER_T</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Transfer data structure definition. For usage in master transfer, refer to <a class="el" href="a00453.html#ga05710be20b72b425aac66bb3def57aaf">Chip_I2C_MasterTransfer</a>. For usage in slave transfer, refer to <a class="el" href="a00453.html#gaf6ea40668dde26e406f76ff3ddeda527">Chip_I2C_SlaveSetup</a>. </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a771bfcb0b066269afae6905ce5804c89"></a>uint8_t</td>
<td class="fieldname">
slaveAddr</td>
<td class="fielddoc">
<p>7-bit I2C Slave address </p>
</td></tr>
<tr><td class="fieldtype">
<a id="aa273a5a6ef5e2426562692030769f5d8"></a>const uint8_t *</td>
<td class="fieldname">
txBuff</td>
<td class="fielddoc">
<p>Pointer to array of bytes to be transmitted </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a3d14f9d3bba338401b8f8b0ff6ec0ea0"></a>int</td>
<td class="fieldname">
txSz</td>
<td class="fielddoc">
<p>Positive value indicating number of bytes in transmit array, if 0 only reception will be carried on </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a0aa410ff8cbc01a00b2fa2189e1c2938"></a>uint8_t *</td>
<td class="fieldname">
rxBuff</td>
<td class="fielddoc">
<p>Pointer to memory where bytes received from I2C will be stored </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a745e2b08d1a5413929a13d9aa30137c5"></a>int</td>
<td class="fieldname">
rxSz</td>
<td class="fielddoc">
<p>Positive value indicating number of bytes to be received, if 0 only transmission will be carried on </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a30a194e0acd94c980e171b51999d2aa8"></a><a class="el" href="a00453.html#ga21aa839302786105dcf6a96be0e6e8bc">I2C_STATUS_T</a></td>
<td class="fieldname">
status</td>
<td class="fielddoc">
<p>Status of the current I2C transfer, this is read only for user </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="gaef152f4dc1487d90573810007489082e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaef152f4dc1487d90573810007489082e">&#9670;&nbsp;</a></span>I2C_EVENTHANDLER_T</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* I2C_EVENTHANDLER_T) (<a class="el" href="a00453.html#ga1c03245782af1bec5eaaf1f54207cfc2">I2C_ID_T</a>, <a class="el" href="a00453.html#gacb2cd4e03ea48339d327e4f387441bf3">I2C_EVENT_T</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Event handler function type. Use this prototype if you want to define your own event handler using <a class="el" href="a00453.html#ga1fc3fc0946344e9551d9eef0bbf610b9">Chip_I2C_SetMasterEventHandler</a>. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga5fb1ba338fb3822bb6ca012adc4194bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5fb1ba338fb3822bb6ca012adc4194bf">&#9670;&nbsp;</a></span>I2C_SLAVE_ID</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="a00453.html#ga5fb1ba338fb3822bb6ca012adc4194bf">I2C_SLAVE_ID</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>I2C Slave Identifiers. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga5fb1ba338fb3822bb6ca012adc4194bfa7d2284af5f49b5b9df2582a31fff6370"></a>I2C_SLAVE_GENERAL&#160;</td><td class="fielddoc"><p>Slave ID for general calls </p>
</td></tr>
<tr><td class="fieldname"><a id="gga5fb1ba338fb3822bb6ca012adc4194bfad17f6d6b2d217b84307c502108a6fed6"></a>I2C_SLAVE_0&#160;</td><td class="fielddoc"><p>Slave ID for Slave Address 0 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga5fb1ba338fb3822bb6ca012adc4194bfa8a4d6db2156bad4cf8c21226be564fe2"></a>I2C_SLAVE_1&#160;</td><td class="fielddoc"><p>Slave ID for Slave Address 1 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga5fb1ba338fb3822bb6ca012adc4194bfab6d7a585cfa1106eb290fa9f302c5783"></a>I2C_SLAVE_2&#160;</td><td class="fielddoc"><p>Slave ID for Slave Address 2 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga5fb1ba338fb3822bb6ca012adc4194bfaf5cff98e9db3da7cc50edd21d3873efd"></a>I2C_SLAVE_3&#160;</td><td class="fielddoc"><p>Slave ID for Slave Address 3 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga5fb1ba338fb3822bb6ca012adc4194bfabdb0d442b75f2dbdb63aed5a307de077"></a>I2C_SLAVE_NUM_INTERFACE&#160;</td><td class="fielddoc"><p>Number of slave interfaces. Not to be used as a slave ID. Use this for loops or to define array sizes. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga21aa839302786105dcf6a96be0e6e8bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga21aa839302786105dcf6a96be0e6e8bc">&#9670;&nbsp;</a></span>I2C_STATUS_T</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="a00453.html#ga21aa839302786105dcf6a96be0e6e8bc">I2C_STATUS_T</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>I2C transfer status. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga21aa839302786105dcf6a96be0e6e8bca9f5024a35710b260041d351d794afa9a"></a>I2C_STATUS_DONE&#160;</td><td class="fielddoc"><p>Transfer done successfully, used for Master and Slave transfers </p>
</td></tr>
<tr><td class="fieldname"><a id="gga21aa839302786105dcf6a96be0e6e8bcac41be4d0689494327d4dae20504c854d"></a>I2C_STATUS_NAK&#160;</td><td class="fielddoc"><p>NAK received during transfer, used for Master transfer </p>
</td></tr>
<tr><td class="fieldname"><a id="gga21aa839302786105dcf6a96be0e6e8bca674732e92811621ed2ca34b9e40ca724"></a>I2C_STATUS_ARBLOST&#160;</td><td class="fielddoc"><p>Arbitration lost during transfer, used for Master transfer </p>
</td></tr>
<tr><td class="fieldname"><a id="gga21aa839302786105dcf6a96be0e6e8bca803d8563e2b11514ba4549763ad441f5"></a>I2C_STATUS_BUSERR&#160;</td><td class="fielddoc"><p>Bus error in I2C transfer, used for Master transfer </p>
</td></tr>
<tr><td class="fieldname"><a id="gga21aa839302786105dcf6a96be0e6e8bcab3dd2c4a10e92ca1a5cb580501bad817"></a>I2C_STATUS_BUSY&#160;</td><td class="fielddoc"><p>I2C is busy doing transfer, used for Master and Slave transfers </p>
</td></tr>
</table>

</div>
</div>
<a id="ga1c03245782af1bec5eaaf1f54207cfc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1c03245782af1bec5eaaf1f54207cfc2">&#9670;&nbsp;</a></span>I2C_ID_T</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="a00453.html#ga1c03245782af1bec5eaaf1f54207cfc2">I2C_ID_T</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>I2C interface IDs. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga1c03245782af1bec5eaaf1f54207cfc2a8b606b29817406621b85b78b1ee9e653"></a>I2C0&#160;</td><td class="fielddoc"><p>ID I2C0, all Chip functions will take this as the first parameter </p>
</td></tr>
<tr><td class="fieldname"><a id="gga1c03245782af1bec5eaaf1f54207cfc2a84f3a2e3885474dda12c3d223eef5304"></a>I2C_NUM_INTERFACE&#160;</td><td class="fielddoc"><p>Number of I2C interfaces in the chip, must never be used for calling any Chip functions </p>
</td></tr>
</table>

</div>
</div>
<a id="gacb2cd4e03ea48339d327e4f387441bf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacb2cd4e03ea48339d327e4f387441bf3">&#9670;&nbsp;</a></span>I2C_EVENT_T</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="a00453.html#gacb2cd4e03ea48339d327e4f387441bf3">I2C_EVENT_T</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>I2C events. Provides information on the type of event to the event handler functions (<a class="el" href="a00453.html#gaef152f4dc1487d90573810007489082e">I2C_EVENTHANDLER_T</a>). </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggacb2cd4e03ea48339d327e4f387441bf3a565d2f9e44285e1965deb390497f62ac"></a>I2C_EVENT_WAIT&#160;</td><td class="fielddoc"><p>I2C Wait event, triggered when waiting for the status (<a class="el" href="a00453.html#ga21aa839302786105dcf6a96be0e6e8bc">I2C_STATUS_T</a>) to update </p>
</td></tr>
<tr><td class="fieldname"><a id="ggacb2cd4e03ea48339d327e4f387441bf3a43d00f7d92100d4af6df5514e4ccf1d1"></a>I2C_EVENT_DONE&#160;</td><td class="fielddoc"><p>Done event that wakes up Wait event, triggered when master transactions for slave are completed </p>
</td></tr>
<tr><td class="fieldname"><a id="ggacb2cd4e03ea48339d327e4f387441bf3acec197aede70fe12008a68435bf5f339"></a>I2C_EVENT_LOCK&#160;</td><td class="fielddoc"><p>Re-entrancy lock event for I2C transfer, triggered at the beginning of a Master transfer </p>
</td></tr>
<tr><td class="fieldname"><a id="ggacb2cd4e03ea48339d327e4f387441bf3aae6af45644ff5abf7016b5a8e8f41393"></a>I2C_EVENT_UNLOCK&#160;</td><td class="fielddoc"><p>Re-entrancy unlock event for I2C transfer, triggered on completion of a Master transfer </p>
</td></tr>
<tr><td class="fieldname"><a id="ggacb2cd4e03ea48339d327e4f387441bf3a290fcc1bb657102af26daa1b84472848"></a>I2C_EVENT_SLAVE_RX&#160;</td><td class="fielddoc"><p>Slave receive event, triggered on reception of data in Slave </p>
</td></tr>
<tr><td class="fieldname"><a id="ggacb2cd4e03ea48339d327e4f387441bf3a3911d9b6505f77f0bed3f21b2710ca58"></a>I2C_EVENT_SLAVE_TX&#160;</td><td class="fielddoc"><p>Slave transmit event, triggered after data transmitted from Slave </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gab79263d278814945df2cd44c5db7b514"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab79263d278814945df2cd44c5db7b514">&#9670;&nbsp;</a></span>Chip_I2C_Init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Chip_I2C_Init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00453.html#ga1c03245782af1bec5eaaf1f54207cfc2">I2C_ID_T</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes the NSS_I2C peripheral with specified parameter. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>: I2C peripheral ID (<a class="el" href="a00453.html#gga1c03245782af1bec5eaaf1f54207cfc2a8b606b29817406621b85b78b1ee9e653">I2C0</a>) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga334c2c12edda443a7e949a1ea4a6a646"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga334c2c12edda443a7e949a1ea4a6a646">&#9670;&nbsp;</a></span>Chip_I2C_DeInit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Chip_I2C_DeInit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00453.html#ga1c03245782af1bec5eaaf1f54207cfc2">I2C_ID_T</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>De-initializes the I2C peripheral registers to their default reset values </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>: I2C peripheral ID (<a class="el" href="a00453.html#gga1c03245782af1bec5eaaf1f54207cfc2a8b606b29817406621b85b78b1ee9e653">I2C0</a>) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga17fac5d72058db8eed11d247e78b74ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga17fac5d72058db8eed11d247e78b74ed">&#9670;&nbsp;</a></span>Chip_I2C_SetClockRate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Chip_I2C_SetClockRate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00453.html#ga1c03245782af1bec5eaaf1f54207cfc2">I2C_ID_T</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>clockrate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set up clock rate for NSS_I2C peripheral. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>: I2C peripheral ID (<a class="el" href="a00453.html#gga1c03245782af1bec5eaaf1f54207cfc2a8b606b29817406621b85b78b1ee9e653">I2C0</a>) </td></tr>
    <tr><td class="paramname">clockrate</td><td>: Target clock rate value to initialize I2C peripheral (Hz) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Parameter <em>clockrate</em> for <a class="el" href="a00453.html#gga1c03245782af1bec5eaaf1f54207cfc2a8b606b29817406621b85b78b1ee9e653">I2C0</a> must be from 1000 up to 400000 (1 KHz to 400 KHz), as <a class="el" href="a00453.html#gga1c03245782af1bec5eaaf1f54207cfc2a8b606b29817406621b85b78b1ee9e653">I2C0</a> supports Fast Mode. </dd>
<dd>
Refer to <a class="el" href="a00453.html#I2CClockRates_anchor">I2C clock rates</a> for I2C clock restrictions. </dd></dl>

</div>
</div>
<a id="ga6b13511432337d21b8cd325651cc5b63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6b13511432337d21b8cd325651cc5b63">&#9670;&nbsp;</a></span>Chip_I2C_GetClockRate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t Chip_I2C_GetClockRate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00453.html#ga1c03245782af1bec5eaaf1f54207cfc2">I2C_ID_T</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get current clock rate for NSS_I2C peripheral. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>: I2C peripheral ID (<a class="el" href="a00453.html#gga1c03245782af1bec5eaaf1f54207cfc2a8b606b29817406621b85b78b1ee9e653">I2C0</a>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The current I2C peripheral clock rate </dd></dl>

</div>
</div>
<a id="ga05710be20b72b425aac66bb3def57aaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga05710be20b72b425aac66bb3def57aaf">&#9670;&nbsp;</a></span>Chip_I2C_MasterTransfer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00453.html#ga21aa839302786105dcf6a96be0e6e8bc">I2C_STATUS_T</a> Chip_I2C_MasterTransfer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00453.html#ga1c03245782af1bec5eaaf1f54207cfc2">I2C_ID_T</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00453.html#a00642">I2C_XFER_T</a> *&#160;</td>
          <td class="paramname"><em>xfer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Transmit and Receive data in master mode </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>: I2C peripheral selected (<a class="el" href="a00453.html#gga1c03245782af1bec5eaaf1f54207cfc2a8b606b29817406621b85b78b1ee9e653">I2C0</a>) </td></tr>
    <tr><td class="paramname">xfer</td><td>: Pointer to a <a class="el" href="a00453.html#a00642">I2C_XFER_T</a> structure. Details of structure members is captured below:<ul>
<li>slaveAddr : 7-Bit slave address to which the master will do the transfer, bit0 to bit6 should have the address and bit7 is ignored.</li>
<li>txBuff : pointer to the memory from which to pick the data to be transfered to slave</li>
<li>txSz : number of bytes to send</li>
<li>rxBuff : pointer to the memory where data received from slave is to be stored</li>
<li>rxSz : number of bytes to get from slave</li>
</ul>
Refer to <a class="el" href="a00453.html#a00642">I2C_XFER_T</a> for additional information. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Any of <a class="el" href="a00453.html#ga21aa839302786105dcf6a96be0e6e8bc">I2C_STATUS_T</a> values, <a class="el" href="a00453.html#a3d14f9d3bba338401b8f8b0ff6ec0ea0">I2C_XFER_T.txSz</a> will have number of bytes not sent due to error, <a class="el" href="a00453.html#a745e2b08d1a5413929a13d9aa30137c5">I2C_XFER_T.rxSz</a> will have the number of bytes yet to be received. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>During the transfer, program execution (like event handler) must not change the content of the memory pointed to by <em>xfer</em>. </dd>
<dd>
Alternate implementations for Master transfers can be referred from <a class="el" href="a00453.html#ga889826ff1209ef05d260ac2cbc7d0069">Chip_I2C_MasterSend</a> and <a class="el" href="a00453.html#gae816049843eb162c803b5058ebd9a25c">Chip_I2C_MasterRead</a>. </dd></dl>

</div>
</div>
<a id="ga889826ff1209ef05d260ac2cbc7d0069"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga889826ff1209ef05d260ac2cbc7d0069">&#9670;&nbsp;</a></span>Chip_I2C_MasterSend()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Chip_I2C_MasterSend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00453.html#ga1c03245782af1bec5eaaf1f54207cfc2">I2C_ID_T</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>slaveAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>buff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Transmit data to I2C slave using I2C Master mode </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>: I2C peripheral ID (<a class="el" href="a00453.html#gga1c03245782af1bec5eaaf1f54207cfc2a8b606b29817406621b85b78b1ee9e653">I2C0</a>) </td></tr>
    <tr><td class="paramname">slaveAddr</td><td>: Slave address to which the data be written </td></tr>
    <tr><td class="paramname">buff</td><td>: Pointer to buffer having the array of data </td></tr>
    <tr><td class="paramname">len</td><td>: Number of bytes to be transfered from <em>buff</em> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes successfully transfered </dd></dl>

</div>
</div>
<a id="gad31b605d03e23e050b7b85b1d2ad0d8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad31b605d03e23e050b7b85b1d2ad0d8c">&#9670;&nbsp;</a></span>Chip_I2C_MasterCmdRead()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Chip_I2C_MasterCmdRead </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00453.html#ga1c03245782af1bec5eaaf1f54207cfc2">I2C_ID_T</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>slaveAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>cmdBuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Transfer a command to slave and receive data from slave after a repeated start </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>: I2C peripheral ID (<a class="el" href="a00453.html#gga1c03245782af1bec5eaaf1f54207cfc2a8b606b29817406621b85b78b1ee9e653">I2C0</a>) </td></tr>
    <tr><td class="paramname">slaveAddr</td><td>: Slave address of the I2C device </td></tr>
    <tr><td class="paramname">cmdBuff</td><td>: Pointer to command buffer of size one byte </td></tr>
    <tr><td class="paramname">buff</td><td>: Pointer to memory that will hold the data received </td></tr>
    <tr><td class="paramname">len</td><td>: Number of bytes to receive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes successfully received </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is a specific implementation of Master transfer where a specific command can be send by the Master to invoke a pre-defined behavior from the Slave. </dd></dl>

</div>
</div>
<a id="gafad03b4f6c0ecb3f59f014ab63bfda5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafad03b4f6c0ecb3f59f014ab63bfda5c">&#9670;&nbsp;</a></span>Chip_I2C_GetMasterEventHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00453.html#gaef152f4dc1487d90573810007489082e">I2C_EVENTHANDLER_T</a> Chip_I2C_GetMasterEventHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00453.html#ga1c03245782af1bec5eaaf1f54207cfc2">I2C_ID_T</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get pointer to current function handling the events </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>: I2C peripheral ID (<a class="el" href="a00453.html#gga1c03245782af1bec5eaaf1f54207cfc2a8b606b29817406621b85b78b1ee9e653">I2C0</a>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to function handing events of I2C </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The user can also implement an own handler using <a class="el" href="a00453.html#ga1fc3fc0946344e9551d9eef0bbf610b9">Chip_I2C_SetMasterEventHandler</a> API. </dd></dl>

</div>
</div>
<a id="ga1fc3fc0946344e9551d9eef0bbf610b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1fc3fc0946344e9551d9eef0bbf610b9">&#9670;&nbsp;</a></span>Chip_I2C_SetMasterEventHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Chip_I2C_SetMasterEventHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00453.html#ga1c03245782af1bec5eaaf1f54207cfc2">I2C_ID_T</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00453.html#gaef152f4dc1487d90573810007489082e">I2C_EVENTHANDLER_T</a>&#160;</td>
          <td class="paramname"><em>event</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set function that must handle I2C events </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>: I2C peripheral ID (<a class="el" href="a00453.html#gga1c03245782af1bec5eaaf1f54207cfc2a8b606b29817406621b85b78b1ee9e653">I2C0</a>) </td></tr>
    <tr><td class="paramname">event</td><td>: Pointer to function that will handle the event, <a class="el" href="a00453.html#gaef152f4dc1487d90573810007489082e">I2C_EVENTHANDLER_T</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 when successful, 0 when a transfer is on going with its own event handler </dd></dl>
<dl class="section note"><dt>Note</dt><dd><em>event</em> should not be NULL </dd>
<dd>
Live swap of event handlers is not tested. </dd></dl>

</div>
</div>
<a id="gae816049843eb162c803b5058ebd9a25c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae816049843eb162c803b5058ebd9a25c">&#9670;&nbsp;</a></span>Chip_I2C_MasterRead()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Chip_I2C_MasterRead </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00453.html#ga1c03245782af1bec5eaaf1f54207cfc2">I2C_ID_T</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>slaveAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Receive data from I2C slave using I2C Master mode </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>: I2C peripheral ID (<a class="el" href="a00453.html#gga1c03245782af1bec5eaaf1f54207cfc2a8b606b29817406621b85b78b1ee9e653">I2C0</a>) </td></tr>
    <tr><td class="paramname">slaveAddr</td><td>: Slave address from which data be read </td></tr>
    <tr><td class="paramname">buff</td><td>: Pointer to memory where data read be stored </td></tr>
    <tr><td class="paramname">len</td><td>: Number of bytes to read from slave </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes read successfully </dd></dl>

</div>
</div>
<a id="gaaa89a66d658a41325b3c5e56bc059401"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaa89a66d658a41325b3c5e56bc059401">&#9670;&nbsp;</a></span>Chip_I2C_EventHandlerPolling()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Chip_I2C_EventHandlerPolling </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00453.html#ga1c03245782af1bec5eaaf1f54207cfc2">I2C_ID_T</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00453.html#gacb2cd4e03ea48339d327e4f387441bf3">I2C_EVENT_T</a>&#160;</td>
          <td class="paramname"><em>event</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Default event handler for polling operation </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>: I2C peripheral ID (<a class="el" href="a00453.html#gga1c03245782af1bec5eaaf1f54207cfc2a8b606b29817406621b85b78b1ee9e653">I2C0</a>) </td></tr>
    <tr><td class="paramname">event</td><td>: Event ID of the event that called the function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This is the default handler for polling mode where only the <a class="el" href="a00453.html#ggacb2cd4e03ea48339d327e4f387441bf3a565d2f9e44285e1965deb390497f62ac">I2C_EVENT_WAIT</a> state is handled. </dd></dl>

</div>
</div>
<a id="ga06b84fe3fad7ffd4ccb93f2683781936"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga06b84fe3fad7ffd4ccb93f2683781936">&#9670;&nbsp;</a></span>Chip_I2C_EventHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Chip_I2C_EventHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00453.html#ga1c03245782af1bec5eaaf1f54207cfc2">I2C_ID_T</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00453.html#gacb2cd4e03ea48339d327e4f387441bf3">I2C_EVENT_T</a>&#160;</td>
          <td class="paramname"><em>event</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Default event handler for interrupt based operation </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>: I2C peripheral ID (<a class="el" href="a00453.html#gga1c03245782af1bec5eaaf1f54207cfc2a8b606b29817406621b85b78b1ee9e653">I2C0</a>) </td></tr>
    <tr><td class="paramname">event</td><td>: Event ID of the event that called the function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This is the default handler for interrupt mode where only the <a class="el" href="a00453.html#ggacb2cd4e03ea48339d327e4f387441bf3a565d2f9e44285e1965deb390497f62ac">I2C_EVENT_WAIT</a> state is handled. </dd></dl>

</div>
</div>
<a id="ga179362e42a3de931ff7f57ca698254fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga179362e42a3de931ff7f57ca698254fa">&#9670;&nbsp;</a></span>Chip_I2C_MasterStateHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Chip_I2C_MasterStateHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00453.html#ga1c03245782af1bec5eaaf1f54207cfc2">I2C_ID_T</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>I2C Master transfer state change handler </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>: I2C peripheral ID (<a class="el" href="a00453.html#gga1c03245782af1bec5eaaf1f54207cfc2a8b606b29817406621b85b78b1ee9e653">I2C0</a>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>In case of interrupt based operation, this function is to be invoked from the interrupt handler. For the polling based operation, this function is implicitly invoked from <a class="el" href="a00453.html#gaaa89a66d658a41325b3c5e56bc059401">Chip_I2C_EventHandlerPolling</a>. </dd></dl>

</div>
</div>
<a id="ga68f1d630224edab35ba796373c5867c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga68f1d630224edab35ba796373c5867c0">&#9670;&nbsp;</a></span>Chip_I2C_Disable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Chip_I2C_Disable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00453.html#ga1c03245782af1bec5eaaf1f54207cfc2">I2C_ID_T</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Disable I2C peripheral's operation </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>: I2C peripheral ID (<a class="el" href="a00453.html#gga1c03245782af1bec5eaaf1f54207cfc2a8b606b29817406621b85b78b1ee9e653">I2C0</a>) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5fdf29aff7847c93373cf02da41285e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5fdf29aff7847c93373cf02da41285e1">&#9670;&nbsp;</a></span>Chip_I2C_IsMasterActive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Chip_I2C_IsMasterActive </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00453.html#ga1c03245782af1bec5eaaf1f54207cfc2">I2C_ID_T</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks if master transfer in progress </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>: I2C peripheral ID (<a class="el" href="a00453.html#gga1c03245782af1bec5eaaf1f54207cfc2a8b606b29817406621b85b78b1ee9e653">I2C0</a>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if master transfer in progress, 0 for slave transfer </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This API is generally used in interrupt handler of the application to decide whether to call master state handler or to call slave state handler </dd></dl>

</div>
</div>
<a id="gaf6ea40668dde26e406f76ff3ddeda527"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf6ea40668dde26e406f76ff3ddeda527">&#9670;&nbsp;</a></span>Chip_I2C_SlaveSetup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Chip_I2C_SlaveSetup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00453.html#ga1c03245782af1bec5eaaf1f54207cfc2">I2C_ID_T</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00453.html#ga5fb1ba338fb3822bb6ca012adc4194bf">I2C_SLAVE_ID</a>&#160;</td>
          <td class="paramname"><em>sid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00453.html#a00642">I2C_XFER_T</a> *&#160;</td>
          <td class="paramname"><em>xfer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00453.html#gaef152f4dc1487d90573810007489082e">I2C_EVENTHANDLER_T</a>&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>addrMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Setup a slave I2C device </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>: I2C peripheral ID (<a class="el" href="a00453.html#gga1c03245782af1bec5eaaf1f54207cfc2a8b606b29817406621b85b78b1ee9e653">I2C0</a>) </td></tr>
    <tr><td class="paramname">sid</td><td>: I2C Slave peripheral ID (<a class="el" href="a00453.html#ga5fb1ba338fb3822bb6ca012adc4194bf">I2C_SLAVE_ID</a>) </td></tr>
    <tr><td class="paramname">xfer</td><td>: Pointer to transfer structure (<a class="el" href="a00453.html#a00642">I2C_XFER_T</a>). Details of structure members is captured below:<ul>
<li>slaveAddr : 7 bit Slave address (from bit1 to bit7), bit0 when set enables general call handling. This along with <em>addrMask</em> will be used to match the slave address.</li>
<li>txBuff : pointer to valid buffers where slave can send data from</li>
<li>txSz : size of txBuff</li>
<li>rxBuff : pointer to valid buffers where slave can receive data from</li>
<li>rxSz : size of rxBuff</li>
</ul>
</td></tr>
    <tr><td class="paramname">event</td><td>: Event handler for slave transfers (<a class="el" href="a00453.html#gaef152f4dc1487d90573810007489082e">I2C_EVENTHANDLER_T</a>) </td></tr>
    <tr><td class="paramname">addrMask</td><td>: Address mask to use along with slave address, see notes below for more info </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Parameter <em>xfer</em> should point to a valid <a class="el" href="a00453.html#a00642">I2C_XFER_T</a> structure object. <br />
 Function pointed to by <em>event</em> will be called for the following events:<ul>
<li><a class="el" href="a00453.html#ggacb2cd4e03ea48339d327e4f387441bf3a290fcc1bb657102af26daa1b84472848">I2C_EVENT_SLAVE_RX</a> : One byte of data received successfully from the master and stored inside memory pointed by <a class="el" href="a00453.html#a0aa410ff8cbc01a00b2fa2189e1c2938">I2C_XFER_T.rxBuff</a>, incremented the pointer and decremented the <a class="el" href="a00453.html#a745e2b08d1a5413929a13d9aa30137c5">I2C_XFER_T.rxSz</a></li>
<li><a class="el" href="a00453.html#ggacb2cd4e03ea48339d327e4f387441bf3a3911d9b6505f77f0bed3f21b2710ca58">I2C_EVENT_SLAVE_TX</a> : One byte of data from <a class="el" href="a00453.html#aa273a5a6ef5e2426562692030769f5d8">I2C_XFER_T.txBuff</a> was sent to master successfully, incremented the pointer and decremented <a class="el" href="a00453.html#a3d14f9d3bba338401b8f8b0ff6ec0ea0">I2C_XFER_T.txSz</a></li>
<li><a class="el" href="a00453.html#ggacb2cd4e03ea48339d327e4f387441bf3a43d00f7d92100d4af6df5514e4ccf1d1">I2C_EVENT_DONE</a> : Master is done doing its transfers with the slave</li>
</ul>
Bit-0 of the parameter <em>addrMask</em> is reserved and should always be 0. Any bit (BIT1 to BIT7) set in <em>addrMask</em> will make the corresponding bit in <a class="el" href="a00453.html#a771bfcb0b066269afae6905ce5804c89">I2C_XFER_T.slaveAddr</a> as don't care, that is, if <a class="el" href="a00453.html#a771bfcb0b066269afae6905ce5804c89">I2C_XFER_T.slaveAddr</a> is (0x10 &lt;&lt; 1) and <em>addrMask</em> is (0x03 &lt;&lt; 1) then 0x10, 0x11, 0x12, 0x13 will all be considered as valid slave addresses for the registered slave. Upon receiving any event <a class="el" href="a00453.html#a771bfcb0b066269afae6905ce5804c89">I2C_XFER_T.slaveAddr</a> (BIT1 to BIT7) will hold the actual address which was received from master. <br />
 <br />
 <b>General Call Handling</b> <br />
 Slave can receive data from master using general call address (0x00). General call handling must be setup as given below<ul>
<li>Call <a class="el" href="a00453.html#gaf6ea40668dde26e406f76ff3ddeda527">Chip_I2C_SlaveSetup()</a> with argument <em>sid</em> as <a class="el" href="a00453.html#gga5fb1ba338fb3822bb6ca012adc4194bfa7d2284af5f49b5b9df2582a31fff6370">I2C_SLAVE_GENERAL</a><ul>
<li><a class="el" href="a00453.html#a771bfcb0b066269afae6905ce5804c89">I2C_XFER_T.slaveAddr</a> ignored, argument <em>addrMask</em> ignored</li>
<li>function provided by <em>event</em> will registered to be called when slave received data using addr 0x00</li>
<li><a class="el" href="a00453.html#a0aa410ff8cbc01a00b2fa2189e1c2938">I2C_XFER_T.rxBuff</a> and <a class="el" href="a00453.html#a745e2b08d1a5413929a13d9aa30137c5">I2C_XFER_T.rxSz</a> should be valid in argument <em>xfer</em> </li>
</ul>
</li>
<li>To handle General Call only (No other slaves are configured)<ul>
<li>Call <a class="el" href="a00453.html#gaf6ea40668dde26e406f76ff3ddeda527">Chip_I2C_SlaveSetup()</a> with sid as I2C_SLAVE_X (X=0,1,2,3)</li>
<li>setup <em>xfer</em> with slaveAddr member set to 0, <em>event</em> is ignored hence can be NULL</li>
<li>provide <em>addrMask</em> (typically 0, if not you better be knowing what you are doing)</li>
</ul>
</li>
<li>To handle General Call when other slave is active<ul>
<li>Call <a class="el" href="a00453.html#gaf6ea40668dde26e406f76ff3ddeda527">Chip_I2C_SlaveSetup()</a> with sid as I2C_SLAVE_X (X=0,1,2,3)</li>
<li>setup <em>xfer</em> with slaveAddr member set to 7-Bit Slave address [from Bit1 to 7]</li>
<li>Set Bit0 of <em>xfer-&gt;slaveAddr</em> as 1</li>
<li>Provide appropriate <em>addrMask</em> </li>
<li>Argument <em>event</em> must point to function, that handles events from actual slaveAddress and not the GC</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>If the slave has only one byte left in its <a class="el" href="a00453.html#aa273a5a6ef5e2426562692030769f5d8">I2C_XFER_T.txBuff</a>, once that byte is transfered to master the event handler will be called for event <a class="el" href="a00453.html#ggacb2cd4e03ea48339d327e4f387441bf3a43d00f7d92100d4af6df5514e4ccf1d1">I2C_EVENT_DONE</a>. If the master attempts to read more bytes in the same transfer then the slave hardware will send 0xFF to master till the end of transfer, event handler will not be called to notify this. For more info see section below <br />
 <br />
 <b> Last data handling in slave </b> <br />
 If the user wants to implement a slave which will read a byte from a specific location over and over again whenever master reads the slave. If the user initializes the <a class="el" href="a00453.html#aa273a5a6ef5e2426562692030769f5d8">I2C_XFER_T.txBuff</a> as the location to read the byte from and <a class="el" href="a00453.html#a3d14f9d3bba338401b8f8b0ff6ec0ea0">I2C_XFER_T.txSz</a> as 1, then say, if master reads one byte; slave will send the byte read from <a class="el" href="a00453.html#aa273a5a6ef5e2426562692030769f5d8">I2C_XFER_T.txBuff</a> and will call the event handler with <a class="el" href="a00453.html#ggacb2cd4e03ea48339d327e4f387441bf3a43d00f7d92100d4af6df5514e4ccf1d1">I2C_EVENT_DONE</a>. If the master attempts to read another byte instead of sending the byte read from <a class="el" href="a00453.html#aa273a5a6ef5e2426562692030769f5d8">I2C_XFER_T.txBuff</a> the slave hardware will send 0xFF and no event will occur. To handle this issue, slave should set <a class="el" href="a00453.html#a3d14f9d3bba338401b8f8b0ff6ec0ea0">I2C_XFER_T.txSz</a> to 2, in which case when master reads the byte event handler will be called with <a class="el" href="a00453.html#ggacb2cd4e03ea48339d327e4f387441bf3a3911d9b6505f77f0bed3f21b2710ca58">I2C_EVENT_SLAVE_TX</a>, in which the slave implementation can reset the buffer and size back to original location (i.e, <a class="el" href="a00453.html#aa273a5a6ef5e2426562692030769f5d8">I2C_XFER_T.txBuff</a>&ndash;, <a class="el" href="a00453.html#a3d14f9d3bba338401b8f8b0ff6ec0ea0">I2C_XFER_T.txSz</a>++), if the master reads another byte in the same transfer, byte read from <a class="el" href="a00453.html#aa273a5a6ef5e2426562692030769f5d8">I2C_XFER_T.txBuff</a> will be sent and <a class="el" href="a00453.html#ggacb2cd4e03ea48339d327e4f387441bf3a3911d9b6505f77f0bed3f21b2710ca58">I2C_EVENT_SLAVE_TX</a> will be called again, and the process repeats. </dd></dl>

</div>
</div>
<a id="ga650618a5f4717c46ae3ea304142ddc03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga650618a5f4717c46ae3ea304142ddc03">&#9670;&nbsp;</a></span>Chip_I2C_SlaveStateHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Chip_I2C_SlaveStateHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00453.html#ga1c03245782af1bec5eaaf1f54207cfc2">I2C_ID_T</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>I2C Slave event handler </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>: I2C peripheral ID (<a class="el" href="a00453.html#gga1c03245782af1bec5eaaf1f54207cfc2a8b606b29817406621b85b78b1ee9e653">I2C0</a>) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4240d03d5dda43ddc8afd527b3172318"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4240d03d5dda43ddc8afd527b3172318">&#9670;&nbsp;</a></span>Chip_I2C_IsStateChanged()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Chip_I2C_IsStateChanged </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00453.html#ga1c03245782af1bec5eaaf1f54207cfc2">I2C_ID_T</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>I2C peripheral state change checking </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>: I2C peripheral ID (<a class="el" href="a00453.html#gga1c03245782af1bec5eaaf1f54207cfc2a8b606b29817406621b85b78b1ee9e653">I2C0</a>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if I2C peripheral <em>id</em> has changed its state, 0 if there is no state change </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is applicable for polling mode and must be used by the application when the polling has to be done based on state change. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Tue Oct 20 2020 08:24:34 for NHS31xx SW API by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.14 </li>
  </ul>
</div>
</body>
</html>
