<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NHS31xx storage - Maximizing storage for equisized samples: Diversity Settings</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="nxp-logo_small.jpg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NHS31xx storage - Maximizing storage for equisized samples
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('a00177.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a>  </div>
  <div class="headertitle">
<div class="title">Diversity Settings<div class="ingroups"><a class="el" href="a00176.html">storage: NVM Storage module</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>The application can adapt the storage module to better fit the different application scenarios through the use of diversity settings in the form of defines below. Sensible defaults are chosen. To override the default settings, place the defines with their desired values in the application app_sel.h header file. The compiler will pick up your defines before parsing this file.</p>
<p>Additional notes regarding some flags:</p><ul>
<li>By default, the assigned EEPROM region takes up 2KB and is located just below the read-only EEPROM rows. This storage space can be moved and resized by adapting <a class="el" href="a00177.html#ga89fe1736e393062639f3d7b64e76eeed">STORAGE_EEPROM_FIRST_ROW</a> and <a class="el" href="a00177.html#ga601793e23c7072b845356fc186966c19">STORAGE_EEPROM_LAST_ROW</a>.</li>
<li>By default, the remaining FLASH memory after programming is used for data storage: the available free FLASH space is automatically determined. It can also be manually assigned: move and resize the storage space in FLASH by adapting <a class="el" href="a00177.html#gadc56bda551d9bbea8ac33ac75c98ea6a">STORAGE_FLASH_FIRST_PAGE</a> and <a class="el" href="a00177.html#gaa9d5b61492e536833e7ae705d1888f07">STORAGE_FLASH_LAST_PAGE</a>.</li>
<li>Data is stored decompressed in EEPROM; a chance is given to the application to compress the data before it is moved to FLASH. For this, define both <a class="el" href="a00177.html#gad2c3a42a97cb31f6030cc561ca974eab">STORAGE_COMPRESS_CB</a> and <a class="el" href="a00177.html#ga4bbfc00976edf761a51223936e7360fb">STORAGE_DECOMPRESS_CB</a>.</li>
<li>Flash operations should be used sparingly. The amount of data transferred as one block from EEPROM to FLASH can be controlled using <a class="el" href="a00177.html#ga9023fc3872517d220a8f817eeef29957">STORAGE_BLOCK_SIZE_IN_SAMPLES</a>. Too little data puts unnecessary strain on the battery and reduces compression abilities; too much data risks a portion of the FLASH to remain not utilized when a compressed block of samples no longer fits.</li>
<li>The storage module requires the use of at least one general purpose register. This cannot be disabled.</li>
</ul>
<p>These flags may be overridden:</p><ul>
<li><a class="el" href="a00177.html#gaa0b4af28ee1307ce6c560e71d5a6c742">STORAGE_FIRST_ALON_REGISTER</a></li>
<li><a class="el" href="a00177.html#ga2d3c0407efae913c029d74b8621c16fe">STORAGE_SAMPLE_ALON_CACHE_COUNT</a></li>
<li><a class="el" href="a00177.html#ga89fe1736e393062639f3d7b64e76eeed">STORAGE_EEPROM_FIRST_ROW</a></li>
<li><a class="el" href="a00177.html#ga601793e23c7072b845356fc186966c19">STORAGE_EEPROM_LAST_ROW</a></li>
<li><a class="el" href="a00177.html#gadc56bda551d9bbea8ac33ac75c98ea6a">STORAGE_FLASH_FIRST_PAGE</a></li>
<li><a class="el" href="a00177.html#gaa9d5b61492e536833e7ae705d1888f07">STORAGE_FLASH_LAST_PAGE</a></li>
<li><a class="el" href="a00177.html#gacdcc483479cdfdecfdd8908db2ad80ba">STORAGE_TYPE</a></li>
<li><a class="el" href="a00177.html#gad01e6c1296544674eb74616a97afd3fc">STORAGE_BITSIZE</a></li>
<li><a class="el" href="a00177.html#ga910dbd1de1f6ef5fb34ebcda3478fd2c">STORAGE_SIGNED</a></li>
<li><a class="el" href="a00177.html#gade36aef439049262b4a755353542de43">STORAGE_WORKAREA</a></li>
<li><a class="el" href="a00177.html#ga6c078f740cf06f4b2fc346ea8cef148b">STORAGE_WRITE_RECOVERY_EVERY_X_SAMPLES</a></li>
<li><a class="el" href="a00177.html#ga9023fc3872517d220a8f817eeef29957">STORAGE_BLOCK_SIZE_IN_SAMPLES</a></li>
<li><a class="el" href="a00177.html#ga2bea6382040822311da235aa12667c1e">STORAGE_REDUCE_RECOVERY_WRITES</a></li>
<li><a class="el" href="a00177.html#gad2c3a42a97cb31f6030cc561ca974eab">STORAGE_COMPRESS_CB</a></li>
<li><a class="el" href="a00177.html#ga4bbfc00976edf761a51223936e7360fb">STORAGE_DECOMPRESS_CB</a></li>
</ul>
<p>These defines are fixed or derived from the above flags and may not be defined or redefined in an application:</p><ul>
<li><a class="el" href="a00177.html#ga8dbca404556373a074f6b1492c6fbf5a">STORAGE_EEPROM_ROW_COUNT</a></li>
<li><a class="el" href="a00177.html#gacbcae2947d337ca6553219fe984de8a3">STORAGE_EEPROM_SIZE</a></li>
<li><a class="el" href="a00177.html#gaa08eb53675eeb9d2a5003157ac31d526">STORAGE_MAX_SAMPLE_ALON_CACHE_COUNT</a></li>
<li><a class="el" href="a00177.html#ga15ac8af84ac4d577fa08da026d419534">STORAGE_WORKAREA_SELF_DEFINED</a></li>
<li><a class="el" href="a00177.html#ga4b69ffeada7d6e645ed70b84786850f9">STORAGE_WORKAREA_SIZE</a></li>
<li><a class="el" href="a00177.html#gade48b8c853f2bad6944cd429dac691c6">STORAGE_MAX_BLOCK_SIZE_IN_SAMPLES</a></li>
<li><a class="el" href="a00177.html#ga2cf237c4f6960deeb7e47e092b5094fc">STORAGE_BLOCK_HEADER_SIZE</a></li>
<li><a class="el" href="a00177.html#gad78aac86ab9e6dad0cbb2042d0e907b5">STORAGE_MAX_UNCOMPRESSED_BLOCK_SIZE_IN_BITS</a></li>
<li><a class="el" href="a00177.html#ga2acf9819ffb51fcca98d5d5151c3a1dd">STORAGE_MAX_LOSS_AFTER_CORRUPTION</a></li>
<li><a class="el" href="a00177.html#ga3528a0fe95f4434f065d3824c488debc">STORAGE_UNCOMPRESSED_BLOCK_SIZE_IN_BITS</a></li>
<li><p class="startli"><a class="el" href="a00177.html#ga03b6b7c38aff14a94b0d919538734255">STORAGE_UNCOMPRESSED_BLOCK_SIZE_IN_BYTES</a></p>
<dl class="section user"><dt>Choosing correct values</dt><dd>The storage module has many diversity settings, and can be tweaked a lot. Storing data reliably and as efficient as possible is a complex operation, and every use case will need to adjust a few settings, not relying on the default values.</dd></dl>
<p>To start, determine the correct sizes of the three memory regions the storage module has exclusive access of:</p><ul>
<li>General purpose registers: determined via <a class="el" href="a00177.html#gaa0b4af28ee1307ce6c560e71d5a6c742">STORAGE_FIRST_ALON_REGISTER</a> More general purpose registers means more data can be cached before writing to EEPROM. The more are assigned, the less EPROM flushes are performed, which prolongs life for batteries with a higher battery impedance (think printed batteries). But when things fail, all these samples will be lost.</li>
<li>EEPROM: <a class="el" href="a00177.html#ga89fe1736e393062639f3d7b64e76eeed">STORAGE_EEPROM_FIRST_ROW</a> and <a class="el" href="a00177.html#ga601793e23c7072b845356fc186966c19">STORAGE_EEPROM_LAST_ROW</a> By default, a conservative choice is made, leaving ~2 kB alone, for other uses of the application. The larger the assigned region, the more samples can be stored. This means less room left for the application to store its state, events and validation results.</li>
<li>FLASH: <a class="el" href="a00177.html#gadc56bda551d9bbea8ac33ac75c98ea6a">STORAGE_FLASH_FIRST_PAGE</a> and <a class="el" href="a00177.html#gaa9d5b61492e536833e7ae705d1888f07">STORAGE_FLASH_LAST_PAGE</a> By default, all space not used by the program itself, is used for data storage by the storage module. Unless your application requires to write to flash for other purposes, it is advised to stick with the default settings.</li>
</ul>
<p>Next, determine what will be stored. Each sample given to the storage module must have the same type. Both basic types and structures or unions are possible. Each sample will be placed back to back, without a single padding bit; if you know that a few MSBits are always 0, you can choose to store fewer bits, resulting in a larger storage capacity.</p><ul>
<li><a class="el" href="a00177.html#gacdcc483479cdfdecfdd8908db2ad80ba">STORAGE_TYPE</a></li>
<li><a class="el" href="a00177.html#gad01e6c1296544674eb74616a97afd3fc">STORAGE_BITSIZE</a></li>
<li><a class="el" href="a00177.html#ga910dbd1de1f6ef5fb34ebcda3478fd2c">STORAGE_SIGNED</a></li>
</ul>
<p>Compression greatly increases the number of samples that can be stored, at the cost of the size of the compression library itself. Normally, the compression ratio is greater when more samples are compressed at once. The storage module allows you to insert function calls to compress and decompress a large number of samples automatically. <br />
 Keep in mind that enlarging <a class="el" href="a00177.html#ga03b6b7c38aff14a94b0d919538734255">STORAGE_UNCOMPRESSED_BLOCK_SIZE_IN_BYTES</a> also enlarges <a class="el" href="a00177.html#ga4b69ffeada7d6e645ed70b84786850f9">STORAGE_WORKAREA_SIZE</a>, and the memory required for compressing and decompressing.</p><ul>
<li><a class="el" href="a00177.html#ga9023fc3872517d220a8f817eeef29957">STORAGE_BLOCK_SIZE_IN_SAMPLES</a></li>
<li><a class="el" href="a00177.html#gad2c3a42a97cb31f6030cc561ca974eab">STORAGE_COMPRESS_CB</a></li>
<li><a class="el" href="a00177.html#ga4bbfc00976edf761a51223936e7360fb">STORAGE_DECOMPRESS_CB</a></li>
</ul>
<p>If a compression is to be used which operates on a single sample at a time, the application can wrap the calls to the storage module and implement this outside the storage module. An example of this is a mapping operation which reduces the resolution in specific value ranges. Be sure to adapt the type and bitsize to match the encoded values.</p>
<p class="startli">Data recovery is paramount. Especially when at the end of the use case lifetime, when dealing with batteries which can't maintain a stable voltage any more, the risk of data corruption increases. The chance for data corruption to occur is highly dependent on your specific application, your choice of battery, and your environmental conditions. And apart from data corruption, the IC might also reset during flushing of EEPROM data, or during a FLASH program operation. When any of this happens, the storage module must be able to return as many samples as possible. <br />
 The storage module ensures only a few most recent samples may get lost.</p><ul>
<li>The samples stored in the general purposes registers were already mentioned. The number can be defined exactly using <a class="el" href="a00177.html#ga2d3c0407efae913c029d74b8621c16fe">STORAGE_SAMPLE_ALON_CACHE_COUNT</a></li>
<li>If data corruption occurs in EEPROM - or when data corruption in EEPROM is suspected - none of the data in the affected row can be used anymore. The storage module therefore stores a copy the last data row on a fixed location. Since the write endurance limit per EEPROM row is only 10.000, the storage module cannot copy this each time. Via the setting <a class="el" href="a00177.html#ga6c078f740cf06f4b2fc346ea8cef148b">STORAGE_WRITE_RECOVERY_EVERY_X_SAMPLES</a> the application can decide, taking into account the maximum number of samples that are to be stored. If in your use case less than 30.000 samples are stored over the full lifetime of the product, this value would then be set to 3.</li>
<li>If data corruption occurs in FLASH, the program will avoid all FLASH operations thereafter. No samples are lost, but the total storage capacity diminishes, as the FLASH page where the corruption occurred and all higher FLASH sectors will not be used for data storage any more.</li>
<li>Writing recovery information in itself can also have an averse impact on the battery. The application is therefore given an additional choice: the number of EEPROM flushes due to writing recovery data can be halved, at the expense of an additional 8 bytes of samples which may get lost when data corruption occurs. If <a class="el" href="a00177.html#ga2bea6382040822311da235aa12667c1e">STORAGE_REDUCE_RECOVERY_WRITES</a> is enabled, only one row is reserved for recovery information, and only 56 bytes are duplicated.</li>
</ul>
<p>The maximum amount of samples that may get lost due to an unexpected reset, a battery failure, or a data corruption, is captured in <a class="el" href="a00177.html#ga2acf9819ffb51fcca98d5d5151c3a1dd">STORAGE_MAX_LOSS_AFTER_CORRUPTION</a> To recover all samples safe for the very last, at the expense of (a lot) more EEPROM flush operations, use these settings: </p><div class="fragment"><div class="line"><span class="preprocessor">#define STORAGE_SAMPLE_ALON_CACHE_COUNT 0</span></div><div class="line"><span class="preprocessor">#define STORAGE_WRITE_RECOVERY_EVERY_X_SAMPLES 1</span></div><div class="line"><span class="preprocessor">#define STORAGE_REDUCE_RECOVERY_WRITES 0</span></div></div><!-- fragment --> </li>
</ul>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gad5156aa8d4f9dc31fcd5ff6efc9f5e42"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00177.html#gad5156aa8d4f9dc31fcd5ff6efc9f5e42">STORAGE_IDIVUP</a>(n,  d)&#160;&#160;&#160;(((n)+(d)-1)/(d))</td></tr>
<tr class="separator:gad5156aa8d4f9dc31fcd5ff6efc9f5e42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0b4af28ee1307ce6c560e71d5a6c742"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00177.html#gaa0b4af28ee1307ce6c560e71d5a6c742">STORAGE_FIRST_ALON_REGISTER</a>&#160;&#160;&#160;4</td></tr>
<tr class="separator:gaa0b4af28ee1307ce6c560e71d5a6c742"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89fe1736e393062639f3d7b64e76eeed"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00177.html#ga89fe1736e393062639f3d7b64e76eeed">STORAGE_EEPROM_FIRST_ROW</a>&#160;&#160;&#160;(EEPROM_NR_OF_RW_ROWS - (2048 / EEPROM_ROW_SIZE))</td></tr>
<tr class="separator:ga89fe1736e393062639f3d7b64e76eeed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga601793e23c7072b845356fc186966c19"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00177.html#ga601793e23c7072b845356fc186966c19">STORAGE_EEPROM_LAST_ROW</a>&#160;&#160;&#160;(EEPROM_NR_OF_RW_ROWS - 1)</td></tr>
<tr class="separator:ga601793e23c7072b845356fc186966c19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8dbca404556373a074f6b1492c6fbf5a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00177.html#ga8dbca404556373a074f6b1492c6fbf5a">STORAGE_EEPROM_ROW_COUNT</a>&#160;&#160;&#160;(<a class="el" href="a00177.html#ga601793e23c7072b845356fc186966c19">STORAGE_EEPROM_LAST_ROW</a> - <a class="el" href="a00177.html#ga89fe1736e393062639f3d7b64e76eeed">STORAGE_EEPROM_FIRST_ROW</a> + 1)</td></tr>
<tr class="separator:ga8dbca404556373a074f6b1492c6fbf5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacbcae2947d337ca6553219fe984de8a3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00177.html#gacbcae2947d337ca6553219fe984de8a3">STORAGE_EEPROM_SIZE</a>&#160;&#160;&#160;(<a class="el" href="a00177.html#ga8dbca404556373a074f6b1492c6fbf5a">STORAGE_EEPROM_ROW_COUNT</a> * EEPROM_ROW_SIZE)</td></tr>
<tr class="separator:gacbcae2947d337ca6553219fe984de8a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc56bda551d9bbea8ac33ac75c98ea6a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00177.html#gadc56bda551d9bbea8ac33ac75c98ea6a">STORAGE_FLASH_FIRST_PAGE</a>&#160;&#160;&#160;0</td></tr>
<tr class="separator:gadc56bda551d9bbea8ac33ac75c98ea6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa9d5b61492e536833e7ae705d1888f07"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00177.html#gaa9d5b61492e536833e7ae705d1888f07">STORAGE_FLASH_LAST_PAGE</a>&#160;&#160;&#160;(FLASH_NR_OF_RW_SECTORS * FLASH_PAGES_PER_SECTOR - 1)</td></tr>
<tr class="separator:gaa9d5b61492e536833e7ae705d1888f07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacdcc483479cdfdecfdd8908db2ad80ba"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00177.html#gacdcc483479cdfdecfdd8908db2ad80ba">STORAGE_TYPE</a>&#160;&#160;&#160;uint8_t</td></tr>
<tr class="separator:gacdcc483479cdfdecfdd8908db2ad80ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad01e6c1296544674eb74616a97afd3fc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00177.html#gad01e6c1296544674eb74616a97afd3fc">STORAGE_BITSIZE</a>&#160;&#160;&#160;8</td></tr>
<tr class="separator:gad01e6c1296544674eb74616a97afd3fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa08eb53675eeb9d2a5003157ac31d526"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00177.html#gaa08eb53675eeb9d2a5003157ac31d526">STORAGE_MAX_SAMPLE_ALON_CACHE_COUNT</a>&#160;&#160;&#160;((141 - <a class="el" href="a00177.html#gaa0b4af28ee1307ce6c560e71d5a6c742">STORAGE_FIRST_ALON_REGISTER</a> * 32) / <a class="el" href="a00177.html#gad01e6c1296544674eb74616a97afd3fc">STORAGE_BITSIZE</a>)</td></tr>
<tr class="separator:gaa08eb53675eeb9d2a5003157ac31d526"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d3c0407efae913c029d74b8621c16fe"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00177.html#ga2d3c0407efae913c029d74b8621c16fe">STORAGE_SAMPLE_ALON_CACHE_COUNT</a>&#160;&#160;&#160;<a class="el" href="a00177.html#gaa08eb53675eeb9d2a5003157ac31d526">STORAGE_MAX_SAMPLE_ALON_CACHE_COUNT</a></td></tr>
<tr class="separator:ga2d3c0407efae913c029d74b8621c16fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga910dbd1de1f6ef5fb34ebcda3478fd2c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00177.html#ga910dbd1de1f6ef5fb34ebcda3478fd2c">STORAGE_SIGNED</a>&#160;&#160;&#160;0</td></tr>
<tr class="separator:ga910dbd1de1f6ef5fb34ebcda3478fd2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c078f740cf06f4b2fc346ea8cef148b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00177.html#ga6c078f740cf06f4b2fc346ea8cef148b">STORAGE_WRITE_RECOVERY_EVERY_X_SAMPLES</a>&#160;&#160;&#160;(1 + <a class="el" href="a00177.html#ga2d3c0407efae913c029d74b8621c16fe">STORAGE_SAMPLE_ALON_CACHE_COUNT</a>)</td></tr>
<tr class="separator:ga6c078f740cf06f4b2fc346ea8cef148b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2bea6382040822311da235aa12667c1e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00177.html#ga2bea6382040822311da235aa12667c1e">STORAGE_REDUCE_RECOVERY_WRITES</a>&#160;&#160;&#160;0</td></tr>
<tr class="separator:ga2bea6382040822311da235aa12667c1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2acf9819ffb51fcca98d5d5151c3a1dd"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00177.html#ga2acf9819ffb51fcca98d5d5151c3a1dd">STORAGE_MAX_LOSS_AFTER_CORRUPTION</a></td></tr>
<tr class="separator:ga2acf9819ffb51fcca98d5d5151c3a1dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade48b8c853f2bad6944cd429dac691c6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00177.html#gade48b8c853f2bad6944cd429dac691c6">STORAGE_MAX_BLOCK_SIZE_IN_SAMPLES</a></td></tr>
<tr class="separator:gade48b8c853f2bad6944cd429dac691c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad78aac86ab9e6dad0cbb2042d0e907b5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00177.html#gad78aac86ab9e6dad0cbb2042d0e907b5">STORAGE_MAX_UNCOMPRESSED_BLOCK_SIZE_IN_BITS</a>&#160;&#160;&#160;(<a class="el" href="a00177.html#gade48b8c853f2bad6944cd429dac691c6">STORAGE_MAX_BLOCK_SIZE_IN_SAMPLES</a> * <a class="el" href="a00177.html#gad01e6c1296544674eb74616a97afd3fc">STORAGE_BITSIZE</a>)</td></tr>
<tr class="separator:gad78aac86ab9e6dad0cbb2042d0e907b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2cf237c4f6960deeb7e47e092b5094fc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00177.html#ga2cf237c4f6960deeb7e47e092b5094fc">STORAGE_BLOCK_HEADER_SIZE</a>&#160;&#160;&#160;2</td></tr>
<tr class="separator:ga2cf237c4f6960deeb7e47e092b5094fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9023fc3872517d220a8f817eeef29957"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00177.html#ga9023fc3872517d220a8f817eeef29957">STORAGE_BLOCK_SIZE_IN_SAMPLES</a>&#160;&#160;&#160;(((1024 - <a class="el" href="a00177.html#ga2cf237c4f6960deeb7e47e092b5094fc">STORAGE_BLOCK_HEADER_SIZE</a>) * 8) / <a class="el" href="a00177.html#gad01e6c1296544674eb74616a97afd3fc">STORAGE_BITSIZE</a>)</td></tr>
<tr class="separator:ga9023fc3872517d220a8f817eeef29957"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9023fc3872517d220a8f817eeef29957"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00177.html#ga9023fc3872517d220a8f817eeef29957">STORAGE_BLOCK_SIZE_IN_SAMPLES</a>&#160;&#160;&#160;<a class="el" href="a00177.html#gade48b8c853f2bad6944cd429dac691c6">STORAGE_MAX_BLOCK_SIZE_IN_SAMPLES</a></td></tr>
<tr class="separator:ga9023fc3872517d220a8f817eeef29957"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3528a0fe95f4434f065d3824c488debc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00177.html#ga3528a0fe95f4434f065d3824c488debc">STORAGE_UNCOMPRESSED_BLOCK_SIZE_IN_BITS</a>&#160;&#160;&#160;(<a class="el" href="a00177.html#ga9023fc3872517d220a8f817eeef29957">STORAGE_BLOCK_SIZE_IN_SAMPLES</a> * <a class="el" href="a00177.html#gad01e6c1296544674eb74616a97afd3fc">STORAGE_BITSIZE</a>)</td></tr>
<tr class="separator:ga3528a0fe95f4434f065d3824c488debc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga03b6b7c38aff14a94b0d919538734255"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00177.html#ga03b6b7c38aff14a94b0d919538734255">STORAGE_UNCOMPRESSED_BLOCK_SIZE_IN_BYTES</a>&#160;&#160;&#160;<a class="el" href="a00177.html#gad5156aa8d4f9dc31fcd5ff6efc9f5e42">STORAGE_IDIVUP</a>(<a class="el" href="a00177.html#ga3528a0fe95f4434f065d3824c488debc">STORAGE_UNCOMPRESSED_BLOCK_SIZE_IN_BITS</a>, 8)</td></tr>
<tr class="separator:ga03b6b7c38aff14a94b0d919538734255"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b69ffeada7d6e645ed70b84786850f9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00177.html#ga4b69ffeada7d6e645ed70b84786850f9">STORAGE_WORKAREA_SIZE</a>&#160;&#160;&#160;((FLASH_PAGE_SIZE * 2) + <a class="el" href="a00177.html#ga03b6b7c38aff14a94b0d919538734255">STORAGE_UNCOMPRESSED_BLOCK_SIZE_IN_BYTES</a>)</td></tr>
<tr class="separator:ga4b69ffeada7d6e645ed70b84786850f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga15ac8af84ac4d577fa08da026d419534"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00177.html#ga15ac8af84ac4d577fa08da026d419534">STORAGE_WORKAREA_SELF_DEFINED</a>&#160;&#160;&#160;1</td></tr>
<tr class="separator:ga15ac8af84ac4d577fa08da026d419534"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade36aef439049262b4a755353542de43"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00177.html#gade36aef439049262b4a755353542de43">STORAGE_WORKAREA</a>&#160;&#160;&#160;<a class="el" href="a00002.html#a2d5937977dab1cbd29de86cc5e11762d">sStorage_Workarea</a></td></tr>
<tr class="separator:gade36aef439049262b4a755353542de43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2c3a42a97cb31f6030cc561ca974eab"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00177.html#gad2c3a42a97cb31f6030cc561ca974eab">STORAGE_COMPRESS_CB</a></td></tr>
<tr class="separator:gad2c3a42a97cb31f6030cc561ca974eab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4bbfc00976edf761a51223936e7360fb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00177.html#ga4bbfc00976edf761a51223936e7360fb">STORAGE_DECOMPRESS_CB</a></td></tr>
<tr class="separator:ga4bbfc00976edf761a51223936e7360fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="gad5156aa8d4f9dc31fcd5ff6efc9f5e42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad5156aa8d4f9dc31fcd5ff6efc9f5e42">&#9670;&nbsp;</a></span>STORAGE_IDIVUP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define STORAGE_IDIVUP</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">n, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">d&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;(((n)+(d)-1)/(d))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Helper. Performs integer division, rounding up. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Must be a positive number. </td></tr>
    <tr><td class="paramname">d</td><td>Must be a strict positive number </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="a00008_source.html#l00158">158</a> of file <a class="el" href="a00008_source.html">storage_dft.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="a00002_source.html#l01160">MoveSamplesFromEepromToFlash()</a>, <a class="el" href="a00002_source.html#l00942">ReadFromEeprom()</a>, and <a class="el" href="a00002_source.html#l00912">WriteToEeprom()</a>.</p>

</div>
</div>
<a id="gaa0b4af28ee1307ce6c560e71d5a6c742"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa0b4af28ee1307ce6c560e71d5a6c742">&#9670;&nbsp;</a></span>STORAGE_FIRST_ALON_REGISTER</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define STORAGE_FIRST_ALON_REGISTER&#160;&#160;&#160;4</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The storage module requires the use of at least one general purpose register. This is used for its own housekeeping and allows it to finish initialization (<a class="el" href="a00176.html#gad04fe4fa8e78ef5572e4a39dec188c31">Storage_Init</a>) fast. In addition, <b>all</b> other general purposes registers with an index <b>higher</b> <b>than</b> given are also reserved for the storage module. These will be used to minimize EEPROM flush operations by caching as many samples as possible before committing them to EEPROM. </p><dl class="section pre"><dt>Precondition</dt><dd>These registers must be guaranteed not to be touched outside the storage module. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>More information about the ALON registers can be found in the Power Management Unit driver. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00177.html#ga2d3c0407efae913c029d74b8621c16fe">STORAGE_SAMPLE_ALON_CACHE_COUNT</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00008_source.html#l00176">176</a> of file <a class="el" href="a00008_source.html">storage_dft.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="a00002_source.html#l01505">Storage_DeInit()</a>, and <a class="el" href="a00002_source.html#l01425">Storage_Init()</a>.</p>

</div>
</div>
<a id="ga89fe1736e393062639f3d7b64e76eeed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga89fe1736e393062639f3d7b64e76eeed">&#9670;&nbsp;</a></span>STORAGE_EEPROM_FIRST_ROW</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define STORAGE_EEPROM_FIRST_ROW&#160;&#160;&#160;(EEPROM_NR_OF_RW_ROWS - (2048 / EEPROM_ROW_SIZE))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The first EEPROM row assigned for sample storage. Starting from the first byte in this row, until the last byte in <a class="el" href="a00177.html#ga601793e23c7072b845356fc186966c19">STORAGE_EEPROM_LAST_ROW</a>, the storage module has full control: no other code may touch this EEPROM region. </p><dl class="section note"><dt>Note</dt><dd>By default, the EEPROM row 2 kB below the locked EEPROM rows will be chosen. </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00008_source.html#l00190">190</a> of file <a class="el" href="a00008_source.html">storage_dft.h</a>.</p>

</div>
</div>
<a id="ga601793e23c7072b845356fc186966c19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga601793e23c7072b845356fc186966c19">&#9670;&nbsp;</a></span>STORAGE_EEPROM_LAST_ROW</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define STORAGE_EEPROM_LAST_ROW&#160;&#160;&#160;(EEPROM_NR_OF_RW_ROWS - 1)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The last EEPROM row assigned for sample storage. Starting from the first byte in <a class="el" href="a00177.html#ga89fe1736e393062639f3d7b64e76eeed">STORAGE_EEPROM_FIRST_ROW</a>, until the last byte in this row, the storage module has full control: no other code may touch this EEPROM region. </p><dl class="section note"><dt>Note</dt><dd>the size of the EEPROM region is not required to be a multiple of the FLASH sector size. </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00008_source.html#l00202">202</a> of file <a class="el" href="a00008_source.html">storage_dft.h</a>.</p>

</div>
</div>
<a id="ga8dbca404556373a074f6b1492c6fbf5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8dbca404556373a074f6b1492c6fbf5a">&#9670;&nbsp;</a></span>STORAGE_EEPROM_ROW_COUNT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define STORAGE_EEPROM_ROW_COUNT&#160;&#160;&#160;(<a class="el" href="a00177.html#ga601793e23c7072b845356fc186966c19">STORAGE_EEPROM_LAST_ROW</a> - <a class="el" href="a00177.html#ga89fe1736e393062639f3d7b64e76eeed">STORAGE_EEPROM_FIRST_ROW</a> + 1)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The number of EEPROM rows assigned for sample storage. </p>

<p class="definition">Definition at line <a class="el" href="a00008_source.html#l00209">209</a> of file <a class="el" href="a00008_source.html">storage_dft.h</a>.</p>

</div>
</div>
<a id="gacbcae2947d337ca6553219fe984de8a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacbcae2947d337ca6553219fe984de8a3">&#9670;&nbsp;</a></span>STORAGE_EEPROM_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define STORAGE_EEPROM_SIZE&#160;&#160;&#160;(<a class="el" href="a00177.html#ga8dbca404556373a074f6b1492c6fbf5a">STORAGE_EEPROM_ROW_COUNT</a> * EEPROM_ROW_SIZE)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The size of the assigned EEPROM storage in bytes </p>

<p class="definition">Definition at line <a class="el" href="a00008_source.html#l00215">215</a> of file <a class="el" href="a00008_source.html">storage_dft.h</a>.</p>

</div>
</div>
<a id="gadc56bda551d9bbea8ac33ac75c98ea6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadc56bda551d9bbea8ac33ac75c98ea6a">&#9670;&nbsp;</a></span>STORAGE_FLASH_FIRST_PAGE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define STORAGE_FLASH_FIRST_PAGE&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The first FLASH page assigned for storage. Starting from the first byte in this page, until the last byte in <a class="el" href="a00177.html#gaa9d5b61492e536833e7ae705d1888f07">STORAGE_FLASH_LAST_PAGE</a>, the Storage module has full control: no other code will touch this FLASH region. </p><dl class="section note"><dt>Note</dt><dd>Two special values exist:<ul>
<li>When equal to <code>0</code>, the first empty FLASH page <b>after</b> the <code></code>.text and <code></code>.data sections will be used. This page is automatically determined during link time by the Storage module's code.</li>
<li>When equal to <a class="el" href="a00177.html#gaa9d5b61492e536833e7ae705d1888f07">STORAGE_FLASH_LAST_PAGE</a>, storage to FLASH is disabled. Only the EEPROM will be used to store the data.</li>
</ul>
</dd>
<dd>
The page is not required to be sector aligned. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>If a non-zero value is specified, it is the responsibility of the application programmer to ensure the FLASH location points to outside the <code></code>.text and <code></code>.data sections. </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00008_source.html#l00233">233</a> of file <a class="el" href="a00008_source.html">storage_dft.h</a>.</p>

</div>
</div>
<a id="gaa9d5b61492e536833e7ae705d1888f07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa9d5b61492e536833e7ae705d1888f07">&#9670;&nbsp;</a></span>STORAGE_FLASH_LAST_PAGE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define STORAGE_FLASH_LAST_PAGE&#160;&#160;&#160;(FLASH_NR_OF_RW_SECTORS * FLASH_PAGES_PER_SECTOR - 1)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The last FLASH page assigned for storage. Starting from the first byte in <a class="el" href="a00177.html#gadc56bda551d9bbea8ac33ac75c98ea6a">STORAGE_FLASH_FIRST_PAGE</a>, until the last byte in this page, the Storage module has full control: no other code will touch this FLASH region. </p><dl class="section note"><dt>Note</dt><dd>the size of the region is not required to be a multiple of the FLASH sector size. </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00008_source.html#l00246">246</a> of file <a class="el" href="a00008_source.html">storage_dft.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="a00002_source.html#l01160">MoveSamplesFromEepromToFlash()</a>, and <a class="el" href="a00002_source.html#l01535">Storage_Reset()</a>.</p>

</div>
</div>
<a id="gacdcc483479cdfdecfdd8908db2ad80ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacdcc483479cdfdecfdd8908db2ad80ba">&#9670;&nbsp;</a></span>STORAGE_TYPE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define STORAGE_TYPE&#160;&#160;&#160;uint8_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The type that is used to store one decompressed sample. When writing, samples are to be delivered using this type - see <a class="el" href="a00176.html#ga820a105a6412fe21e8598f2c682664af">Storage_Write</a>; when reading, samples are returned again using this type - see <a class="el" href="a00176.html#gad82b015bb0ed48f90d9782a4b29f52ff">Storage_Read</a>. </p>

<p class="definition">Definition at line <a class="el" href="a00008_source.html#l00264">264</a> of file <a class="el" href="a00008_source.html">storage_dft.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="a00002_source.html#l01750">Storage_Read()</a>, and <a class="el" href="a00002_source.html#l01619">Storage_Write()</a>.</p>

</div>
</div>
<a id="gad01e6c1296544674eb74616a97afd3fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad01e6c1296544674eb74616a97afd3fc">&#9670;&nbsp;</a></span>STORAGE_BITSIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define STORAGE_BITSIZE&#160;&#160;&#160;8</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The number of bits that are to be stored for each sample. For each sample given using <a class="el" href="a00176.html#ga820a105a6412fe21e8598f2c682664af">Storage_Write</a> this number of LSBits are written; </p>

<p class="definition">Definition at line <a class="el" href="a00008_source.html#l00272">272</a> of file <a class="el" href="a00008_source.html">storage_dft.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="a00002_source.html#l00868">CacheSample()</a>, <a class="el" href="a00002_source.html#l00966">FindMarker()</a>, <a class="el" href="a00002_source.html#l00890">GetCachedSample()</a>, <a class="el" href="a00002_source.html#l01027">GetEepromCount()</a>, <a class="el" href="a00002_source.html#l01505">Storage_DeInit()</a>, <a class="el" href="a00002_source.html#l01425">Storage_Init()</a>, <a class="el" href="a00002_source.html#l01750">Storage_Read()</a>, <a class="el" href="a00002_source.html#l01681">Storage_Seek()</a>, <a class="el" href="a00002_source.html#l01619">Storage_Write()</a>, <a class="el" href="a00002_source.html#l01110">StoreSamplesInEeprom()</a>, <a class="el" href="a00002_source.html#l01369">ValidateHint()</a>, and <a class="el" href="a00002_source.html#l01336">ValidateRecoverInfo()</a>.</p>

</div>
</div>
<a id="gaa08eb53675eeb9d2a5003157ac31d526"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa08eb53675eeb9d2a5003157ac31d526">&#9670;&nbsp;</a></span>STORAGE_MAX_SAMPLE_ALON_CACHE_COUNT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define STORAGE_MAX_SAMPLE_ALON_CACHE_COUNT&#160;&#160;&#160;((141 - <a class="el" href="a00177.html#gaa0b4af28ee1307ce6c560e71d5a6c742">STORAGE_FIRST_ALON_REGISTER</a> * 32) / <a class="el" href="a00177.html#gad01e6c1296544674eb74616a97afd3fc">STORAGE_BITSIZE</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The maximum number of samples that can be cached in the ALON general purposes registers before they are committed to EEPROM. </p>

<p class="definition">Definition at line <a class="el" href="a00008_source.html#l00281">281</a> of file <a class="el" href="a00008_source.html">storage_dft.h</a>.</p>

</div>
</div>
<a id="ga2d3c0407efae913c029d74b8621c16fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2d3c0407efae913c029d74b8621c16fe">&#9670;&nbsp;</a></span>STORAGE_SAMPLE_ALON_CACHE_COUNT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define STORAGE_SAMPLE_ALON_CACHE_COUNT&#160;&#160;&#160;<a class="el" href="a00177.html#gaa08eb53675eeb9d2a5003157ac31d526">STORAGE_MAX_SAMPLE_ALON_CACHE_COUNT</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The number of samples that are cached in the ALON general purposes registers before they are committed to EEPROM. </p>

<p class="definition">Definition at line <a class="el" href="a00008_source.html#l00288">288</a> of file <a class="el" href="a00008_source.html">storage_dft.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="a00002_source.html#l00868">CacheSample()</a>, <a class="el" href="a00002_source.html#l01619">Storage_Write()</a>, and <a class="el" href="a00002_source.html#l01336">ValidateRecoverInfo()</a>.</p>

</div>
</div>
<a id="ga910dbd1de1f6ef5fb34ebcda3478fd2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga910dbd1de1f6ef5fb34ebcda3478fd2c">&#9670;&nbsp;</a></span>STORAGE_SIGNED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define STORAGE_SIGNED&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Define or set to a non-zero value (e.g. <code>1</code>) to indicate that <a class="el" href="a00177.html#gacdcc483479cdfdecfdd8908db2ad80ba">STORAGE_TYPE</a> is a signed type.</p><ul>
<li>If defined, the bit at position<div class="fragment"><div class="line">(#<a class="code" href="a00177.html#gad01e6c1296544674eb74616a97afd3fc">STORAGE_BITSIZE</a> - 1) </div></div><!-- fragment --> will be treated as the sign bit: when reading out samples from EEPROM or FLASH, this bit will be propagated left up to the MSBit of <a class="el" href="a00177.html#gacdcc483479cdfdecfdd8908db2ad80ba">STORAGE_TYPE</a>.</li>
<li>If not defined, the MSBits at positions <a class="el" href="a00177.html#gad01e6c1296544674eb74616a97afd3fc">STORAGE_BITSIZE</a> and up will be set to <code>0</code>.</li>
</ul>
<dl class="section warning"><dt>Warning</dt><dd>Setting this diversity flag to 1 while <a class="el" href="a00177.html#gacdcc483479cdfdecfdd8908db2ad80ba">STORAGE_TYPE</a> is a structure, while raise compiler errors. see <a class="el" href="a00176.html#gad82b015bb0ed48f90d9782a4b29f52ff">Storage_Read</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00008_source.html#l00309">309</a> of file <a class="el" href="a00008_source.html">storage_dft.h</a>.</p>

</div>
</div>
<a id="ga6c078f740cf06f4b2fc346ea8cef148b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6c078f740cf06f4b2fc346ea8cef148b">&#9670;&nbsp;</a></span>STORAGE_WRITE_RECOVERY_EVERY_X_SAMPLES</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define STORAGE_WRITE_RECOVERY_EVERY_X_SAMPLES&#160;&#160;&#160;(1 + <a class="el" href="a00177.html#ga2d3c0407efae913c029d74b8621c16fe">STORAGE_SAMPLE_ALON_CACHE_COUNT</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Update the recovery information after adding <code>X</code> samples to <b>non-volatile</b> memory. This recovery information is written on a fixed location. When an unexpected reset occurs or a corruption of the data while writing new content, the recovery information is used to recover as much data as possible. </p><dl class="section note"><dt>Note</dt><dd>The recovery information is only written in the call to <a class="el" href="a00176.html#ga75abea0be7fefec6285224dc0f82f5ac">Storage_DeInit</a>. Depending on the number of calls to <a class="el" href="a00176.html#ga820a105a6412fe21e8598f2c682664af">Storage_Write</a> and its arguments, it is possible more samples have been written than this number. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>maximum number of expected data samples / <code>STORAGE_WRITE_RECOVERY_EVERY_X_SAMPLES</code> &lt; 10.000 </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00008_source.html#l00323">323</a> of file <a class="el" href="a00008_source.html">storage_dft.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="a00002_source.html#l01505">Storage_DeInit()</a>.</p>

</div>
</div>
<a id="ga2bea6382040822311da235aa12667c1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2bea6382040822311da235aa12667c1e">&#9670;&nbsp;</a></span>STORAGE_REDUCE_RECOVERY_WRITES</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define STORAGE_REDUCE_RECOVERY_WRITES&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">
<ul>
<li>If not defined, or defined to zero, two rows of the assigned EEPROM region for data storage are used for data recovery. When data corruption occurs, no extra loss of bytes will occur, only <a class="el" href="a00177.html#ga2d3c0407efae913c029d74b8621c16fe">STORAGE_SAMPLE_ALON_CACHE_COUNT</a> and <a class="el" href="a00177.html#ga6c078f740cf06f4b2fc346ea8cef148b">STORAGE_WRITE_RECOVERY_EVERY_X_SAMPLES</a> contribute to this.</li>
<li>If defined to a non-zero value: the space used for recovery - where the duplicate data of the last row and the hint information is stored - is reduced to just one row. When data corruption occurs, an additional loss of up to 8 bytes can occur.</li>
</ul>

<p class="definition">Definition at line <a class="el" href="a00008_source.html#l00343">343</a> of file <a class="el" href="a00008_source.html">storage_dft.h</a>.</p>

</div>
</div>
<a id="ga2acf9819ffb51fcca98d5d5151c3a1dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2acf9819ffb51fcca98d5d5151c3a1dd">&#9670;&nbsp;</a></span>STORAGE_MAX_LOSS_AFTER_CORRUPTION</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define STORAGE_MAX_LOSS_AFTER_CORRUPTION</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">1 \</div><div class="line">        + <a class="code" href="a00177.html#ga2d3c0407efae913c029d74b8621c16fe">STORAGE_SAMPLE_ALON_CACHE_COUNT</a> \</div><div class="line">        + <a class="code" href="a00177.html#ga6c078f740cf06f4b2fc346ea8cef148b">STORAGE_WRITE_RECOVERY_EVERY_X_SAMPLES</a> \</div><div class="line">        + <a class="code" href="a00177.html#ga2bea6382040822311da235aa12667c1e">STORAGE_REDUCE_RECOVERY_WRITES</a> * <a class="code" href="a00177.html#gad5156aa8d4f9dc31fcd5ff6efc9f5e42">STORAGE_IDIVUP</a>(8 * 8, <a class="code" href="a00177.html#gad01e6c1296544674eb74616a97afd3fc">STORAGE_BITSIZE</a>)</div><div class="ttc" id="a00177_html_ga2bea6382040822311da235aa12667c1e"><div class="ttname"><a href="a00177.html#ga2bea6382040822311da235aa12667c1e">STORAGE_REDUCE_RECOVERY_WRITES</a></div><div class="ttdeci">#define STORAGE_REDUCE_RECOVERY_WRITES</div><div class="ttdef"><b>Definition:</b> <a href="a00008_source.html#l00343">storage_dft.h:343</a></div></div>
<div class="ttc" id="a00177_html_ga6c078f740cf06f4b2fc346ea8cef148b"><div class="ttname"><a href="a00177.html#ga6c078f740cf06f4b2fc346ea8cef148b">STORAGE_WRITE_RECOVERY_EVERY_X_SAMPLES</a></div><div class="ttdeci">#define STORAGE_WRITE_RECOVERY_EVERY_X_SAMPLES</div><div class="ttdef"><b>Definition:</b> <a href="a00008_source.html#l00323">storage_dft.h:323</a></div></div>
<div class="ttc" id="a00177_html_gad5156aa8d4f9dc31fcd5ff6efc9f5e42"><div class="ttname"><a href="a00177.html#gad5156aa8d4f9dc31fcd5ff6efc9f5e42">STORAGE_IDIVUP</a></div><div class="ttdeci">#define STORAGE_IDIVUP(n, d)</div><div class="ttdef"><b>Definition:</b> <a href="a00008_source.html#l00158">storage_dft.h:158</a></div></div>
<div class="ttc" id="a00177_html_gad01e6c1296544674eb74616a97afd3fc"><div class="ttname"><a href="a00177.html#gad01e6c1296544674eb74616a97afd3fc">STORAGE_BITSIZE</a></div><div class="ttdeci">#define STORAGE_BITSIZE</div><div class="ttdef"><b>Definition:</b> <a href="a00008_source.html#l00272">storage_dft.h:272</a></div></div>
<div class="ttc" id="a00177_html_ga2d3c0407efae913c029d74b8621c16fe"><div class="ttname"><a href="a00177.html#ga2d3c0407efae913c029d74b8621c16fe">STORAGE_SAMPLE_ALON_CACHE_COUNT</a></div><div class="ttdeci">#define STORAGE_SAMPLE_ALON_CACHE_COUNT</div><div class="ttdef"><b>Definition:</b> <a href="a00008_source.html#l00288">storage_dft.h:288</a></div></div>
</div><!-- fragment --><p>The maximum loss of samples that can occur. The storage module may not be able to return the most recently stored samples after an EEPROM corruption occurs. A scenario where this can happen is when printed batteries are used, and the battery has an internal impedance of 2 kOhm or higher, resulting in a barely sufficient voltage when operating normally, and a below-spec voltage when extra load is generated due to an EEPROM flush operation. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="a00177.html#ga2d3c0407efae913c029d74b8621c16fe">STORAGE_SAMPLE_ALON_CACHE_COUNT</a> </dd>
<dd>
<a class="el" href="a00177.html#ga6c078f740cf06f4b2fc346ea8cef148b">STORAGE_WRITE_RECOVERY_EVERY_X_SAMPLES</a> </dd>
<dd>
<a class="el" href="a00177.html#ga2bea6382040822311da235aa12667c1e">STORAGE_REDUCE_RECOVERY_WRITES</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00008_source.html#l00358">358</a> of file <a class="el" href="a00008_source.html">storage_dft.h</a>.</p>

</div>
</div>
<a id="gade48b8c853f2bad6944cd429dac691c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gade48b8c853f2bad6944cd429dac691c6">&#9670;&nbsp;</a></span>STORAGE_MAX_BLOCK_SIZE_IN_SAMPLES</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define STORAGE_MAX_BLOCK_SIZE_IN_SAMPLES</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The maximum allowed value for <a class="el" href="a00177.html#ga9023fc3872517d220a8f817eeef29957">STORAGE_BLOCK_SIZE_IN_SAMPLES</a>. After this many samples, the assigned EEPROM region is completely filled and no new sample can be written to EEPROM before its contents are moved to FLASH first. </p>

<p class="definition">Definition at line <a class="el" href="a00008_source.html#l00372">372</a> of file <a class="el" href="a00008_source.html">storage_dft.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="a00002_source.html#l01110">StoreSamplesInEeprom()</a>.</p>

</div>
</div>
<a id="gad78aac86ab9e6dad0cbb2042d0e907b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad78aac86ab9e6dad0cbb2042d0e907b5">&#9670;&nbsp;</a></span>STORAGE_MAX_UNCOMPRESSED_BLOCK_SIZE_IN_BITS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define STORAGE_MAX_UNCOMPRESSED_BLOCK_SIZE_IN_BITS&#160;&#160;&#160;(<a class="el" href="a00177.html#gade48b8c853f2bad6944cd429dac691c6">STORAGE_MAX_BLOCK_SIZE_IN_SAMPLES</a> * <a class="el" href="a00177.html#gad01e6c1296544674eb74616a97afd3fc">STORAGE_BITSIZE</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Defines the number of bits required to store one block of samples. </p>

<p class="definition">Definition at line <a class="el" href="a00008_source.html#l00377">377</a> of file <a class="el" href="a00008_source.html">storage_dft.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="a00002_source.html#l01369">ValidateHint()</a>, and <a class="el" href="a00002_source.html#l01336">ValidateRecoverInfo()</a>.</p>

</div>
</div>
<a id="ga2cf237c4f6960deeb7e47e092b5094fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2cf237c4f6960deeb7e47e092b5094fc">&#9670;&nbsp;</a></span>STORAGE_BLOCK_HEADER_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define STORAGE_BLOCK_HEADER_SIZE&#160;&#160;&#160;2</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The size in bytes of the meta data stored just in front of the (compressed) data block in FLASH. </p>

<p class="definition">Definition at line <a class="el" href="a00008_source.html#l00382">382</a> of file <a class="el" href="a00008_source.html">storage_dft.h</a>.</p>

</div>
</div>
<a id="ga9023fc3872517d220a8f817eeef29957"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9023fc3872517d220a8f817eeef29957">&#9670;&nbsp;</a></span>STORAGE_BLOCK_SIZE_IN_SAMPLES <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define STORAGE_BLOCK_SIZE_IN_SAMPLES&#160;&#160;&#160;(((1024 - <a class="el" href="a00177.html#ga2cf237c4f6960deeb7e47e092b5094fc">STORAGE_BLOCK_HEADER_SIZE</a>) * 8) / <a class="el" href="a00177.html#gad01e6c1296544674eb74616a97afd3fc">STORAGE_BITSIZE</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>After writing this number of samples to EEPROM, the module will try to compress them all at once - see <a class="el" href="a00177.html#gad2c3a42a97cb31f6030cc561ca974eab">STORAGE_COMPRESS_CB</a> - and move them to FLASH - defined by <a class="el" href="a00177.html#gadc56bda551d9bbea8ac33ac75c98ea6a">STORAGE_FLASH_FIRST_PAGE</a> and <a class="el" href="a00177.html#gaa9d5b61492e536833e7ae705d1888f07">STORAGE_FLASH_LAST_PAGE</a>. </p><dl class="section note"><dt>Note</dt><dd>This size determines the value of <a class="el" href="a00177.html#ga4b69ffeada7d6e645ed70b84786850f9">STORAGE_WORKAREA_SIZE</a> - the larger this number, the more SRAM is required, and the larger chunks the compression and decompression algorithms have to work with. </dd>
<dd>
By default, the block size will be chosen such that an uncompressed block can fit in one FLASH sector, including the accompanying meta data. </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00008_source.html#l00396">396</a> of file <a class="el" href="a00008_source.html">storage_dft.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="a00002_source.html#l01034">GetFlashCount()</a>, <a class="el" href="a00002_source.html#l01160">MoveSamplesFromEepromToFlash()</a>, <a class="el" href="a00002_source.html#l01750">Storage_Read()</a>, <a class="el" href="a00002_source.html#l01681">Storage_Seek()</a>, and <a class="el" href="a00002_source.html#l01110">StoreSamplesInEeprom()</a>.</p>

</div>
</div>
<a id="ga9023fc3872517d220a8f817eeef29957"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9023fc3872517d220a8f817eeef29957">&#9670;&nbsp;</a></span>STORAGE_BLOCK_SIZE_IN_SAMPLES <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define STORAGE_BLOCK_SIZE_IN_SAMPLES&#160;&#160;&#160;<a class="el" href="a00177.html#gade48b8c853f2bad6944cd429dac691c6">STORAGE_MAX_BLOCK_SIZE_IN_SAMPLES</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>After writing this number of samples to EEPROM, the module will try to compress them all at once - see <a class="el" href="a00177.html#gad2c3a42a97cb31f6030cc561ca974eab">STORAGE_COMPRESS_CB</a> - and move them to FLASH - defined by <a class="el" href="a00177.html#gadc56bda551d9bbea8ac33ac75c98ea6a">STORAGE_FLASH_FIRST_PAGE</a> and <a class="el" href="a00177.html#gaa9d5b61492e536833e7ae705d1888f07">STORAGE_FLASH_LAST_PAGE</a>. </p><dl class="section note"><dt>Note</dt><dd>This size determines the value of <a class="el" href="a00177.html#ga4b69ffeada7d6e645ed70b84786850f9">STORAGE_WORKAREA_SIZE</a> - the larger this number, the more SRAM is required, and the larger chunks the compression and decompression algorithms have to work with. </dd>
<dd>
By default, the block size will be chosen such that an uncompressed block can fit in one FLASH sector, including the accompanying meta data. </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00008_source.html#l00396">396</a> of file <a class="el" href="a00008_source.html">storage_dft.h</a>.</p>

</div>
</div>
<a id="ga3528a0fe95f4434f065d3824c488debc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3528a0fe95f4434f065d3824c488debc">&#9670;&nbsp;</a></span>STORAGE_UNCOMPRESSED_BLOCK_SIZE_IN_BITS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define STORAGE_UNCOMPRESSED_BLOCK_SIZE_IN_BITS&#160;&#160;&#160;(<a class="el" href="a00177.html#ga9023fc3872517d220a8f817eeef29957">STORAGE_BLOCK_SIZE_IN_SAMPLES</a> * <a class="el" href="a00177.html#gad01e6c1296544674eb74616a97afd3fc">STORAGE_BITSIZE</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Defines the number of bits required to store one block of samples. </p>

<p class="definition">Definition at line <a class="el" href="a00008_source.html#l00404">404</a> of file <a class="el" href="a00008_source.html">storage_dft.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="a00002_source.html#l01160">MoveSamplesFromEepromToFlash()</a>, and <a class="el" href="a00002_source.html#l01300">ReadAndCacheSamplesFromFlash()</a>.</p>

</div>
</div>
<a id="ga03b6b7c38aff14a94b0d919538734255"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga03b6b7c38aff14a94b0d919538734255">&#9670;&nbsp;</a></span>STORAGE_UNCOMPRESSED_BLOCK_SIZE_IN_BYTES</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define STORAGE_UNCOMPRESSED_BLOCK_SIZE_IN_BYTES&#160;&#160;&#160;<a class="el" href="a00177.html#gad5156aa8d4f9dc31fcd5ff6efc9f5e42">STORAGE_IDIVUP</a>(<a class="el" href="a00177.html#ga3528a0fe95f4434f065d3824c488debc">STORAGE_UNCOMPRESSED_BLOCK_SIZE_IN_BITS</a>, 8)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Defines the number of bytes required to store one block of samples. </p>

<p class="definition">Definition at line <a class="el" href="a00008_source.html#l00407">407</a> of file <a class="el" href="a00008_source.html">storage_dft.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="a00002_source.html#l01160">MoveSamplesFromEepromToFlash()</a>, and <a class="el" href="a00002_source.html#l01300">ReadAndCacheSamplesFromFlash()</a>.</p>

</div>
</div>
<a id="ga4b69ffeada7d6e645ed70b84786850f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4b69ffeada7d6e645ed70b84786850f9">&#9670;&nbsp;</a></span>STORAGE_WORKAREA_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define STORAGE_WORKAREA_SIZE&#160;&#160;&#160;((FLASH_PAGE_SIZE * 2) + <a class="el" href="a00177.html#ga03b6b7c38aff14a94b0d919538734255">STORAGE_UNCOMPRESSED_BLOCK_SIZE_IN_BYTES</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The size in bytes of the required memory for this module </p>

<p class="definition">Definition at line <a class="el" href="a00008_source.html#l00410">410</a> of file <a class="el" href="a00008_source.html">storage_dft.h</a>.</p>

</div>
</div>
<a id="ga15ac8af84ac4d577fa08da026d419534"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga15ac8af84ac4d577fa08da026d419534">&#9670;&nbsp;</a></span>STORAGE_WORKAREA_SELF_DEFINED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define STORAGE_WORKAREA_SELF_DEFINED&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Used internally to know when to provide (static) memory for this. </p>

<p class="definition">Definition at line <a class="el" href="a00008_source.html#l00419">419</a> of file <a class="el" href="a00008_source.html">storage_dft.h</a>.</p>

</div>
</div>
<a id="gade36aef439049262b4a755353542de43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gade36aef439049262b4a755353542de43">&#9670;&nbsp;</a></span>STORAGE_WORKAREA</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define STORAGE_WORKAREA&#160;&#160;&#160;<a class="el" href="a00002.html#a2d5937977dab1cbd29de86cc5e11762d">sStorage_Workarea</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>An array, or a pointer to an array of at least <a class="el" href="a00177.html#ga4b69ffeada7d6e645ed70b84786850f9">STORAGE_WORKAREA_SIZE</a> bytes. During the lifetime of this module - starting from the start of the call to <a class="el" href="a00176.html#gad04fe4fa8e78ef5572e4a39dec188c31">Storage_Init</a> until the end of the call to <a class="el" href="a00176.html#ga75abea0be7fefec6285224dc0f82f5ac">Storage_DeInit</a>, this memory is under full control by this module. </p><dl class="section pre"><dt>Precondition</dt><dd>Must be word (32 bits) aligned. </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00008_source.html#l00426">426</a> of file <a class="el" href="a00008_source.html">storage_dft.h</a>.</p>

</div>
</div>
<a id="gad2c3a42a97cb31f6030cc561ca974eab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad2c3a42a97cb31f6030cc561ca974eab">&#9670;&nbsp;</a></span>STORAGE_COMPRESS_CB</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define STORAGE_COMPRESS_CB</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The name of the function - <b>not</b> a function pointer - of type <a class="el" href="a00176.html#gab7c664a0e73ef251f2e68bbd23d6cabb">pStorage_CompressCb_t</a> that is able to compress <a class="el" href="a00177.html#ga9023fc3872517d220a8f817eeef29957">STORAGE_BLOCK_SIZE_IN_SAMPLES</a> packed samples of type <a class="el" href="a00177.html#gacdcc483479cdfdecfdd8908db2ad80ba">STORAGE_TYPE</a> where <a class="el" href="a00177.html#gad01e6c1296544674eb74616a97afd3fc">STORAGE_BITSIZE</a> bits are retained for each. </p><dl class="section note"><dt>Note</dt><dd>When not overridden, the default behavior is to store the data uncompressed, i.e. the data is copied from EEPROM to FLASH unmodified. </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00008_source.html#l00442">442</a> of file <a class="el" href="a00008_source.html">storage_dft.h</a>.</p>

</div>
</div>
<a id="ga4bbfc00976edf761a51223936e7360fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4bbfc00976edf761a51223936e7360fb">&#9670;&nbsp;</a></span>STORAGE_DECOMPRESS_CB</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define STORAGE_DECOMPRESS_CB</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The name of the function - <b>not</b> a function pointer - of type <a class="el" href="a00176.html#gafb11c3cdbd067dcbbe54bac47ba3c6ff">pStorage_DecompressCb_t</a> that is able to decompress <a class="el" href="a00177.html#ga9023fc3872517d220a8f817eeef29957">STORAGE_BLOCK_SIZE_IN_SAMPLES</a> packed samples of type <a class="el" href="a00177.html#gacdcc483479cdfdecfdd8908db2ad80ba">STORAGE_TYPE</a> where <a class="el" href="a00177.html#gad01e6c1296544674eb74616a97afd3fc">STORAGE_BITSIZE</a> bits are retained for each. </p>

<p class="definition">Definition at line <a class="el" href="a00008_source.html#l00454">454</a> of file <a class="el" href="a00008_source.html">storage_dft.h</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Tue Oct 20 2020 08:24:37 for NHS31xx storage - Maximizing storage for equisized samples by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.14 </li>
  </ul>
</div>
</body>
</html>
