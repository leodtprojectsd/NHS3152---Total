<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NHS31xx SW API: ndeft2t: NDEF Type-2 Tag Message creator/parser Module</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="nxp-logo_small.jpg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NHS31xx SW API
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('a00479.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">ndeft2t: NDEF Type-2 Tag Message creator/parser Module<div class="ingroups"><a class="el" href="a00425.html">Modules</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>NDEFT2T module provides the API to handle creation and parsing of NDEF messages on a Type 2 Tag. The record types which are currently supported are NFC Forum well known types TEXT and URI, NFC Forum External types and MIME.</p>
<p>The NDEFT2T module provides the following functionalities:</p><ul>
<li>Creation of an NDEF message consisting of one or more supported record types.</li>
<li>Parsing of an NDEF message and extracting the supported record types.</li>
</ul>
<dl class="section user"><dt>NDEF:</dt><dd>The NFC Data Exchange Format (NDEF) specification defines a message encapsulation format to exchange information, e.g. between an NFC Forum Device and another NFC Forum Device or an NFC Forum Tag. NDEF is a lightweight, binary message format that can be used to encapsulate one or more application-defined payloads of arbitrary type and size into a single message. More details of this format can be referred from the NFC Forum specification available at <a href="http://members.nfc-forum.org/specs/spec_list/">http://members.nfc-forum.org/specs/spec_list/</a>.</dd></dl>
<dl class="section user"><dt>Memory Requirements:</dt><dd>The NDEFT2T module does not allocate any static R/W data memory. Instead, the caller should take care of the allocation of the memory required for the creation/parsing of the NDEF message. The NDEFT2T module memory requirements are contributed from the entities given below:<ul>
<li>Instance Buffer: The instance buffer preserves the necessary housekeeping information during an instantiation of the NDEFT2T module. A new instantiation is made either when <a class="el" href="a00479.html#ga70cfb3eb9393ab20bc3aa564171d89ff">NDEFT2T_CreateMessage()</a> or <a class="el" href="a00479.html#ga86e2733b30f43d68effad331fcb993c1">NDEFT2T_GetMessage()</a> is called. The caller must ensure that the argument pInstance passed to these functions points to a buffer of size <a class="el" href="a00479.html#ga22c7567e5e4cc7862e9e7e4b27d91e18">NDEFT2T_INSTANCE_SIZE</a> bytes. The caller must also ensure that the memory allocated for this buffer starts on a 32-bit aligned address in RAM.</li>
<li>Message Buffer: NDEFT2T module uses this buffer to initially create the NDEF message consisting of one or more records before finally copying the same to the shared memory. Similarly, during parsing, the entire message is initially copied to the message buffer and the constituent records are then parsed from that. The caller must ensure that the variable pBuffer passed when calling the functions <a class="el" href="a00479.html#ga70cfb3eb9393ab20bc3aa564171d89ff">NDEFT2T_CreateMessage()</a> or <a class="el" href="a00479.html#ga86e2733b30f43d68effad331fcb993c1">NDEFT2T_GetMessage()</a> has sufficient space to create/parse the entire NDEF message. However, it is safe to allocate a size of <a class="el" href="a00457.html#gac7d03f279b83abdbaef3a81ea3b0e30d">NFC_SHARED_MEM_BYTE_SIZE</a> (which stands for the size of the shared memory) in case the caller is not sure of the size of the NDEF message being created or parsed. The caller must also ensure that the memory allocated for this buffer starts on a 32-bit aligned address in RAM and has a size that is a multiple of 4.</li>
<li>Record information structure: The exchange of type information (main type and extended properties) for the record being created or parsed is achieved through the data structures <a class="el" href="a00479.html#a00746">NDEFT2T_CREATE_RECORD_INFO_T</a> and <a class="el" href="a00479.html#a00750">NDEFT2T_PARSE_RECORD_INFO_T</a> respectively. In the case of message creation, the caller must allocate and fill in the relevant fields of <a class="el" href="a00479.html#a00746">NDEFT2T_CREATE_RECORD_INFO_T</a> to input the information of the record to create. Similarly, in the case of parsing, the caller must allocate <a class="el" href="a00479.html#a00750">NDEFT2T_PARSE_RECORD_INFO_T</a> and process the information received about the record getting parsed.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Initialization/De-initialization:</dt><dd>The module has to be initialized before a message creation or parsing, at the start of application processing. This has to be done after initializing the NFC HW block (see <a class="el" href="a00457.html#ga97c0696317d3a042bf0fdc3600343d07">Chip_NFC_Init</a>) by calling <a class="el" href="a00479.html#gacbdbeead1744aa3447376a6f240edc58">NDEFT2T_Init</a>. Similarly, the module can be de-initialized by calling <a class="el" href="a00479.html#ga8433bf6f14a70748c7ab65f1907610bd">NDEFT2T_DeInit</a> followed by de-initialization of the NFC HW block (see Chip_NFC_DeInit) after the application processing is complete. Note that the Initialization/de-initialization of the NFC HW block is not done inside the module and hence has to be done at application level in the order mentioned above.</dd></dl>
<dl class="section user"><dt>NDEF Message creation:</dt><dd>The below steps outline the NDEF message creation:<ul>
<li>Step1: Call <a class="el" href="a00479.html#ga70cfb3eb9393ab20bc3aa564171d89ff">NDEFT2T_CreateMessage</a> to instantiate a new NDEF message and prepare for adding constituent records into it. The caller must ensure to allocate sufficient memory for the arguments pInstance and pBuffer before calling the above function.</li>
<li>Step2: Create one or more records in the instantiated NDEF message by following the procedure listed below till all records have been created.<ul>
<li>Create record: Call one of the functions <a class="el" href="a00479.html#ga383ef299e95ca2a474cef1856fe0a0a1">NDEFT2T_CreateTextRecord</a>, <a class="el" href="a00479.html#ga65be886d4b4967d5e552c31b408b9daa">NDEFT2T_CreateUriRecord</a> <a class="el" href="a00479.html#ga3f8846fb81d6f363236479d43a9eae55">NDEFT2T_CreateExtRecord</a> or <a class="el" href="a00479.html#gaa212d62dc1721f3ec4fb001b842bd61b">NDEFT2T_CreateMimeRecord</a> for creating NFC Forum well known types TEXT and URI, NFC Forum External types or MIME. The caller must ensure to initialize relevant fields of the record information argument pRecordInfo before calling the above functions.</li>
<li>Copy record payload: Call the function <a class="el" href="a00479.html#ga23418d555943119a964b80b5c8e410d2">NDEFT2T_WriteRecordPayload</a> to copy the record payload to the message buffer.</li>
<li>Finalize record: Call the function <a class="el" href="a00479.html#ga2a13584ed6943a9b21b2bc807e074fd8">NDEFT2T_CommitRecord</a> to finalize the record.</li>
</ul>
</li>
<li>Step3: Call function <a class="el" href="a00479.html#gaa1166ef185ee22d55489cf1927adb566">NDEFT2T_CommitMessage</a> to finalize the NDEF message. The user cannot add any more records after this. The finalised message is copied to the shared memory at this stage.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>NDEF Message Parsing:</dt><dd>The below steps outline the NDEF message parsing:<ul>
<li>Step1: Call function <a class="el" href="a00479.html#ga86e2733b30f43d68effad331fcb993c1">NDEFT2T_GetMessage</a> to copy the NDEF message from shared memory into the message buffer. The caller must ensure to allocate sufficient memory for the arguments pInstance and pBuffer before calling the above function.</li>
<li>Step2: Call the function <a class="el" href="a00479.html#ga6a3a42026d8354639b9de950f8dd6138">NDEFT2T_GetNextRecord</a> to search and retrieve the next record present in the NDEF message. The caller can then check the returned record information from the argument pRecordInfo and decide whether this record type is relevant for the application scenario.</li>
<li>Step3: Call the function <a class="el" href="a00479.html#ga5e32405e5c62a6e42cac4ce8d8df188c">NDEFT2T_GetRecordPayload</a> to retrieve record payload.</li>
</ul>
Continue steps 2 and 3 above till all the relevant records have been retrieved or till end of message.</dd></dl>
<p><a class="anchor" id="nfcIntHandling_anchor"></a></p><dl class="section user"><dt>NFC Interrupt Handling:</dt><dd>This module provides an implementation of the interrupt vector <a class="el" href="a00481.html#gac1c3452d4422030154067f1cc26279a3">NFC_IRQHandler</a> and controls the interrupt <a class="el" href="a00435.html#gga7e1129cd8a196f4284d41db3e82ad5c8a22e3d8d1df0ecc438b592f06a0bd7ca2">NFC_IRQn</a>. By including this module, the application can no longer instantiate the NFC interrupt handler and may no longer enable, disable or clear the corresponding interrupts. The interrupts which are enabled all the time are <a class="el" href="a00457.html#ggadc1c0828fcebab2311e7c89040b2dc19a9053ea7aed85752a1fa4344211380395">NFC_INT_RFSELECT</a>, <a class="el" href="a00457.html#ggadc1c0828fcebab2311e7c89040b2dc19a77d23daaa82cf9f8b9b8337754a029eb">NFC_INT_TARGETWRITE</a> and <a class="el" href="a00457.html#ggadc1c0828fcebab2311e7c89040b2dc19a7d4aa3785b8c7df436858a1bc63dbae9">NFC_INT_NFCOFF</a> interrupts. However, <a class="el" href="a00457.html#ggadc1c0828fcebab2311e7c89040b2dc19a449ed3ad2dcb16b03978076c5a0f10b2">NFC_INT_MEMWRITE</a> and <a class="el" href="a00457.html#ggadc1c0828fcebab2311e7c89040b2dc19a5aed387eb6871afa72a4ff3067921205">NFC_INT_TARGETREAD</a> interrupts are also enabled/disabled internally by the module during NDEF message creation. Two callback functions are provided to the application, of types <a class="el" href="a00479.html#gac8dadf40ffa8266581eadcf6b79d15c8">pNdeft2t_FieldStatus_Cb_t</a> and <a class="el" href="a00479.html#ga21b67e5fba50153110a7862a5a40fd63">pNdeft2t_MsgAvailable_Cb_t</a>. These are called from the interrupt handler.<ul>
<li>The callback function of type <a class="el" href="a00479.html#gac8dadf40ffa8266581eadcf6b79d15c8">pNdeft2t_FieldStatus_Cb_t</a> provides the current status of the NFC field (ON or OFF) as obtained inside the interrupt handler.</li>
<li>The callback function of type <a class="el" href="a00479.html#ga21b67e5fba50153110a7862a5a40fd63">pNdeft2t_MsgAvailable_Cb_t</a> gets fired once per message, indicating the presence of a valid NDEF message in the shared memory. This can be used as a trigger for the application to start the parsing of a new NDEF message.</li>
</ul>
The application has to implement these callbacks and enable them by using the respective diversity settings <a class="el" href="a00480.html#gabcf3fbd280b24bea200801554ef2bbc1">NDEFT2T_FIELD_STATUS_CB</a> and <a class="el" href="a00480.html#ga5647a6582c2b2d2d06602035c6d61de4">NDEFT2T_MSG_AVAILABLE_CB</a>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The <a class="el" href="a00457.html#ggadc1c0828fcebab2311e7c89040b2dc19a77d23daaa82cf9f8b9b8337754a029eb">NFC_INT_TARGETWRITE</a> and <a class="el" href="a00457.html#ggadc1c0828fcebab2311e7c89040b2dc19a5aed387eb6871afa72a4ff3067921205">NFC_INT_TARGETREAD</a> interrupts are internally configured by the module to occur for page 6 of the NFC Tag memory as seen from RF side or page 2 of the NFC shared memory.</dd></dl>
<p><a class="anchor" id="colDetDesc_anchor"></a></p><dl class="section user"><dt>Shared memory access collision detection:</dt><dd>This feature allows detecting a collision in case of a simultaneous read/write access from both the APB-side and RF-side from/to the shared memory. The data that is getting read from the APB-side can get corrupted due to a simultaneous data write from the RF side. In a similar way, the data that is getting written from the APB-side can also get corrupted. The collision detection feature allows detecting such a corruption and the read or write attempt can be retried for a specified number of times by using respective diversity settings (See <a class="el" href="a00480.html">Diversity Settings</a>).</dd></dl>
<dl class="section user"><dt>Record and Message Header overheads</dt><dd>An NDEF message has few record and message header bytes in addition to the record payloads. The overhead in bytes required for these header bytes can be obtained using the macros <a class="el" href="a00479.html#ga481337d4d39d7f00bcbb1b655a7dbbe0">NDEFT2T_TEXT_RECORD_OVERHEAD</a>, <a class="el" href="a00479.html#ga6273fcd719ee26aff474441ee10b411e">NDEFT2T_MIME_RECORD_OVERHEAD</a>, <a class="el" href="a00479.html#ga17f5b5be81f1b45fbcde60834f4a48a4">NDEFT2T_EXT_RECORD_OVERHEAD</a>, <a class="el" href="a00479.html#ga9ea61e40b2eb1dbe7ec8a0b17a59e9e0">NDEFT2T_URI_RECORD_OVERHEAD</a> and <a class="el" href="a00479.html#gad96246ce81e82ea3e9b9662025424898">NDEFT2T_MSG_OVERHEAD</a>. Knowing the overhead will enable the application writer to know the bytes left in the shared memory for the record payload. An example usage is given below for a message with a TEXT and MIME record each being a short record and the total message payload size being less than 255 bytes:<ul>
<li>overhead = NDEFT2T_MSG_OVERHEAD(true, (NDEFT2T_TEXT_RECORD_OVERHEAD(true, sizeof("en")-1) + NDEFT2T_MIME_RECORD_OVERHEAD(true, sizeof("nhs31xx/demo.nhs.log")-1));</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Diversity</dt><dd>This module supports diversity, like enabling/disabling collision detection and also to specify the number of read/write retries in case of a collision. Check <a class="el" href="a00480.html">Diversity Settings</a> for all diversity parameters.</dd></dl>
<dl class="section user"><dt>Example1 - Creating an NDEF Message with a single record of type TEXT</dt><dd>NDEF messages consisting of a single record of types MIME, AAR and URI can be created in a similar way as given in this example. <div class="fragment"><div class="line">    uint8_t instance[<a class="code" href="a00479.html#ga22c7567e5e4cc7862e9e7e4b27d91e18">NDEFT2T_INSTANCE_SIZE</a>] __attribute__((aligned (4)));</div><div class="line">    uint8_t buffer[<a class="code" href="a00457.html#gac7d03f279b83abdbaef3a81ea3b0e30d">NFC_SHARED_MEM_BYTE_SIZE</a> ] __attribute__((aligned (4)));</div><div class="line">    uint8_t locale[] = <span class="stringliteral">&quot;en&quot;</span>;</div><div class="line">    uint8_t text[] = <span class="stringliteral">&quot;Hello World&quot;</span>;</div><div class="line"></div><div class="line">    <a class="code" href="a00457.html#ga97c0696317d3a042bf0fdc3600343d07">Chip_NFC_Init</a>(<a class="code" href="a00433.html#ga8efeb8924ba11243c8d540dfaea086af">NSS_NFC</a>); <span class="comment">/* Is normally already called during board initialization. */</span></div><div class="line">    <a class="code" href="a00479.html#gacbdbeead1744aa3447376a6f240edc58">NDEFT2T_Init</a>();</div><div class="line"></div><div class="line">    <a class="code" href="a00479.html#ga70cfb3eb9393ab20bc3aa564171d89ff">NDEFT2T_CreateMessage</a>(instance, buffer, <a class="code" href="a00457.html#gac7d03f279b83abdbaef3a81ea3b0e30d">NFC_SHARED_MEM_BYTE_SIZE</a>, <span class="keyword">true</span>);</div><div class="line"></div><div class="line">    <a class="code" href="a00479.html#a00746">NDEFT2T_CREATE_RECORD_INFO_T</a> recordInfo = {.<a class="code" href="a00479.html#a9b8679ecfbf98d4533fa37393046b632">shortRecord</a> = <span class="keyword">true</span>, .pString = locale};</div><div class="line">    <span class="keywordflow">if</span> (<a class="code" href="a00479.html#ga383ef299e95ca2a474cef1856fe0a0a1">NDEFT2T_CreateTextRecord</a>(instance, &amp;recordInfo)) {</div><div class="line">        <span class="comment">/* The payload length to pass excludes the NUL terminator. */</span></div><div class="line">        <span class="keywordflow">if</span> (<a class="code" href="a00479.html#ga23418d555943119a964b80b5c8e410d2">NDEFT2T_WriteRecordPayload</a>(instance, text, <span class="keyword">sizeof</span>(text) - 1)) {</div><div class="line">            <a class="code" href="a00479.html#ga2a13584ed6943a9b21b2bc807e074fd8">NDEFT2T_CommitRecord</a>(instance);</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <a class="code" href="a00479.html#gaa1166ef185ee22d55489cf1927adb566">NDEFT2T_CommitMessage</a>(instance);</div><div class="line">    <span class="comment">/* The return value of the commit function is ignored here. */</span></div></div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>Example2 - Creating an NDEF Message with one TEXT record and one MIME record</dt><dd><div class="fragment"><div class="line">    uint8_t instance[<a class="code" href="a00479.html#ga22c7567e5e4cc7862e9e7e4b27d91e18">NDEFT2T_INSTANCE_SIZE</a>]  __attribute__((aligned (4)));</div><div class="line">    uint8_t buffer[<a class="code" href="a00457.html#gac7d03f279b83abdbaef3a81ea3b0e30d">NFC_SHARED_MEM_BYTE_SIZE</a>]  __attribute__((aligned (4)));</div><div class="line">    <a class="code" href="a00479.html#a00746">NDEFT2T_CREATE_RECORD_INFO_T</a> recordInfo = {.<a class="code" href="a00479.html#a9b8679ecfbf98d4533fa37393046b632">shortRecord</a> = <span class="keyword">true</span>};</div><div class="line">    uint8_t locale[] = <span class="stringliteral">&quot;en&quot;</span>;</div><div class="line">    uint8_t text[] = <span class="stringliteral">&quot;Hello World&quot;</span>;</div><div class="line">    uint8_t mimeType[] = <span class="stringliteral">&quot;nhs31xx/demo.nhs.nxp.log&quot;</span>;</div><div class="line">    uint8_t mimePayload[] = {0xab, 0xbc, 0xcd, 0xde, 0xef};</div><div class="line"></div><div class="line">    <a class="code" href="a00457.html#ga97c0696317d3a042bf0fdc3600343d07">Chip_NFC_Init</a>(<a class="code" href="a00433.html#ga8efeb8924ba11243c8d540dfaea086af">NSS_NFC</a>); <span class="comment">/* Is normally already called during board initialization. */</span></div><div class="line">    <a class="code" href="a00479.html#gacbdbeead1744aa3447376a6f240edc58">NDEFT2T_Init</a>();</div><div class="line"></div><div class="line">    <a class="code" href="a00479.html#ga70cfb3eb9393ab20bc3aa564171d89ff">NDEFT2T_CreateMessage</a>(instance, buffer, <a class="code" href="a00457.html#gac7d03f279b83abdbaef3a81ea3b0e30d">NFC_SHARED_MEM_BYTE_SIZE</a>, <span class="keyword">true</span>);</div><div class="line">    recordInfo.<a class="code" href="a00479.html#a4f9622821cb20009b23b18c58d72ec4e">pString</a> = locale;</div><div class="line">    <span class="keywordflow">if</span> (<a class="code" href="a00479.html#ga383ef299e95ca2a474cef1856fe0a0a1">NDEFT2T_CreateTextRecord</a>(instance, &amp;recordInfo)) {</div><div class="line">        <span class="comment">/* The payload length to pass excludes the NUL terminator. */</span></div><div class="line">        <span class="keywordflow">if</span> (<a class="code" href="a00479.html#ga23418d555943119a964b80b5c8e410d2">NDEFT2T_WriteRecordPayload</a>(instance, text, <span class="keyword">sizeof</span>(text) - 1)) {</div><div class="line">            <a class="code" href="a00479.html#ga2a13584ed6943a9b21b2bc807e074fd8">NDEFT2T_CommitRecord</a>(instance);</div><div class="line">        }</div><div class="line">    }</div><div class="line">    recordInfo.<a class="code" href="a00479.html#a4f9622821cb20009b23b18c58d72ec4e">pString</a> = mimeType;</div><div class="line">    <span class="keywordflow">if</span> (<a class="code" href="a00479.html#gaa212d62dc1721f3ec4fb001b842bd61b">NDEFT2T_CreateMimeRecord</a>(instance, &amp;recordInfo)) {</div><div class="line">        <span class="keywordflow">if</span> (<a class="code" href="a00479.html#ga23418d555943119a964b80b5c8e410d2">NDEFT2T_WriteRecordPayload</a>(instance, mimePayload, <span class="keyword">sizeof</span>(mimePayload))) {</div><div class="line">            <a class="code" href="a00479.html#ga2a13584ed6943a9b21b2bc807e074fd8">NDEFT2T_CommitRecord</a>(instance);</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <a class="code" href="a00479.html#gaa1166ef185ee22d55489cf1927adb566">NDEFT2T_CommitMessage</a>(instance);</div><div class="line">    <span class="comment">/* The return value of the commit function is ignored here. */</span></div></div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>Example3 - Parsing of an NDEF Message with a single record of type TEXT</dt><dd><div class="fragment"><div class="line">    <span class="keyword">static</span> uint8_t sBuffer[<a class="code" href="a00457.html#gac7d03f279b83abdbaef3a81ea3b0e30d">NFC_SHARED_MEM_BYTE_SIZE</a>] __attribute__((aligned (4)));</div><div class="line">    uint8_t instance[<a class="code" href="a00479.html#ga22c7567e5e4cc7862e9e7e4b27d91e18">NDEFT2T_INSTANCE_SIZE</a>] __attribute__((aligned (4)));</div><div class="line">    <a class="code" href="a00479.html#a00750">NDEFT2T_PARSE_RECORD_INFO_T</a> parseRecordInfo;</div><div class="line">    <span class="keywordtype">int</span> len = 0;</div><div class="line">    uint8_t *payload = NULL;</div><div class="line"></div><div class="line">    <span class="comment">/* Chip_NFC_Init is normally already called during board initialization. */</span></div><div class="line">    <span class="comment">//Chip_NFC_Init(NSS_NFC);</span></div><div class="line">    <span class="comment">/* NDEFT2T_Init should have been called after NFC initialization. */</span></div><div class="line">    <span class="comment">//NDEFT2T_Init();</span></div><div class="line"></div><div class="line">    <span class="comment">/* In this example, we assume a proper NDEF message has already been written in the NFC shared memory by an external</span></div><div class="line"><span class="comment">     * reader (typically an NFC-enabled Android phone).</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keywordflow">if</span> (<a class="code" href="a00479.html#ga86e2733b30f43d68effad331fcb993c1">NDEFT2T_GetMessage</a>(instance, sBuffer, <a class="code" href="a00457.html#gac7d03f279b83abdbaef3a81ea3b0e30d">NFC_SHARED_MEM_BYTE_SIZE</a>)) {</div><div class="line">        <span class="keywordflow">while</span> (<a class="code" href="a00479.html#ga6a3a42026d8354639b9de950f8dd6138">NDEFT2T_GetNextRecord</a>(instance, &amp;parseRecordInfo)) {</div><div class="line">            <span class="keywordflow">if</span> (parseRecordInfo.<a class="code" href="a00479.html#a3266cbb1c231ad8e6b91216f0885f06e">type</a> == <a class="code" href="a00479.html#ggaa2778808e2b7b2a4ee758d5db7961e6eae9ce224e3055c3a0d7a4028279a63a6d">NDEFT2T_RECORD_TYPE_TEXT</a>) {</div><div class="line">                payload = (uint8_t *)<a class="code" href="a00479.html#ga5e32405e5c62a6e42cac4ce8d8df188c">NDEFT2T_GetRecordPayload</a>(instance, &amp;len);</div><div class="line">                <span class="comment">/* payload now points to the start of the record payload bytes.</span></div><div class="line"><span class="comment">                 * len contains the length of the payload in number of bytes.</span></div><div class="line"><span class="comment">                 */</span></div><div class="line">                <span class="comment">/* ... */</span></div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div></div><!-- fragment --></dd></dl>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:a00480"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00480.html">Diversity Settings</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:a00746"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00479.html#a00746">NDEFT2T_CREATE_RECORD_INFO_T</a></td></tr>
<tr class="separator:a00746"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00750"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00479.html#a00750">NDEFT2T_PARSE_RECORD_INFO_T</a></td></tr>
<tr class="separator:a00750"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga22c7567e5e4cc7862e9e7e4b27d91e18"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00479.html#ga22c7567e5e4cc7862e9e7e4b27d91e18">NDEFT2T_INSTANCE_SIZE</a>&#160;&#160;&#160;24</td></tr>
<tr class="separator:ga22c7567e5e4cc7862e9e7e4b27d91e18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga481337d4d39d7f00bcbb1b655a7dbbe0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00479.html#ga481337d4d39d7f00bcbb1b655a7dbbe0">NDEFT2T_TEXT_RECORD_OVERHEAD</a>(shortRecord,  localeLength)&#160;&#160;&#160;(4 + ((shortRecord) ? 1 : 4) + (localeLength))</td></tr>
<tr class="separator:ga481337d4d39d7f00bcbb1b655a7dbbe0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6273fcd719ee26aff474441ee10b411e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00479.html#ga6273fcd719ee26aff474441ee10b411e">NDEFT2T_MIME_RECORD_OVERHEAD</a>(shortRecord,  typeLength)&#160;&#160;&#160;(2 + ((shortRecord) ? 1 : 4) + (typeLength))</td></tr>
<tr class="separator:ga6273fcd719ee26aff474441ee10b411e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga17f5b5be81f1b45fbcde60834f4a48a4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00479.html#ga17f5b5be81f1b45fbcde60834f4a48a4">NDEFT2T_EXT_RECORD_OVERHEAD</a>(shortRecord,  typeLength)&#160;&#160;&#160;(2 + ((shortRecord) ? 1 : 4) + (typeLength))</td></tr>
<tr class="separator:ga17f5b5be81f1b45fbcde60834f4a48a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ea61e40b2eb1dbe7ec8a0b17a59e9e0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00479.html#ga9ea61e40b2eb1dbe7ec8a0b17a59e9e0">NDEFT2T_URI_RECORD_OVERHEAD</a>(shortRecord)&#160;&#160;&#160;(4 + ((shortRecord) ? 1 : 4))</td></tr>
<tr class="separator:ga9ea61e40b2eb1dbe7ec8a0b17a59e9e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad96246ce81e82ea3e9b9662025424898"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00479.html#gad96246ce81e82ea3e9b9662025424898">NDEFT2T_MSG_OVERHEAD</a>(shortMessage,  totalRecordOverhead)&#160;&#160;&#160;(8 + 2 + ((shortMessage) ? 1 : 3) + (totalRecordOverhead))</td></tr>
<tr class="separator:gad96246ce81e82ea3e9b9662025424898"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7534ae047d7e38cb6d59d848753df6eb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00479.html#ga7534ae047d7e38cb6d59d848753df6eb">NDEFT2T_EnableAutomaticMode</a>()&#160;&#160;&#160;<a class="el" href="a00479.html#ga64408e83c05d65094bcf54a6d7977c1c">NDEFT2T_EnableMessageReadDetection</a>(0)</td></tr>
<tr class="separator:ga7534ae047d7e38cb6d59d848753df6eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gac8dadf40ffa8266581eadcf6b79d15c8"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00479.html#gac8dadf40ffa8266581eadcf6b79d15c8">pNdeft2t_FieldStatus_Cb_t</a>) (bool isPresent)</td></tr>
<tr class="separator:gac8dadf40ffa8266581eadcf6b79d15c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga21b67e5fba50153110a7862a5a40fd63"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00479.html#ga21b67e5fba50153110a7862a5a40fd63">pNdeft2t_MsgAvailable_Cb_t</a>) (void)</td></tr>
<tr class="separator:ga21b67e5fba50153110a7862a5a40fd63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba34e811f8444fb2c0b9c98d33fc49bc"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00479.html#gaba34e811f8444fb2c0b9c98d33fc49bc">pNdeft2t_MsgRead_Cb_t</a>) (void)</td></tr>
<tr class="separator:gaba34e811f8444fb2c0b9c98d33fc49bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gaa2778808e2b7b2a4ee758d5db7961e6e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00479.html#gaa2778808e2b7b2a4ee758d5db7961e6e">NDEFT2T_RECORD_TYPE_T</a> { <br />
&#160;&#160;<a class="el" href="a00479.html#ggaa2778808e2b7b2a4ee758d5db7961e6ea8260df5470501730ab098e47d3318b49">NDEFT2T_RECORD_TYPE_EMPTY</a> = 0x00, 
<br />
&#160;&#160;<a class="el" href="a00479.html#ggaa2778808e2b7b2a4ee758d5db7961e6ea7d7e1d9167846567b6eb9855f2835a6a">NDEFT2T_RECORD_TYPE_UNKNOWN</a>, 
<br />
&#160;&#160;<a class="el" href="a00479.html#ggaa2778808e2b7b2a4ee758d5db7961e6ea30c4a2e6a35317735ec980065801c721">NDEFT2T_RECORD_TYPE_UNCHANGED</a>, 
<br />
&#160;&#160;<a class="el" href="a00479.html#ggaa2778808e2b7b2a4ee758d5db7961e6eae9ce224e3055c3a0d7a4028279a63a6d">NDEFT2T_RECORD_TYPE_TEXT</a>, 
<br />
&#160;&#160;<a class="el" href="a00479.html#ggaa2778808e2b7b2a4ee758d5db7961e6ea036a802d92ce61407de238b0927f441e">NDEFT2T_RECORD_TYPE_MIME</a>, 
<br />
&#160;&#160;<a class="el" href="a00479.html#ggaa2778808e2b7b2a4ee758d5db7961e6eaa2cf6dc0230a71b8fc6603393a8c1757">NDEFT2T_RECORD_TYPE_EXT</a>, 
<br />
&#160;&#160;<a class="el" href="a00479.html#ggaa2778808e2b7b2a4ee758d5db7961e6ea1fb957508be72144eff763574b2303b8">NDEFT2T_RECORD_TYPE_URI</a>, 
<br />
&#160;&#160;<a class="el" href="a00479.html#ggaa2778808e2b7b2a4ee758d5db7961e6ea83ee408eec31c33ff9ad79af30b6c8b4">NDEFT2T_RECORD_TYPE_PHDC</a>, 
<br />
&#160;&#160;<a class="el" href="a00479.html#ggaa2778808e2b7b2a4ee758d5db7961e6eaa39592d7ee50950260478914a39f409c">NDEFT2T_RECORD_TYPE_RESERVED</a>
<br />
 }</td></tr>
<tr class="separator:gaa2778808e2b7b2a4ee758d5db7961e6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gacbdbeead1744aa3447376a6f240edc58"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00479.html#gacbdbeead1744aa3447376a6f240edc58">NDEFT2T_Init</a> (void)</td></tr>
<tr class="separator:gacbdbeead1744aa3447376a6f240edc58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8433bf6f14a70748c7ab65f1907610bd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00479.html#ga8433bf6f14a70748c7ab65f1907610bd">NDEFT2T_DeInit</a> (void)</td></tr>
<tr class="separator:ga8433bf6f14a70748c7ab65f1907610bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab16f4f04bd89c492ed8b58a2ce98c252"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00479.html#gab16f4f04bd89c492ed8b58a2ce98c252">NDEFT2T_ResetNfcMemory</a> (void)</td></tr>
<tr class="separator:gab16f4f04bd89c492ed8b58a2ce98c252"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga64408e83c05d65094bcf54a6d7977c1c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00479.html#ga64408e83c05d65094bcf54a6d7977c1c">NDEFT2T_EnableMessageReadDetection</a> (unsigned int lastPageOfMessage)</td></tr>
<tr class="separator:ga64408e83c05d65094bcf54a6d7977c1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaace6dbc7404f6ab555e816b51d720f79"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00479.html#gaace6dbc7404f6ab555e816b51d720f79">NDEFT2T_DisableMessageReadDetection</a> (void)</td></tr>
<tr class="separator:gaace6dbc7404f6ab555e816b51d720f79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga70cfb3eb9393ab20bc3aa564171d89ff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00479.html#ga70cfb3eb9393ab20bc3aa564171d89ff">NDEFT2T_CreateMessage</a> (void *pInstance, uint8_t *pBuffer, int bufLen, bool shortMessage)</td></tr>
<tr class="separator:ga70cfb3eb9393ab20bc3aa564171d89ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga383ef299e95ca2a474cef1856fe0a0a1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00479.html#ga383ef299e95ca2a474cef1856fe0a0a1">NDEFT2T_CreateTextRecord</a> (void *pInstance, const <a class="el" href="a00479.html#a00746">NDEFT2T_CREATE_RECORD_INFO_T</a> *pRecordInfo)</td></tr>
<tr class="separator:ga383ef299e95ca2a474cef1856fe0a0a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f8846fb81d6f363236479d43a9eae55"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00479.html#ga3f8846fb81d6f363236479d43a9eae55">NDEFT2T_CreateExtRecord</a> (void *pInstance, const <a class="el" href="a00479.html#a00746">NDEFT2T_CREATE_RECORD_INFO_T</a> *pRecordInfo)</td></tr>
<tr class="separator:ga3f8846fb81d6f363236479d43a9eae55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa212d62dc1721f3ec4fb001b842bd61b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00479.html#gaa212d62dc1721f3ec4fb001b842bd61b">NDEFT2T_CreateMimeRecord</a> (void *pInstance, const <a class="el" href="a00479.html#a00746">NDEFT2T_CREATE_RECORD_INFO_T</a> *pRecordInfo)</td></tr>
<tr class="separator:gaa212d62dc1721f3ec4fb001b842bd61b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga65be886d4b4967d5e552c31b408b9daa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00479.html#ga65be886d4b4967d5e552c31b408b9daa">NDEFT2T_CreateUriRecord</a> (void *pInstance, const <a class="el" href="a00479.html#a00746">NDEFT2T_CREATE_RECORD_INFO_T</a> *pRecordInfo)</td></tr>
<tr class="separator:ga65be886d4b4967d5e552c31b408b9daa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga23418d555943119a964b80b5c8e410d2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00479.html#ga23418d555943119a964b80b5c8e410d2">NDEFT2T_WriteRecordPayload</a> (void *pInstance, const void *pData, int size)</td></tr>
<tr class="separator:ga23418d555943119a964b80b5c8e410d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2a13584ed6943a9b21b2bc807e074fd8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00479.html#ga2a13584ed6943a9b21b2bc807e074fd8">NDEFT2T_CommitRecord</a> (void *pInstance)</td></tr>
<tr class="separator:ga2a13584ed6943a9b21b2bc807e074fd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa1166ef185ee22d55489cf1927adb566"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00479.html#gaa1166ef185ee22d55489cf1927adb566">NDEFT2T_CommitMessage</a> (void *pInstance)</td></tr>
<tr class="separator:gaa1166ef185ee22d55489cf1927adb566"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86e2733b30f43d68effad331fcb993c1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00479.html#ga86e2733b30f43d68effad331fcb993c1">NDEFT2T_GetMessage</a> (void *pInstance, uint8_t *pBuffer, int bufLen)</td></tr>
<tr class="separator:ga86e2733b30f43d68effad331fcb993c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a3a42026d8354639b9de950f8dd6138"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00479.html#ga6a3a42026d8354639b9de950f8dd6138">NDEFT2T_GetNextRecord</a> (void *pInstance, <a class="el" href="a00479.html#a00750">NDEFT2T_PARSE_RECORD_INFO_T</a> *pRecordInfo)</td></tr>
<tr class="separator:ga6a3a42026d8354639b9de950f8dd6138"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e32405e5c62a6e42cac4ce8d8df188c"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00479.html#ga5e32405e5c62a6e42cac4ce8d8df188c">NDEFT2T_GetRecordPayload</a> (void *pInstance, int *pLen)</td></tr>
<tr class="separator:ga5e32405e5c62a6e42cac4ce8d8df188c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<hr/><h2 class="groupheader">Data Structure Documentation</h2>
<a name="a00746" id="a00746"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00746">&#9670;&nbsp;</a></span>NDEFT2T_CREATE_RECORD_INFO_T</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct NDEFT2T_CREATE_RECORD_INFO_T</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Record information data structure to be used for Creation </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a4f9622821cb20009b23b18c58d72ec4e"></a>uint8_t *</td>
<td class="fieldname">
pString</td>
<td class="fielddoc">
<p>This field is used to pass the payload type string as given below. The caller shall ensure NULL termination of this string.</p><ul>
<li>For a TEXT record, locale string such as 'en', 'fr' to be provided here.</li>
<li>For NFC Forum external Type record (Eg. AAR), payload type to be provided here.</li>
<li>For MIME type record: MIME type string to be provided here.</li>
<li>Ignored for URI records.</li>
</ul>
</td></tr>
<tr><td class="fieldtype">
<a id="a9b8679ecfbf98d4533fa37393046b632"></a>bool</td>
<td class="fieldname">
shortRecord</td>
<td class="fielddoc">
<p>Set to <code>true</code> to use short records, <code>false</code> otherwise. </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a9324a5f04906c66ad6fdd25eb8e898ef"></a>uint32_t</td>
<td class="fieldname">
uriCode</td>
<td class="fielddoc">
<p>URI identifier code. Applicable only when type equals <a class="el" href="a00479.html#ggaa2778808e2b7b2a4ee758d5db7961e6ea1fb957508be72144eff763574b2303b8">NDEFT2T_RECORD_TYPE_URI</a>. A full list is available in the technical specification from NFC Forum: NFC URI Record Type Definition Technical Specification.pdf "URI Record Type Definition Technical Specification, RTD-URI 1.0, 2006-07-24, 3.2.2 URI Identifier Code, table 3". The most common ones are:</p><ul>
<li>0x00 - No prepending is done, and the URI field contains the unabridged URI.</li>
<li>0x01 - "http://www."</li>
<li>0x02 - "https://www."</li>
<li>0x03 - "http://"</li>
<li>0x04 - "https://"</li>
<li>0x06 - "mailto:"</li>
<li>0x07 - "ftp://anonymous:anonymous@"</li>
<li>0x08 - "ftp://ftp."</li>
<li>0x09 - "ftps://"</li>
<li>0x0A - "sftp://"</li>
</ul>
</td></tr>
</table>

</div>
</div>
<a name="a00750" id="a00750"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00750">&#9670;&nbsp;</a></span>NDEFT2T_PARSE_RECORD_INFO_T</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct NDEFT2T_PARSE_RECORD_INFO_T</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Record information data structure to be used for Parsing </p><dl class="section note"><dt>Note</dt><dd>: NDEFT2T module supports extraction of record information for only MIME and TEXT type records. Extraction of all record information fields for URI and AAR is not supported. </dd></dl>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a3266cbb1c231ad8e6b91216f0885f06e"></a><a class="el" href="a00479.html#gaa2778808e2b7b2a4ee758d5db7961e6e">NDEFT2T_RECORD_TYPE_T</a></td>
<td class="fieldname">
type</td>
<td class="fielddoc">
<p>Type of record. </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a4f9622821cb20009b23b18c58d72ec4e"></a>uint8_t *</td>
<td class="fieldname">
pString</td>
<td class="fielddoc">
<p>This field is used to retrieve the payload type string as given below.<br />
 &ndash;For a TEXT record, locale string such as 'en', 'fr' can be retrieved from this.<br />
 &ndash;For MIME type record: MIME type string can be retrieved from this. </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a5e3388c8976fccb67f81b60117291459"></a>int</td>
<td class="fieldname">
stringLength</td>
<td class="fielddoc">
<p>Length of type string defined above. </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a600582e5fea55590fe3f995106059a30"></a>bool</td>
<td class="fieldname">
chunked</td>
<td class="fielddoc">
<p>When set to <code>true</code> the current record is a chunk. When set to <code>false</code>, the current record is the last chunk of the record, provided the previous record was a chunk. This field will remain <code>false</code> when records are not chunked. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga22c7567e5e4cc7862e9e7e4b27d91e18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga22c7567e5e4cc7862e9e7e4b27d91e18">&#9670;&nbsp;</a></span>NDEFT2T_INSTANCE_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NDEFT2T_INSTANCE_SIZE&#160;&#160;&#160;24</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Size of Instance buffer required by the NDEFT2T module for internal housekeeping. </p>

</div>
</div>
<a id="ga481337d4d39d7f00bcbb1b655a7dbbe0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga481337d4d39d7f00bcbb1b655a7dbbe0">&#9670;&nbsp;</a></span>NDEFT2T_TEXT_RECORD_OVERHEAD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NDEFT2T_TEXT_RECORD_OVERHEAD</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">shortRecord, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">localeLength&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;(4 + ((shortRecord) ? 1 : 4) + (localeLength))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculates the overhead in bytes required for a TEXT record header. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shortRecord</td><td>: Set this to <code>true</code> if the payload size is known to be &lt;= 255 bytes. Use <code>false</code> if it is bigger, unknown or to get the largest overhead in bytes. </td></tr>
    <tr><td class="paramname">localeLength</td><td>: This is the length of the locale string <b>without</b> the <code>NULL</code> character as given in <a class="el" href="a00479.html#a4f9622821cb20009b23b18c58d72ec4e">NDEFT2T_CREATE_RECORD_INFO_T.pString</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6273fcd719ee26aff474441ee10b411e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6273fcd719ee26aff474441ee10b411e">&#9670;&nbsp;</a></span>NDEFT2T_MIME_RECORD_OVERHEAD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NDEFT2T_MIME_RECORD_OVERHEAD</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">shortRecord, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">typeLength&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;(2 + ((shortRecord) ? 1 : 4) + (typeLength))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculates the overhead in bytes required for a MIME record header. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shortRecord</td><td>: Set this to <code>true</code> if the payload size is known to be &lt;= 255 bytes. Use <code>false</code> if it is bigger, unknown or to get the largest overhead in bytes. </td></tr>
    <tr><td class="paramname">typeLength</td><td>: This is the length of the type string <b>without</b> the <code>NULL</code> character as given in <a class="el" href="a00479.html#a4f9622821cb20009b23b18c58d72ec4e">NDEFT2T_CREATE_RECORD_INFO_T.pString</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga17f5b5be81f1b45fbcde60834f4a48a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga17f5b5be81f1b45fbcde60834f4a48a4">&#9670;&nbsp;</a></span>NDEFT2T_EXT_RECORD_OVERHEAD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NDEFT2T_EXT_RECORD_OVERHEAD</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">shortRecord, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">typeLength&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;(2 + ((shortRecord) ? 1 : 4) + (typeLength))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculates the overhead in bytes required for a NFC Forum external record header. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shortRecord</td><td>: Set this to <code>true</code> if the payload size is known to be &lt;= 255 bytes. Use <code>false</code> if it is bigger, unknown or to get the largest overhead in bytes. </td></tr>
    <tr><td class="paramname">typeLength</td><td>: This is the length of the payload type string <b>without</b> the <code>NULL</code> character as given in <a class="el" href="a00479.html#a4f9622821cb20009b23b18c58d72ec4e">NDEFT2T_CREATE_RECORD_INFO_T.pString</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9ea61e40b2eb1dbe7ec8a0b17a59e9e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9ea61e40b2eb1dbe7ec8a0b17a59e9e0">&#9670;&nbsp;</a></span>NDEFT2T_URI_RECORD_OVERHEAD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NDEFT2T_URI_RECORD_OVERHEAD</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">shortRecord</td><td>)</td>
          <td>&#160;&#160;&#160;(4 + ((shortRecord) ? 1 : 4))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculates the overhead in bytes required for a URI record header. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shortRecord</td><td>: Set this to <code>true</code> if the payload size is known to be &lt;= 255 bytes. Use <code>false</code> if it is bigger, unknown or to get the largest overhead in bytes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad96246ce81e82ea3e9b9662025424898"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad96246ce81e82ea3e9b9662025424898">&#9670;&nbsp;</a></span>NDEFT2T_MSG_OVERHEAD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NDEFT2T_MSG_OVERHEAD</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">shortMessage, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">totalRecordOverhead&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;(8 + 2 + ((shortMessage) ? 1 : 3) + (totalRecordOverhead))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculates the total overhead in bytes required to create an NDEF message. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shortMessage</td><td>: Set this to <code>true</code> if the total message payload size (sum of all the individual record payloads and record overheads) is known to be &lt;= 254 bytes. Use <code>false</code> if it is bigger, unknown or to get the largest overhead in bytes. </td></tr>
    <tr><td class="paramname">totalRecordOverhead</td><td>: This is the total record overhead (sum of all the individual record overheads). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The limit &lt;= 254 message payload size is as per the standard and is different from the limit used for record payload. </dd></dl>

</div>
</div>
<a id="ga7534ae047d7e38cb6d59d848753df6eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7534ae047d7e38cb6d59d848753df6eb">&#9670;&nbsp;</a></span>NDEFT2T_EnableAutomaticMode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NDEFT2T_EnableAutomaticMode</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="a00479.html#ga64408e83c05d65094bcf54a6d7977c1c">NDEFT2T_EnableMessageReadDetection</a>(0)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd>Its use is discouraged. Present only for backward compatibility. Will be removed in a later SDK. </dd></dl>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="gac8dadf40ffa8266581eadcf6b79d15c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac8dadf40ffa8266581eadcf6b79d15c8">&#9670;&nbsp;</a></span>pNdeft2t_FieldStatus_Cb_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* pNdeft2t_FieldStatus_Cb_t) (bool isPresent)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Callback function type to chain interrupt status from ISR to application. Refer <a class="el" href="a00479.html#nfcIntHandling_anchor">NFC Interrupt Handling</a> for more details. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">isPresent</td><td>: NFC interrupt status obtained inside NDEFT2T MOD. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga21b67e5fba50153110a7862a5a40fd63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga21b67e5fba50153110a7862a5a40fd63">&#9670;&nbsp;</a></span>pNdeft2t_MsgAvailable_Cb_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* pNdeft2t_MsgAvailable_Cb_t) (void)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Callback function type to get indicated on the presence of a valid NDEF message in shared memory. This will occur once per message. Refer <a class="el" href="a00479.html#nfcIntHandling_anchor">NFC Interrupt Handling</a> for more details. </p>

</div>
</div>
<a id="gaba34e811f8444fb2c0b9c98d33fc49bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaba34e811f8444fb2c0b9c98d33fc49bc">&#9670;&nbsp;</a></span>pNdeft2t_MsgRead_Cb_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* pNdeft2t_MsgRead_Cb_t) (void)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Callback function type to get notified when the NFC tag reader has finished reading the NDEF message written by the firmware in the NFC shared memory. </p><dl class="section note"><dt>Note</dt><dd>Called under interrupt. </dd></dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="gaa2778808e2b7b2a4ee758d5db7961e6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa2778808e2b7b2a4ee758d5db7961e6e">&#9670;&nbsp;</a></span>NDEFT2T_RECORD_TYPE_T</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="a00479.html#gaa2778808e2b7b2a4ee758d5db7961e6e">NDEFT2T_RECORD_TYPE_T</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Supported record Types. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggaa2778808e2b7b2a4ee758d5db7961e6ea8260df5470501730ab098e47d3318b49"></a>NDEFT2T_RECORD_TYPE_EMPTY&#160;</td><td class="fielddoc"><p>Empty Record. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa2778808e2b7b2a4ee758d5db7961e6ea7d7e1d9167846567b6eb9855f2835a6a"></a>NDEFT2T_RECORD_TYPE_UNKNOWN&#160;</td><td class="fielddoc"><p>Unknown. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa2778808e2b7b2a4ee758d5db7961e6ea30c4a2e6a35317735ec980065801c721"></a>NDEFT2T_RECORD_TYPE_UNCHANGED&#160;</td><td class="fielddoc"><p>Unchanged. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa2778808e2b7b2a4ee758d5db7961e6eae9ce224e3055c3a0d7a4028279a63a6d"></a>NDEFT2T_RECORD_TYPE_TEXT&#160;</td><td class="fielddoc"><p>TEXT Record. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa2778808e2b7b2a4ee758d5db7961e6ea036a802d92ce61407de238b0927f441e"></a>NDEFT2T_RECORD_TYPE_MIME&#160;</td><td class="fielddoc"><p>MIME Record. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa2778808e2b7b2a4ee758d5db7961e6eaa2cf6dc0230a71b8fc6603393a8c1757"></a>NDEFT2T_RECORD_TYPE_EXT&#160;</td><td class="fielddoc"><p>NFC Forum external type Record. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa2778808e2b7b2a4ee758d5db7961e6ea1fb957508be72144eff763574b2303b8"></a>NDEFT2T_RECORD_TYPE_URI&#160;</td><td class="fielddoc"><p>URI Record. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa2778808e2b7b2a4ee758d5db7961e6ea83ee408eec31c33ff9ad79af30b6c8b4"></a>NDEFT2T_RECORD_TYPE_PHDC&#160;</td><td class="fielddoc"><p>PHDC Record. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa2778808e2b7b2a4ee758d5db7961e6eaa39592d7ee50950260478914a39f409c"></a>NDEFT2T_RECORD_TYPE_RESERVED&#160;</td><td class="fielddoc"><p>Reserved. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gacbdbeead1744aa3447376a6f240edc58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacbdbeead1744aa3447376a6f240edc58">&#9670;&nbsp;</a></span>NDEFT2T_Init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NDEFT2T_Init </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function initializes the NDEFT2T module. </p><dl class="section pre"><dt>Precondition</dt><dd>The NFC HW block has been initialized by calling <a class="el" href="a00457.html#ga97c0696317d3a042bf0fdc3600343d07">Chip_NFC_Init</a> </dd></dl>

</div>
</div>
<a id="ga8433bf6f14a70748c7ab65f1907610bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8433bf6f14a70748c7ab65f1907610bd">&#9670;&nbsp;</a></span>NDEFT2T_DeInit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NDEFT2T_DeInit </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function De-initializes the NDEFT2T module. </p><dl class="section post"><dt>Postcondition</dt><dd>De-initialize the NFC HW block by calling <a class="el" href="a00457.html#ga94a6be0b879c3d4a399c0b92d0bc2117">Chip_NFC_DeInit</a> </dd></dl>

</div>
</div>
<a id="gab16f4f04bd89c492ed8b58a2ce98c252"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab16f4f04bd89c492ed8b58a2ce98c252">&#9670;&nbsp;</a></span>NDEFT2T_ResetNfcMemory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NDEFT2T_ResetNfcMemory </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>(Re-)initialize the NFC shared memory. This allows a phone to recognize the IC as an NDEF object, not just as an NdefFormatable, even if contents are not changed afterwards. It also blocks both the tag reader from reading what data may be present thereafter. And the ARM also can no longer access the data when using this module's API (<a class="el" href="a00479.html#ga86e2733b30f43d68effad331fcb993c1">NDEFT2T_GetMessage</a>). </p>

</div>
</div>
<a id="ga64408e83c05d65094bcf54a6d7977c1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga64408e83c05d65094bcf54a6d7977c1c">&#9670;&nbsp;</a></span>NDEFT2T_EnableMessageReadDetection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NDEFT2T_EnableMessageReadDetection </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>lastPageOfMessage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enables detection of when a message is fully read by a tag reader. It will monitor detection of the first page where the user NDEF message can be written to, and the last page of the NDEF message. <a class="el" href="a00480.html#gab05af3735922d9b027d4c9ae7bed6ac8">NDEFT2T_MSG_READ_CB</a> is called each time the tag reader has read the complete NDEF message. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lastPageOfMessage</td><td>The page number where the last payload can be found. Use this when a message has been pre-populated in the NFC memory (after calling <a class="el" href="a00479.html#gacbdbeead1744aa3447376a6f240edc58">NDEFT2T_Init</a> since this will also re-initialize the NFC memory contents). When <code>0</code> is provided, the read detection will only start once a new NDEF message is committed by calling <a class="el" href="a00479.html#gaa1166ef185ee22d55489cf1927adb566">NDEFT2T_CommitMessage</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This can be used by the application to enter an 'automatic mode' until the NFC tag reader writes any page. The application can send out subsequent messages without waiting for an explicit command, increasing throughput. As long as the tag reader does not write, the tag is in control and decides which information to provide. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>When this call ends, all <em>new</em> messages committed will be monitored for reading by the tag reader. The last page of the message is calculated and the detection mechanism will be reconfigured during the call to <a class="el" href="a00479.html#gaa1166ef185ee22d55489cf1927adb566">NDEFT2T_CommitMessage</a> </dd>
<dd>
Once entered, the mode is left:<ul>
<li>when the tag reader writes in the NFC shared memory - generating the <a class="el" href="a00457.html#ggadc1c0828fcebab2311e7c89040b2dc19a449ed3ad2dcb16b03978076c5a0f10b2">NFC_INT_MEMWRITE</a> interrupt</li>
<li>when <a class="el" href="a00479.html#gacbdbeead1744aa3447376a6f240edc58">NDEFT2T_Init</a> is called</li>
<li>when <a class="el" href="a00479.html#gaace6dbc7404f6ab555e816b51d720f79">NDEFT2T_DisableMessageReadDetection</a> is called</li>
</ul>
</dd></dl>

</div>
</div>
<a id="gaace6dbc7404f6ab555e816b51d720f79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaace6dbc7404f6ab555e816b51d720f79">&#9670;&nbsp;</a></span>NDEFT2T_DisableMessageReadDetection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NDEFT2T_DisableMessageReadDetection </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Disables detection of when a message is fully read by a tag reader. </p>

</div>
</div>
<a id="ga70cfb3eb9393ab20bc3aa564171d89ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga70cfb3eb9393ab20bc3aa564171d89ff">&#9670;&nbsp;</a></span>NDEFT2T_CreateMessage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NDEFT2T_CreateMessage </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pInstance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bufLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>shortMessage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function starts the process of creating an NDEF message and prepares for addition of one or more records into the message. A call to this function makes a new instantiation of the NDEFT2T module for message creation. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pInstance</td><td>: Base address of instance Buffer. The instance buffer preserves the necessary housekeeping information during an instantiation of the NDEFT2T module. The caller must ensure that the argument pInstance points to a buffer of size <a class="el" href="a00479.html#ga22c7567e5e4cc7862e9e7e4b27d91e18">NDEFT2T_INSTANCE_SIZE</a> bytes. </td></tr>
    <tr><td class="paramname">pBuffer</td><td>: Base address of message buffer used for creation of the message. The NDEF message is initially created in this buffer and the completed message is finally copied to the shared memory at the end of message creation by calling <a class="el" href="a00479.html#gaa1166ef185ee22d55489cf1927adb566">NDEFT2T_CommitMessage()</a>. The caller must allocate sufficient memory for this buffer. Refer section on "Memory Requirements" for more details. </td></tr>
    <tr><td class="paramname">bufLen</td><td>: Length of the message buffer as explained above. </td></tr>
    <tr><td class="paramname">shortMessage</td><td>: Set this to <code>true</code> if the length of the message payload is &lt;= 254 bytes or not known, else set to <code>false</code>. See also <a class="el" href="a00480.html#ga08ec0ce2878a8549fdbdd3d3a2266c13">NDEFT2T_MESSAGE_HEADER_LENGTH_CORRECTION</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga383ef299e95ca2a474cef1856fe0a0a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga383ef299e95ca2a474cef1856fe0a0a1">&#9670;&nbsp;</a></span>NDEFT2T_CreateTextRecord()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool NDEFT2T_CreateTextRecord </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pInstance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00479.html#a00746">NDEFT2T_CREATE_RECORD_INFO_T</a> *&#160;</td>
          <td class="paramname"><em>pRecordInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function creates a TEXT type record. The function will reserve space for the record header, fill known values to the record header and initialize related instance variables. The function has to be called after calling <a class="el" href="a00479.html#ga70cfb3eb9393ab20bc3aa564171d89ff">NDEFT2T_CreateMessage()</a>. Call to this function has to be followed by copying the actual payload to the message buffer and then by finalizing the record header. Copying of payload to the message buffer has to be done by calling <a class="el" href="a00479.html#ga23418d555943119a964b80b5c8e410d2">NDEFT2T_WriteRecordPayload()</a> and finalizing of the header by calling <a class="el" href="a00479.html#ga2a13584ed6943a9b21b2bc807e074fd8">NDEFT2T_CommitRecord()</a> . </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pInstance</td><td>: Base address of instance Buffer </td></tr>
    <tr><td class="paramname">pRecordInfo</td><td>: Base address of the record type information data structure instantiated in application. The caller has to initialize the <a class="el" href="a00479.html#a00746">NDEFT2T_CREATE_RECORD_INFO_T</a> structure field pString with locale and set or clear shortRecord based on the need to use short records. Refer to <a class="el" href="a00479.html#a00746">NDEFT2T_CREATE_RECORD_INFO_T</a> data structure for more details. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true/false for success/failure of operation respectively. The function returns false under the below scenarios.<ol type="1">
<li>Size of the NDEF message being created exceeds the size of message buffer allocated by caller</li>
<li>Size of the NDEF message being created exceeds the size of the shared memory</li>
</ol>
</dd></dl>

</div>
</div>
<a id="ga3f8846fb81d6f363236479d43a9eae55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3f8846fb81d6f363236479d43a9eae55">&#9670;&nbsp;</a></span>NDEFT2T_CreateExtRecord()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool NDEFT2T_CreateExtRecord </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pInstance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00479.html#a00746">NDEFT2T_CREATE_RECORD_INFO_T</a> *&#160;</td>
          <td class="paramname"><em>pRecordInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function creates an NFC Forum external type record. The function will reserve space for the record header, fill known values to the record header and initialize related instance variables. The function has to be called after calling <a class="el" href="a00479.html#ga70cfb3eb9393ab20bc3aa564171d89ff">NDEFT2T_CreateMessage()</a>. Call to this function has to be followed by copying the actual payload to the message buffer and then by finalizing the record header. Copying of payload to the message buffer has to be done by calling <a class="el" href="a00479.html#ga23418d555943119a964b80b5c8e410d2">NDEFT2T_WriteRecordPayload()</a> and finalizing of the header by calling <a class="el" href="a00479.html#ga2a13584ed6943a9b21b2bc807e074fd8">NDEFT2T_CommitRecord()</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pInstance</td><td>: Base address of instance Buffer </td></tr>
    <tr><td class="paramname">pRecordInfo</td><td>: Base address of the record type information data structure instantiated in application. The caller has to initialize the <a class="el" href="a00479.html#a00746">NDEFT2T_CREATE_RECORD_INFO_T</a> structure field pString with "android.com:pkg" and set or clear shortRecord based on the need to use short records. Refer to <a class="el" href="a00479.html#a00746">NDEFT2T_CREATE_RECORD_INFO_T</a> data structure for more details. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true/false for success/failure of operation respectively. The function returns false under the below scenarios.<ol type="1">
<li>Size of the NDEF message being created exceeds the size of message buffer allocated by caller</li>
<li>Size of the NDEF message being created exceeds the size of the shared memory</li>
</ol>
</dd></dl>

</div>
</div>
<a id="gaa212d62dc1721f3ec4fb001b842bd61b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa212d62dc1721f3ec4fb001b842bd61b">&#9670;&nbsp;</a></span>NDEFT2T_CreateMimeRecord()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool NDEFT2T_CreateMimeRecord </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pInstance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00479.html#a00746">NDEFT2T_CREATE_RECORD_INFO_T</a> *&#160;</td>
          <td class="paramname"><em>pRecordInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function creates a MIME type record. The function will reserve space for the record header, fill known values to the record header and initialize related instance variables. The function has to be called after calling <a class="el" href="a00479.html#ga70cfb3eb9393ab20bc3aa564171d89ff">NDEFT2T_CreateMessage()</a>. Call to this function has to be followed by copying the actual payload to the message buffer and then by finalizing the record header. Copying of payload to the message buffer has to be done by calling <a class="el" href="a00479.html#ga23418d555943119a964b80b5c8e410d2">NDEFT2T_WriteRecordPayload()</a> and finalizing of the header by calling <a class="el" href="a00479.html#ga2a13584ed6943a9b21b2bc807e074fd8">NDEFT2T_CommitRecord()</a> . </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pInstance</td><td>: Base address of instance Buffer </td></tr>
    <tr><td class="paramname">pRecordInfo</td><td>: Base address of the record type information data structure instantiated in application. The caller has to initialize the <a class="el" href="a00479.html#a00746">NDEFT2T_CREATE_RECORD_INFO_T</a> structure field pString with MIME payload type and set or clear the field shortRecord based on the need to use short records. Refer to <a class="el" href="a00479.html#a00746">NDEFT2T_CREATE_RECORD_INFO_T</a> data structure for more details. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true/false for success/failure of operation respectively. The function returns false under the below scenarios.<ol type="1">
<li>Size of the NDEF message being created exceeds the size of message buffer allocated by caller</li>
<li>Size of the NDEF message being created exceeds the size of the shared memory</li>
</ol>
</dd></dl>

</div>
</div>
<a id="ga65be886d4b4967d5e552c31b408b9daa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga65be886d4b4967d5e552c31b408b9daa">&#9670;&nbsp;</a></span>NDEFT2T_CreateUriRecord()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool NDEFT2T_CreateUriRecord </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pInstance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00479.html#a00746">NDEFT2T_CREATE_RECORD_INFO_T</a> *&#160;</td>
          <td class="paramname"><em>pRecordInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function creates a URI type record. The function will reserve space for the record header, fill known values to the record header and initialize related instance variables. The function has to be called after calling <a class="el" href="a00479.html#ga70cfb3eb9393ab20bc3aa564171d89ff">NDEFT2T_CreateMessage()</a>. Call to this function has to be followed by copying the actual payload to the message buffer and then by finalizing the record header. Copying of payload to the message buffer has to be done by calling <a class="el" href="a00479.html#ga23418d555943119a964b80b5c8e410d2">NDEFT2T_WriteRecordPayload()</a> and finalizing of the header by calling <a class="el" href="a00479.html#ga2a13584ed6943a9b21b2bc807e074fd8">NDEFT2T_CommitRecord()</a> . </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pInstance</td><td>: Base address of instance Buffer </td></tr>
    <tr><td class="paramname">pRecordInfo</td><td>: Base address of the record type information data structure instantiated in application. The caller has to initialize the <a class="el" href="a00479.html#a00746">NDEFT2T_CREATE_RECORD_INFO_T</a> structure field uriCode and set or clear shortRecord based on the need to use short records. The pString field is not applicable for URI record. Refer to <a class="el" href="a00479.html#a00746">NDEFT2T_CREATE_RECORD_INFO_T</a> data structure for more details. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true/false for success/failure of operation respectively. The function returns false under the below scenarios.<ol type="1">
<li>Size of the NDEF message being created exceeds the size of message buffer allocated by caller</li>
<li>Size of the NDEF message being created exceeds the size of the shared memory</li>
<li>The <a class="el" href="a00479.html#a00746">NDEFT2T_CREATE_RECORD_INFO_T</a> data structure field uriCode is not valid</li>
</ol>
</dd></dl>

</div>
</div>
<a id="ga23418d555943119a964b80b5c8e410d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga23418d555943119a964b80b5c8e410d2">&#9670;&nbsp;</a></span>NDEFT2T_WriteRecordPayload()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool NDEFT2T_WriteRecordPayload </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pInstance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>pData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function appends data to the payload of the record that was previously created. The application can copy the entire data at once, if the same is available immediately. If the entire data is not available immediately, then the same can be copied in parts by calling this function multiple times. The function will keep track of the total size of the payload that gets copied in this manner in its instance variables. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pInstance</td><td>: Base address of instance Buffer </td></tr>
    <tr><td class="paramname">pData</td><td>: Base address of the record payload. </td></tr>
    <tr><td class="paramname">size</td><td>: Length in bytes of the record payload. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true/false for success/failure of operation respectively. The function returns false under the below scenarios.<ol type="1">
<li>Size of the NDEF message being created exceeds the size of message buffer allocated by caller</li>
<li>Size of the NDEF message being created exceeds the size of the shared memory</li>
<li>The <a class="el" href="a00479.html#a00746">NDEFT2T_CREATE_RECORD_INFO_T</a> data structure field shortRecord is set and payload data size exceeds 255 bytes.</li>
</ol>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>When <a class="el" href="a00480.html#ga85fc051e0a520f4c11465a377f67e341">NDEFT2T_EEPROM_COPY_SUPPPORT</a> is set to '1', pData can be located in EEPROM read/write region. In that case, <b>address</b> must be given, <b>not</b> the offset. For example, provide <a class="el" href="a00433.html#ga19220ff77b3f420a71eddcfcb2534a52">EEPROM_START</a> to copy the data from the start of the EEPROM memory. The function will then internally take care of the copying from EEPROM to the message buffer. However, the EEPROM must already be initialized before calling this function. This is <b>not</b> checked for, and will result in a hang if this precondition is not met. </dd></dl>

</div>
</div>
<a id="ga2a13584ed6943a9b21b2bc807e074fd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2a13584ed6943a9b21b2bc807e074fd8">&#9670;&nbsp;</a></span>NDEFT2T_CommitRecord()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NDEFT2T_CommitRecord </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pInstance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function finalizes the record header and has to be called after the caller has copied the payload. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pInstance</td><td>: Base address of instance Buffer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa1166ef185ee22d55489cf1927adb566"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa1166ef185ee22d55489cf1927adb566">&#9670;&nbsp;</a></span>NDEFT2T_CommitMessage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool NDEFT2T_CommitMessage </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pInstance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function finalizes the NDEF message header. The function has to be called at the end of an NDEF message creation after creating all records. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pInstance</td><td>: Base address of instance Buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> </dd></dl>

</div>
</div>
<a id="ga86e2733b30f43d68effad331fcb993c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga86e2733b30f43d68effad331fcb993c1">&#9670;&nbsp;</a></span>NDEFT2T_GetMessage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool NDEFT2T_GetMessage </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pInstance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bufLen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function starts the process of parsing an NDEF message present in shared memory. A call to this function makes a new instantiation of the NDEFT2T module for message parsing. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pInstance</td><td>: Base address of instance Buffer. The instance buffer preserves the necessary housekeeping information during an instantiation of the NDEFT2T module. The caller must ensure that the argument pInstance points to a buffer of size <a class="el" href="a00479.html#ga22c7567e5e4cc7862e9e7e4b27d91e18">NDEFT2T_INSTANCE_SIZE</a> bytes. </td></tr>
    <tr><td class="paramname">pBuffer</td><td>: Base address of message buffer used for parsing of the message. NDEF message is first copied into this buffer from the shared memory. Further parsing of constituent records is then done on this buffer. This function also validates the message for correctness of header fields. The caller must allocate sufficient memory for this buffer. Refer section on "Memory Requirements" for more details. </td></tr>
    <tr><td class="paramname">bufLen</td><td>: Length of the message buffer as explained above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true/false for success/failure of operation respectively. The function returns false under the below scenarios.<ol type="1">
<li>Size of the NDEF message being parsed exceeds the size of message buffer allocated by caller or the size of the NFC shared memory (<a class="el" href="a00457.html#gac7d03f279b83abdbaef3a81ea3b0e30d">NFC_SHARED_MEM_BYTE_SIZE</a>).</li>
<li>Shared memory contains non-NDEF formatted data or an invalid record header field.</li>
<li>Unsupported record types or payload types</li>
</ol>
</dd></dl>

</div>
</div>
<a id="ga6a3a42026d8354639b9de950f8dd6138"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6a3a42026d8354639b9de950f8dd6138">&#9670;&nbsp;</a></span>NDEFT2T_GetNextRecord()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool NDEFT2T_GetNextRecord </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pInstance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00479.html#a00750">NDEFT2T_PARSE_RECORD_INFO_T</a> *&#160;</td>
          <td class="paramname"><em>pRecordInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function parses the NDEF message and retrieves the type and all related information of the next record present in the message. The function has to be called after calling the <a class="el" href="a00479.html#ga86e2733b30f43d68effad331fcb993c1">NDEFT2T_GetMessage()</a> function. Each call to this function will advance the internal message buffer pointer to the start of the next record after the one that got parsed. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">pInstance</td><td>: Base address of instance Buffer </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pRecordInfo</td><td>: Base address of the record type information data structure. The function will populate the applicable fields of this data structure after parsing the next NDEF record present in the message. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true/false for success/failure of operation respectively. The function returns false under the below scenarios.<ul>
<li>End of message reached</li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga5e32405e5c62a6e42cac4ce8d8df188c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5e32405e5c62a6e42cac4ce8d8df188c">&#9670;&nbsp;</a></span>NDEFT2T_GetRecordPayload()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* NDEFT2T_GetRecordPayload </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pInstance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pLen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function provides the address of the message buffer location from where the record payload can be retrieved and the length of the payload data as well. The function has to be called after calling the <a class="el" href="a00479.html#ga6a3a42026d8354639b9de950f8dd6138">NDEFT2T_GetNextRecord()</a> function during message parsing. The function can also be used during creation of NDEF message in case the application needs to preserve the buffer location of a particular record payload. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">pInstance</td><td>: Base address of instance Buffer </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pLen</td><td>: Length of the record payload can be retrieved via this output parameter. A payload length of <code>0</code> means that either the current record being parsed is an empty record or that this function was called before calling <a class="el" href="a00479.html#ga6a3a42026d8354639b9de950f8dd6138">NDEFT2T_GetNextRecord()</a> function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Address in message buffer where the record payload starts. A value of NULL being returned indicates that either the current record being parsed is an empty record or that this function was called before calling <a class="el" href="a00479.html#ga6a3a42026d8354639b9de950f8dd6138">NDEFT2T_GetNextRecord()</a> function. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Tue Oct 20 2020 08:24:35 for NHS31xx SW API by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.14 </li>
  </ul>
</div>
</body>
</html>
