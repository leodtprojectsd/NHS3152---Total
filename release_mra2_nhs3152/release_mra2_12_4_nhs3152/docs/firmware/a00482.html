<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NHS31xx SW API: storage: NVM Storage module</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="nxp-logo_small.jpg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NHS31xx SW API
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('a00482.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">storage: NVM Storage module<div class="ingroups"><a class="el" href="a00425.html">Modules</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>The storage module allows an application to store samples <b> all of identical size</b> in non-volatile memories EEPROM and FLASH.</p>
<p>It will:</p><ul>
<li>abstract away where and how the samples are stored</li>
<li>provide an easy interface via which samples can be written to and read from</li>
<li>utilize all bits, placing all samples back to back, maximizing storage capacity</li>
<li>minimize FLASH program operations, thereby avoiding the time penalty, voltage drop and current consumption that comes with every FLASH program operation</li>
<li>move data from EEPROM to FLASH automatically whenever necessary to make sure the newest data is always in EEPROM</li>
<li>allow application-specific compression of the data just before moving data from EEPROM to FLASH</li>
<li>allow application-specific decompression of the data before they are read out again</li>
<li>recover its full state based on the contents of the non-volatile memory alone</li>
</ul>
<p>The storage module will use general purpose registers, EEPROM and FLASH to store bits of data. The usage of the three types of memories is prioritized. When a new sample is to be stored:</p><ul>
<li>first an attempt is made to store it in the general purpose registers ("cached").</li>
<li>when this is not possible, the storage module tries to store it (together with all the cached samples) in EEPROM <br />
 After moving data to EEPROM, the general purpose registers are re-used.</li>
<li>only when a sufficient amount of samples are stored in EEPROM, all the data is moved to FLASH. <br />
 After moving data to FLASH, the EEPROM is re-used.</li>
</ul>
<p>Writing samples always means appending them to the already written samples; it is not possible to edit the already written stream of bits. When reading out, the user can control the starting read position using a sequence number. It is automatically deduced where the corresponding sample is written, whether it is compressed, and what needs to be done to be able to return the requested sample(s).</p>
<dl class="section user"><dt>Hardening</dt><dd>The storage module provides a ready-made solution to maximize storage of samples in persistent memory. It can:<ul>
<li>store more than 10.000 samples without hitting the write endurance limit of both EEPROM and FLASH</li>
<li>recover state from unexpected resets</li>
<li>recover all or most of the samples in case of data corruption (this may occur when the battery is degraded and can no longer supply the minimum voltage when the load increases during a write operation in EEPROM or FLASH)</li>
</ul>
It is not possible to fully recover data under all circumstances. The storage module guarantees that only the last few samples may get lost. The number is dependent on the number of the reserved general purpose registers and the size of a sample, both of which (and more) can be tweaked using diversity settings.</dd></dl>
<dl class="section user"><dt>Diversity</dt><dd>This module supports diversity settings. Some settings define the type and size of the sample. Others define the EEPROM and FLASH regions placed under control of this module. The rest of the settings control the behavior of the module. Check <a class="el" href="a00483.html">Diversity Settings</a> for all diversity settings. <br />
 It is expected that each application that requires this module includes it and configures the diversity settings of the module according to its specific needs.</dd></dl>
<dl class="section user"><dt>Memory Requirements</dt><dd>The storage module requires a large chunk of SRAM, called its workarea - see <a class="el" href="a00483.html#gade36aef439049262b4a755353542de43">STORAGE_WORKAREA</a> and <a class="el" href="a00483.html#ga4b69ffeada7d6e645ed70b84786850f9">STORAGE_WORKAREA_SIZE</a>. This is used for two purposes:<ul>
<li>When storing samples, and a move from EEPROM to FLASH is required, the assigned compress callback - see <a class="el" href="a00483.html#gad2c3a42a97cb31f6030cc561ca974eab">STORAGE_COMPRESS_CB</a> - is given a pointer inside this SRAM memory. The output is then stored in FLASH.</li>
<li>When reading samples from FLASH, the assigned decompress callback - see <a class="el" href="a00483.html#ga4bbfc00976edf761a51223936e7360fb">STORAGE_DECOMPRESS_CB</a> - is called as little as possible: its output is cached in the work area to speed up subsequent reads.</li>
</ul>
If two operations in your code require such a big chunk of memory, you can overlap them if they don't have to operate concurrently. Diversity setting <a class="el" href="a00483.html#gade36aef439049262b4a755353542de43">STORAGE_WORKAREA</a> can be used for this.</dd></dl>
<dl class="section user"><dt>How to use the module</dt><dd><ol type="1">
<li>Define the best diversity settings for your application or accept the default ones.</li>
<li>Initialize the EEPROM driver and the storage module, in that order.</li>
<li>Read and write samples as necessary, in any order or quantity that is required for your use case.</li>
<li>De-initialize the storage module and the EEPROM driver, in that order.</li>
</ol>
</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">    <span class="keywordtype">int</span> n;</div><div class="line">    uint8_t one = 1;</div><div class="line">    uint8_t ten[10] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};</div><div class="line"></div><div class="line">    <a class="code" href="a00450.html#ga65e67bfd12e5b091f3eb1978d16eeae1">Chip_EEPROM_Init</a>(<a class="code" href="a00433.html#gab335e5163c07337ca40cd7f1cd5aa3c0">NSS_EEPROM</a>);</div><div class="line">    <a class="code" href="a00482.html#gad04fe4fa8e78ef5572e4a39dec188c31">Storage_Init</a>();</div><div class="line">    <a class="code" href="a00482.html#ga345ce91da83ce1cea789068dfb587ed5">Storage_Reset</a>(<span class="keyword">false</span>);</div><div class="line"></div><div class="line">    <a class="code" href="a00482.html#ga8140766c4b825016f5cb508c9dec2f73">Storage_Write</a>(&amp;one, 1);</div><div class="line">    <a class="code" href="a00482.html#ga82112f49c64c590b321e1e02caf077f5">Storage_Seek</a>(0);</div><div class="line"></div><div class="line">    n = <a class="code" href="a00482.html#ga7ff9042e0e6194a3d9faf026693beda6">Storage_Read</a>(&amp;one, 1); <span class="comment">/* one will remain 1 */</span></div><div class="line">    <a class="code" href="a00433.html#ga28301f76c53b643912da7c538f74e2c6">ASSERT</a>(n == 1);</div><div class="line"></div><div class="line">    <a class="code" href="a00482.html#ga8140766c4b825016f5cb508c9dec2f73">Storage_Write</a>(ten, 10);</div><div class="line">    <span class="comment">/*  Read index:    x</span></div><div class="line"><span class="comment">     * Data stored: 1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9</span></div><div class="line"><span class="comment">     * Write index:                                  x</span></div><div class="line"><span class="comment">     */</span></div><div class="line"></div><div class="line">    <a class="code" href="a00482.html#ga82112f49c64c590b321e1e02caf077f5">Storage_Seek</a>(0);</div><div class="line">    n = <a class="code" href="a00482.html#ga7ff9042e0e6194a3d9faf026693beda6">Storage_Read</a>(ten, 7); <span class="comment">/* ten will become {1, 0, 1, 2, 3, 4, 5, 7, 8, 9} */</span></div><div class="line">    <a class="code" href="a00433.html#ga28301f76c53b643912da7c538f74e2c6">ASSERT</a>(n == 7);</div><div class="line">    <span class="comment">/*  Read index:                      x</span></div><div class="line"><span class="comment">     * Data stored: 1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9</span></div><div class="line"><span class="comment">     * Write index:                                  x</span></div><div class="line"><span class="comment">     */</span></div><div class="line"></div><div class="line">    n = <a class="code" href="a00482.html#ga7ff9042e0e6194a3d9faf026693beda6">Storage_Read</a>(ten, 100); <span class="comment">/* ten will become {6, 7, 8, 9, 3, 4, 5, 7, 8, 9} */</span></div><div class="line">    <a class="code" href="a00433.html#ga28301f76c53b643912da7c538f74e2c6">ASSERT</a>(n == 4);</div><div class="line">    <span class="comment">/*  Read index:                                  x</span></div><div class="line"><span class="comment">     * Data stored: 1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9</span></div><div class="line"><span class="comment">     * Write index:                                  x</span></div><div class="line"><span class="comment">     */</span></div><div class="line"></div><div class="line">    <a class="code" href="a00482.html#ga75abea0be7fefec6285224dc0f82f5ac">Storage_DeInit</a>();</div></div><!-- fragment --> </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>These functions are not re-entrant. Calling these functions from multiple threads or in an interrupt is highly discouraged. </dd>
<dd>
The storage module requires the exclusive use of <em>at</em> <em>least</em> <em>one</em> register in the always-on domain (see <a class="el" href="a00483.html#gaa0b4af28ee1307ce6c560e71d5a6c742">STORAGE_FIRST_ALON_REGISTER</a>). Under no circumstance may the reserved registers be touched from outside the storage module. </dd>
<dd>
Although the storage module is able to recover after a power loss or going to Power-off, it is slow in doing so. The slow recovery time only occurs once as long as no changes to the NVM are made (e.g. by calling <a class="el" href="a00482.html#ga8140766c4b825016f5cb508c9dec2f73">Storage_Write</a>). </dd></dl>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:a00483"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00483.html">Diversity Settings</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gab7c664a0e73ef251f2e68bbd23d6cabb"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00482.html#gab7c664a0e73ef251f2e68bbd23d6cabb">pStorage_CompressCb_t</a>) (int eepromByteOffset, int bitCount, void *pOut)</td></tr>
<tr class="separator:gab7c664a0e73ef251f2e68bbd23d6cabb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb11c3cdbd067dcbbe54bac47ba3c6ff"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00482.html#gafb11c3cdbd067dcbbe54bac47ba3c6ff">pStorage_DecompressCb_t</a>) (const uint8_t *pData, int bitCount, void *pOut)</td></tr>
<tr class="separator:gafb11c3cdbd067dcbbe54bac47ba3c6ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gad04fe4fa8e78ef5572e4a39dec188c31"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00482.html#gad04fe4fa8e78ef5572e4a39dec188c31">Storage_Init</a> (void)</td></tr>
<tr class="separator:gad04fe4fa8e78ef5572e4a39dec188c31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga75abea0be7fefec6285224dc0f82f5ac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00482.html#ga75abea0be7fefec6285224dc0f82f5ac">Storage_DeInit</a> (void)</td></tr>
<tr class="separator:ga75abea0be7fefec6285224dc0f82f5ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga80e837c4eb77a8ff14057e1971e63083"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00482.html#ga80e837c4eb77a8ff14057e1971e63083">Storage_GetCount</a> (void)</td></tr>
<tr class="separator:ga80e837c4eb77a8ff14057e1971e63083"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga345ce91da83ce1cea789068dfb587ed5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00482.html#ga345ce91da83ce1cea789068dfb587ed5">Storage_Reset</a> (bool checkFlash)</td></tr>
<tr class="separator:ga345ce91da83ce1cea789068dfb587ed5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8140766c4b825016f5cb508c9dec2f73"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00482.html#ga8140766c4b825016f5cb508c9dec2f73">Storage_Write</a> (uint8_t *pSamples, int n)</td></tr>
<tr class="separator:ga8140766c4b825016f5cb508c9dec2f73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga82112f49c64c590b321e1e02caf077f5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00482.html#ga82112f49c64c590b321e1e02caf077f5">Storage_Seek</a> (int n)</td></tr>
<tr class="separator:ga82112f49c64c590b321e1e02caf077f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ff9042e0e6194a3d9faf026693beda6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00482.html#ga7ff9042e0e6194a3d9faf026693beda6">Storage_Read</a> (uint8_t *pSamples, int n)</td></tr>
<tr class="separator:ga7ff9042e0e6194a3d9faf026693beda6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="gab7c664a0e73ef251f2e68bbd23d6cabb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab7c664a0e73ef251f2e68bbd23d6cabb">&#9670;&nbsp;</a></span>pStorage_CompressCb_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* pStorage_CompressCb_t) (int eepromByteOffset, int bitCount, void *pOut)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Whenever data is about to be moved from EEPROM to FLASH, the application is notified via a callback of this prototype. It then has a chance to compress the data before it is written to FLASH. The application is in charge of:</p><ul>
<li>reading the data from EEPROM using <code>eepromByteOffset</code> as starting point,</li>
<li>compressing exactly <code>bitCount</code> bits,</li>
<li>storing the end result in <code>out</code> and</li>
<li>returning the size of the data written in <code>pOut</code>, expressed in <b>bits</b>. <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eepromByteOffset</td><td>The absolute offset in bytes to the EEPROM where the first sample is stored. </td></tr>
    <tr><td class="paramname">bitCount</td><td>An exact total of <a class="el" href="a00483.html#ga9023fc3872517d220a8f817eeef29957">STORAGE_BLOCK_SIZE_IN_SAMPLES</a> samples are stored. They are packed together, i.e. without any padding bits. This argument will <b>always</b> equal <code><a class="el" href="a00483.html#ga3528a0fe95f4434f065d3824c488debc">STORAGE_UNCOMPRESSED_BLOCK_SIZE_IN_BITS</a></code>. </td></tr>
    <tr><td class="paramname">pOut</td><td>A pointer to SRAM where the compressed data must be stored in. The buffer has a size of <code><a class="el" href="a00483.html#ga03b6b7c38aff14a94b0d919538734255">STORAGE_UNCOMPRESSED_BLOCK_SIZE_IN_BYTES</a></code> bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The size of the compressed data <b>in</b> <b>bits</b>. When <code>0</code> is returned, or a value bigger than or equal to <code><a class="el" href="a00483.html#ga3528a0fe95f4434f065d3824c488debc">STORAGE_UNCOMPRESSED_BLOCK_SIZE_IN_BITS</a></code>, the uncompressed data will be stored instead, and the corresponding decompression callback of type <a class="el" href="a00482.html#gafb11c3cdbd067dcbbe54bac47ba3c6ff">pStorage_DecompressCb_t</a> will not be called when reading out the data later. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>It is <b>not</b> allowed to call any function of this module during the lifetime of the callback. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00483.html#gad2c3a42a97cb31f6030cc561ca974eab">STORAGE_COMPRESS_CB</a> </dd></dl>
</li>
</ul>

</div>
</div>
<a id="gafb11c3cdbd067dcbbe54bac47ba3c6ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafb11c3cdbd067dcbbe54bac47ba3c6ff">&#9670;&nbsp;</a></span>pStorage_DecompressCb_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* pStorage_DecompressCb_t) (const uint8_t *pData, int bitCount, void *pOut)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Whenever data is read from FLASH, the application is notified via a callback of this prototype. It then has a chance to decompress the data before it is used to fulfill the read request <a class="el" href="a00482.html#ga7ff9042e0e6194a3d9faf026693beda6">Storage_Read</a>. The application is in charge of:</p><ul>
<li>reading the data from FLASH using <code>data</code> as starting point,</li>
<li>decompressing one block of compressed data stored from that point with size <code>bitCount</code>,</li>
<li>storing the end result - <a class="el" href="a00483.html#ga9023fc3872517d220a8f817eeef29957">STORAGE_BLOCK_SIZE_IN_SAMPLES</a> samples - in <code>out</code>. The samples <b>must</b> be written packed together, i.e. without any padding bits. <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pData</td><td>The absolute byte address to FLASH memory where the start of the (compressed) data block is found. </td></tr>
    <tr><td class="paramname">bitCount</td><td>The size in bits of the (compressed) data block. </td></tr>
    <tr><td class="paramname">pOut</td><td>A pointer to SRAM where the compressed data must be stored in. The buffer has a size of <code><a class="el" href="a00483.html#ga03b6b7c38aff14a94b0d919538734255">STORAGE_UNCOMPRESSED_BLOCK_SIZE_IN_BYTES</a></code> bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bits written to in <code>pOut</code>. If <code><a class="el" href="a00483.html#ga3528a0fe95f4434f065d3824c488debc">STORAGE_UNCOMPRESSED_BLOCK_SIZE_IN_BITS</a></code> is returned, the operation is assumed to be successful and the decompressed samples are now available. <code>Any</code> other value indicates a decompression failure: the samples stored in that block can <b>not</b> be retrieved any more, and the call to <a class="el" href="a00482.html#ga7ff9042e0e6194a3d9faf026693beda6">Storage_Read</a> which initiated this callback will fail. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>It is <b>not</b> allowed to call any function of this module during the lifetime of the callback. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00483.html#ga4bbfc00976edf761a51223936e7360fb">STORAGE_DECOMPRESS_CB</a> </dd></dl>
</li>
</ul>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gad04fe4fa8e78ef5572e4a39dec188c31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad04fe4fa8e78ef5572e4a39dec188c31">&#9670;&nbsp;</a></span>Storage_Init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Storage_Init </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function must be the first function to call in this module after going to deep power down or power-off power save mode. Not calling this function will result at best in random data being written and read, and possibly generate hard faults. </p><dl class="section pre"><dt>Precondition</dt><dd>The value written in <a class="el" href="a00483.html#gaa0b4af28ee1307ce6c560e71d5a6c742">STORAGE_FIRST_ALON_REGISTER</a> and beyond is either exactly what was stored after leaving <a class="el" href="a00482.html#ga75abea0be7fefec6285224dc0f82f5ac">Storage_DeInit</a>, or equal to <code>0</code>. </dd>
<dd>
EEPROM is initialized and is ready to be used. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>When this function returns, <a class="el" href="a00482.html#ga82112f49c64c590b321e1e02caf077f5">Storage_Seek</a> still needs to be called before being able to read samples. This is also required when reading from the start of the memory, i.e. when reading the oldest stored sample referred to as index 0. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function can run for a long time before completion when it is forced to scan the assigned EEPROM region to recover the data that is stored in EEPROM and/or FLASH. The time spent is depending on both the assigned EEPROM region and the number of samples stored in EEPROM: the longer the region, the more time spent; the more samples stored in EEPROM, the less time spent recovering. Under worst case conditions using a system clock of 0.5 MHz, this may last more than 10 msec. This penalty only occurs under these combined conditions:<ul>
<li>the IC went to power-off, losing all information stored in the register <a class="el" href="a00483.html#gaa0b4af28ee1307ce6c560e71d5a6c742">STORAGE_FIRST_ALON_REGISTER</a> and beyond.</li>
<li>data was added to the storage module after leaving a previous power-off mode</li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga75abea0be7fefec6285224dc0f82f5ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga75abea0be7fefec6285224dc0f82f5ac">&#9670;&nbsp;</a></span>Storage_DeInit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Storage_DeInit </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function must be the last function to call in this module before going to deep power down or power-off power save mode. </p><dl class="section pre"><dt>Precondition</dt><dd>EEPROM is still initialized and ready to be used. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>Possibly, an EEPROM flush was necessary, but that has finished when this function returns. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Loss of power before or during this call may result in loss of some or all of the newly added samples. </dd></dl>

</div>
</div>
<a id="ga80e837c4eb77a8ff14057e1971e63083"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga80e837c4eb77a8ff14057e1971e63083">&#9670;&nbsp;</a></span>Storage_GetCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Storage_GetCount </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The total number of samples currently stored, in EEPROM and FLASH combined. </dd></dl>

</div>
</div>
<a id="ga345ce91da83ce1cea789068dfb587ed5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga345ce91da83ce1cea789068dfb587ed5">&#9670;&nbsp;</a></span>Storage_Reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Storage_Reset </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>checkFlash</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Resets the storage module to a pristine state. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">checkFlash</td><td>The contents in FLASH must have been erased before it can be written to. An erase operation is costly and time-consuming and is preferably avoided.<ul>
<li>When <code>true</code> is given, <b>all</b> words of the FLASH memory assigned for sample storage are checked. If one checked word does not contain the erased value (<code>0xFFFFFFFF</code>), all FLASH memory is erased. This can possibly take up to 3 erase cycles. Aligning <a class="el" href="a00483.html#gadc56bda551d9bbea8ac33ac75c98ea6a">STORAGE_FLASH_FIRST_PAGE</a> and <a class="el" href="a00483.html#gaa9d5b61492e536833e7ae705d1888f07">STORAGE_FLASH_LAST_PAGE</a> to sector boundaries can reduce this to the minimum of 1 erase cycle.</li>
<li>When <code>false</code> is given, FLASH memory is not checked and not erased.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Provide <code>true</code> as argument for <code>checkFlash</code> when the intention is to store new samples afterwards. </dd></dl>

</div>
</div>
<a id="ga8140766c4b825016f5cb508c9dec2f73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8140766c4b825016f5cb508c9dec2f73">&#9670;&nbsp;</a></span>Storage_Write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Storage_Write </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pSamples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stores <code>n</code> samples. </p><dl class="section pre"><dt>Precondition</dt><dd>EEPROM is initialized </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pSamples</td><td>Pointer to the start of the array where to copy the samples from. For each element of the array, only the <a class="el" href="a00483.html#gad01e6c1296544674eb74616a97afd3fc">STORAGE_BITSIZE</a> LSBits are copied. </td></tr>
    <tr><td class="paramname">n</td><td>The size of the array <code>pSamples</code> points to, in number of <a class="el" href="a00483.html#gacdcc483479cdfdecfdd8908db2ad80ba">STORAGE_TYPE</a> elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of samples written. This value may be <code>0</code> or any number of samples less than or equal to <code>n</code>. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>When a value less than <code>n</code> is returned, at least one of these errors occurred:<ul>
<li>There is insufficient storage capacity</li>
<li>Compressing of samples was necessary during the call, but that operation yielded an error.</li>
</ul>
</dd>
<dd>
A prior call to <a class="el" href="a00482.html#ga82112f49c64c590b321e1e02caf077f5">Storage_Seek</a> is <b>not</b> required, as writing will always <b>append</b> the new samples. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>A later call to <a class="el" href="a00482.html#ga75abea0be7fefec6285224dc0f82f5ac">Storage_DeInit</a> is necessary to ensure the data can survive Deep power down state. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Data is not guaranteed to be stored in EEPROM or FLASH: reset can lose some of the last samples written. </dd></dl>

</div>
</div>
<a id="ga82112f49c64c590b321e1e02caf077f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga82112f49c64c590b321e1e02caf077f5">&#9670;&nbsp;</a></span>Storage_Seek()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Storage_Seek </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determines which sample is read out next in a future call to <a class="el" href="a00482.html#ga7ff9042e0e6194a3d9faf026693beda6">Storage_Read</a>. This call is required to be called once before calling <a class="el" href="a00482.html#ga7ff9042e0e6194a3d9faf026693beda6">Storage_Read</a> one or multiple times. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Must be a positive number. A value of <code>0</code> indicates the oldest sample, which was written first. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> when the sought for sequence number was found; <code>false</code> otherwise. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>the next call to <a class="el" href="a00482.html#ga7ff9042e0e6194a3d9faf026693beda6">Storage_Read</a> will either return at least one sample - the value which was stored as the <code>n-th</code> sample - or fail - when less than <code>n</code> samples are being stored at the time of calling this function. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>After initialization, the default sequence number is <em>not</em> <code>0</code>. First, a call to this function is required before <a class="el" href="a00482.html#ga7ff9042e0e6194a3d9faf026693beda6">Storage_Read</a> can retrieve samples. </dd></dl>

</div>
</div>
<a id="ga7ff9042e0e6194a3d9faf026693beda6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7ff9042e0e6194a3d9faf026693beda6">&#9670;&nbsp;</a></span>Storage_Read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Storage_Read </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pSamples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads <code>n</code> samples from persistent storage, starting from the sequence number set in <a class="el" href="a00482.html#ga82112f49c64c590b321e1e02caf077f5">Storage_Seek</a>. </p><dl class="section pre"><dt>Precondition</dt><dd>EEPROM is initialized </dd>
<dd>
A prior successful call to <a class="el" href="a00482.html#ga82112f49c64c590b321e1e02caf077f5">Storage_Seek</a> is required before this function can succeed. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Multiple reads can be issued after calling <a class="el" href="a00482.html#ga82112f49c64c590b321e1e02caf077f5">Storage_Seek</a> once, each time fetching samples in sequence. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pSamples</td><td>: Pointer to an array of <br />
 elements, where the read samples are copied to. Upon successful completion, each element will contain one sample, where only the <a class="el" href="a00483.html#gad01e6c1296544674eb74616a97afd3fc">STORAGE_BITSIZE</a> LSBits are used per element; the remainder MSBits are set to 0. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">n</td><td>: The size of the array <code>samples</code> points to, in number of <a class="el" href="a00483.html#gacdcc483479cdfdecfdd8908db2ad80ba">STORAGE_TYPE</a> elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of samples read. This value may be <code>0</code> or any number of samples less than <code>n</code>. The remainder of the elements with a higher index may have been written to, but must be ignored. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>When a value less than <code>n</code> is returned, at least one of these errors occurred:<ul>
<li>There was no prior successful call to <a class="el" href="a00482.html#ga82112f49c64c590b321e1e02caf077f5">Storage_Seek</a></li>
<li>Decompressing of samples was necessary during the call, but that operation yielded an error.</li>
<li>There are no more samples stored. </li>
</ul>
</dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Tue Oct 20 2020 08:24:35 for NHS31xx SW API by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.14 </li>
  </ul>
</div>
</body>
</html>
