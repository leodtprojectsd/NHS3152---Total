<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NHS31xx SW API: pmu: Power Management Unit driver</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="nxp-logo_small.jpg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NHS31xx SW API
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('a00458.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">pmu: Power Management Unit driver<div class="ingroups"><a class="el" href="a00427.html">Drivers</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>The Power Management Unit driver (PMU) provides the API to control all the functionalities handled by the PMU HW block. The PMU driver allows controlling the:</p><ol type="1">
<li>Power modes</li>
<li>Power switches</li>
<li>Brown-Out detector</li>
<li>NFC power detector</li>
<li>Wakeup pin functionality</li>
<li>RTC block clock source</li>
</ol>
<p><a class="anchor" id="pmu_powerarch_anchor"></a></p><dl class="section user"><dt>Power Architecture:</dt><dd>The chip has 4 separate major power domains:<ul>
<li>NFC (VNFC)</li>
<li>Always-On (VDD_ALON)</li>
<li>1.2V Internal (VDD1V2)</li>
<li>1.6V Internal (VDD1V6)</li>
</ul>
Power may be supplied via two possible sources:<ul>
<li>External power supply pin (VDDBAT)</li>
<li>Built-in RFID rectifier (part of the VNFC power domain)</li>
</ul>
The VDD_ALON power domain is directly powered by one of these two power sources. The PMU, which is in the VDD_ALON power domain, is responsible for controlling the power for the 1V2 and 1V6 internal power domains.</dd></dl>
<dl class="section user"><dt></dt><dd>Both the VDDBAT pin and the VNFC power sources are connected to the VDD_ALON power domain by means of automatic switches. The switches define which power source is providing power to the VDD_ALON power domain and, consequently, the rest of the chip. The switches are, thus, never closed simultaneously.</dd></dl>
<dl class="section user"><dt></dt><dd>Even when power in the VDDBAT pin is present (when voltage is lower than 1.72V, power is not considered to be present), the respective switch will only be automatically closed when the RESETN pin is deasserted (an edge from low to high is detected) or at the time power is detected at the VNFC power domain (an edge from no power detected to power detected coming from the built-in RFID rectifier). In other words, even when power in the VDDBAT pin is present, the chip is only effectively powered up when one of these two triggers is detected. This switch can be manually set back to its initial open state using the <a class="el" href="a00458.html#ga49d6eeaf641dec113e934dac07146390">Chip_PMU_Switch_OpenVDDBat</a> function.</dd></dl>
<dl class="section user"><dt></dt><dd>When power in the VNFC domain becomes present (when voltage is lower than 1.72V, power is not considered to be present), there are three possible scenarios:<ul>
<li>No power is available in the VDDBAT pin</li>
<li>Power is also available in the VDDBAT pin, but the switch is still open</li>
<li>Power is also available in the VDDBAT pin, but the switch is already closed</li>
</ul>
In the first scenario, the VNFC switch is automatically closed and the chip will be powered via VNFC. <br />
 In the second scenario, the presence of VNFC will trigger the VDDBAT switch to close. In the presence of the two power sources, the automatic switching mechanism will give priority to VDDBAT. <br />
 In the last scenario, as the switch is already closed, the IC is already being powered by the VDDBAT pin. Hence, when VNFC becomes also present, priority will continue to be given to VDDBAT. <br />
 As described above, it is always possible to manually send back the VDDBAT switch to its initial open state using the <a class="el" href="a00458.html#ga49d6eeaf641dec113e934dac07146390">Chip_PMU_Switch_OpenVDDBat</a> function. This can be used to manually trigger a switchover from VDDBAT to VNFC power source. So it is possible to force the IC to be powered by VNFC, however this has to be done each time power in the VNFC domain becomes present.</dd></dl>
<dl class="section user"><dt></dt><dd>Switchover from one source to the other is automatically done in both directions without glitches in the VDD_ALON power domain.</dd></dl>
<dl class="section user"><dt></dt><dd>The VDD_ALON power domain is hard connected to the external bondpad ring (pins), hence, it is possible to provide power to the pins from both VDDBAT or VNFC. Note that in the latter case, the VDDBAT pin will be disconnected from the bondpad ring as it is only meant to be a power source itself.</dd></dl>
<dl class="section user"><dt>Power Modes:</dt><dd><dl>
<dt>Active: </dt>
<dd>This is the default power state after Power-On-Reset. In this state, all internal power domains (1V2 and 1V6) are powered. Thus, the ARM core and memories are clocked by the system clock, and peripherals are clocked (if enabled) by the system clock or a dedicated peripheral clock.  </dd>
<dt>Sleep: </dt>
<dd>The only difference from Active to Sleep is that the clocking of the ARM core is stopped and program execution is suspended until an interrupt reaches the core or a reset condition is detected. All peripherals, if in use, continue operation, the processor state and registers as well as SRAM content are retained and the logic levels of pins remain static. Use the <a class="el" href="a00458.html#gaf9474d0c37f1179ebe0edf523883452c">Chip_PMU_PowerMode_EnterSleep</a> function to enter the Sleep power mode after the wake-up interrupt sources are correctly configured.  </dd>
<dt>Deep Sleep: </dt>
<dd>In this power mode, as in Sleep mode, the clocking of the ARM core is also stopped . Moreover, all analog peripherals and Flash memory are powered down. However, as the SFRO keeps running, it is possible to leave the Watchdog timer or the general-purpose timers running (if required for timer controlled wake-up). The processor state and registers as well as SRAM content are retained and the logic levels of pins remain static. Use <a class="el" href="a00458.html#gacee0d5eace81c8634b66862102478e6d">Chip_PMU_PowerMode_EnterDeepSleep</a> to enter the Deep Sleep power mode after the wake-up interrupt source are correctly configured and all the peripheral clocks, except the ones required, are disabled. <br />
 The chip can exit the Deep Sleep power mode and resume execution on any Start Logic or Watchdog interrupt or restart execution in Active mode on a reset condition.  <a class="anchor" id="pmu_deeppowerdownmode_anchor"></a> </dd>
<dt>Deep power down: </dt>
<dd>In this power mode, all the internal power domains (1V2 and 1V6) are switched off (SFRO is stopped). In other words, everything is powered down except the VDD_ALON power domain (PMU and RTC are still powered). This means that, besides the program execution and peripherals being stopped and the ARM core state being lost, all SRAM and register content is also lost (except registers residing in the PMU and RTC). All digital functional pins are tri-stated except for the WAKEUP (if previously configured), and RESETN pins. Use the <a class="el" href="a00458.html#ga1af1ed037e3824d314f7a01649cf2800">Chip_PMU_PowerMode_EnterDeepPowerDown</a> function to enter the Deep power down power mode after the wake-up sources are correctly configured. <br />
 The chip can exit the Deep power down power mode on a reset condition, WAKEUP pin asserted (active low), RTC wake-up counter expire event or NFC powered event (NVIC or ARM core not involved). After waking up from Deep Power Down mode, the code execution is restarted (never resumed). If the chip exits Deep power down mode due to a reset condition, all the registers from the PMU and RTC are also set to their default value, including RTC counters, PMU general purpose registers and status flags. <br />
 Using the <a class="el" href="a00458.html#gaef096829b6b4445cc6c006589aac0681">Chip_PMU_PowerMode_GetDPDWakeupReason</a> function it is possible to know if the chip woke up from Deep Power Down as well as the reason for the wake up. <br />
 Note that, if there is a debugging session ongoing when you enter Deep power down mode, it will terminate and cannot be started again as long as the IC is in Deep power down mode. <br />
 More important details when combining the wakeup functionality with the use of the Deep power down mode can found below: see <a class="el" href="a00458.html#pmu_deeppowerdownprocedure_anchor">Deep power down procedure</a>. <a class="anchor" id="pmu_poweroffmode_anchor"></a> </dd>
<dt>Off: </dt>
<dd>In this "Off" mode, it is considered that power is present in the VDDBAT pin. In this mode everything in the IC is powered off except the HW logic that detects the triggers that cause the VDDBAT switch to close and consequently power the rest of the IC (see <a class="el" href="a00458.html#pmu_powerarch_anchor">Power Architecture</a>). <br />
 Use the <a class="el" href="a00458.html#ga49d6eeaf641dec113e934dac07146390">Chip_PMU_Switch_OpenVDDBat</a> function to enter the "Off" mode. When the "Off" mode is left (due to RESETN asserted or power present in VNFC), the IC will start-up from scratch (POR). </dd>
</dl>
Regardless of the power mode ("Off" is not included), RTC and PMU register values will be kept and functionality ensured until a full system reset occurs which sets all registers to their default state. A normal exit from Deep Power Down mode does not trigger a full system reset.</dd></dl>
<p><a class="anchor" id="pmu_power_source_switches_par"></a></p><dl class="section user"><dt>Power source switches:</dt><dd>Each power source (VDDBAT pin and VNFC power domain) has a dedicated switch that connects it to the VDD_ALON power domain. These switches behave automatically, and give priority to the VDDBAT pin, as described above. <br />
 The state of the switches can be individually checked using the <a class="el" href="a00458.html#ga7cb74ee59ab87c65c1ba2fbb74c83e79">Chip_PMU_Switch_GetVNFC</a> and the <a class="el" href="a00458.html#gaa6a8b8c55c507ec2bcb4f965a5fe6705">Chip_PMU_Switch_GetVDDBat</a> functions. This automatic switching mechanism can be disabled before entering Deep power down (See <a class="el" href="a00458.html#ga1af1ed037e3824d314f7a01649cf2800">Chip_PMU_PowerMode_EnterDeepPowerDown</a>). This is typically done to keep power consumption to a minimum, however, special care must be taken when entering Deep power down with the power source switches disabled when running from an almost empty battery (VDDBat ~ 1.74V). The consequences are that if the battery drains out (VDDBat &lt; 1.74V) during Deep power down and the automatic switching mechanism is disabled, the IC won't be able to switch to VNFC power and start execution using the energy of an NFC field only. <br />
 The proposed solution is to use the Brown Out detector feature of the IC (See <a class="el" href="a00458.html#pmu_brown_out_detector_par">Brown-Out-Detector</a>) to find out if VDDBat is below 1.8V to decide whether or not it is safe to disable the automatic switching mechanism.</dd></dl>
<p><a class="anchor" id="pmu_brown_out_detector_par"></a></p><dl class="section user"><dt>Brown-Out-Detector:</dt><dd>The PMU provides the possibility to monitor the power source voltage and detect whether it drops to 1.8V or below. This functionality is disabled by default and can be enabled using the <a class="el" href="a00458.html#gadc0b596a1a5a4a2aeaa807f6e1dab349">Chip_PMU_SetBODEnabled</a> function. The detection of a Brown-Out condition is combined with interrupt generation. The current state of the BOD can be checked with the <a class="el" href="a00458.html#gab6b002ff8a4bd48569898396ad305c44">Chip_PMU_GetStatus</a> function and the interrupt generation can be enabled with <a class="el" href="a00458.html#ga9eb3ef6a2c8cf6483a480ba0c5ebdef3">Chip_PMU_Int_SetEnabledMask</a>. If enabled, the BOD functionality will be working during all power modes, although its interrupt can only be used as a wake-up source in Sleep mode. The occurrence of a BO condition can, thus, only be known after wakeup from Sleep, Deep Sleep or Deep power down. <br />
 Note that the <a class="el" href="a00458.html#gab6b002ff8a4bd48569898396ad305c44">Chip_PMU_GetStatus</a> function will not provide the BOD interrupt flag that retains its value after triggered, but only the current status of the BOD (if the brown out condition is not present anymore, the current status will be cleared). To get the BOD interrupt flag, use the <a class="el" href="a00458.html#ga735cdce0bfae730113f91a7c039f8140">Chip_PMU_Int_GetRawStatus</a> function.</dd></dl>
<dl class="section user"><dt>NFC power detector:</dt><dd>The PMU provides the possibility to detect, in SW, the presence of power in the VNFC power domain. This functionality is always enabled and the current status of the power in the VNFC power domain can be checked using <a class="el" href="a00458.html#gab6b002ff8a4bd48569898396ad305c44">Chip_PMU_GetStatus</a>. The respective interrupt generation can be enabled with the <a class="el" href="a00458.html#ga9eb3ef6a2c8cf6483a480ba0c5ebdef3">Chip_PMU_Int_SetEnabledMask</a> function. <br />
 The NFC power detector functionality will be working during all power modes, although its interrupt can only be used as a wake-up source in Sleep mode (via triggering of corresponding interrupt in the NVIC). To wake-up from Deep Sleep with an NFC field, you can use the respective start logic interrupt (see <a class="el" href="a00461.html#startLogic_anchor">System wake-up start logic</a>). <br />
 Note that the <a class="el" href="a00458.html#gab6b002ff8a4bd48569898396ad305c44">Chip_PMU_GetStatus</a> function will not provide the VNFC power interrupt flag that retains its value after triggered, but only the current status of the VNFC power (if the VNFC power is not present anymore, the current status will be cleared). To get the VNFC power interrupt flag, use the <a class="el" href="a00458.html#ga735cdce0bfae730113f91a7c039f8140">Chip_PMU_Int_GetRawStatus</a> function. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>It is not possible to reliably detect whether the power-off mode has been left due to power present in VNFC. As mentioned, you can get the current status using <a class="el" href="a00458.html#gab6b002ff8a4bd48569898396ad305c44">Chip_PMU_GetStatus</a> but this will not tell you whether the VDDBAT pin got connected and the IC started up due to the presence of an NFC field: it is possible that the NFC field triggers VDDBAT pin to be connected but is already gone by the time <a class="el" href="a00458.html#gab6b002ff8a4bd48569898396ad305c44">Chip_PMU_GetStatus</a> is called; or that the field was only present after VDDBAT pin got connected (due to a different reason) but just in time for the <a class="el" href="a00458.html#gab6b002ff8a4bd48569898396ad305c44">Chip_PMU_GetStatus</a> call.</dd></dl>
<dl class="section user"><dt>Wakeup Pin:</dt><dd>The PMU provides the possibility to wakeup from Deep power down mode when a high-to-low transition in the PIO0_0 pin is detected. By default, after a reset, this functionality is disabled, meaning it is not possible to exit the Deep power down mode via the PIO0_0 pin. To enable this functionality, the application must:<ul>
<li>Call <a class="el" href="a00458.html#ga1dbdb908395ac42fec4702149e86c0af">Chip_PMU_SetWakeupPinEnabled</a> with <code>true</code> as argument, and</li>
<li>Configure the PIO0_0 pin for input with the pull-up resistor enabled.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>General Purpose data registers:</dt><dd>The PMU can hold 5 words of data in its own registers which is retained during Deep power down mode. This data will only be lost after a Power-On-Reset or an external reset (RESETN pin asserted). This data region can be accessed using <a class="el" href="a00458.html#gae502a3b16171568e51b23103aa5cbb2b">Chip_PMU_SetRetainedData</a> and <a class="el" href="a00458.html#gadd02ac110402447536dcca375df4cd72">Chip_PMU_GetRetainedData</a>. This data section is available to be used by the application layer as a simple data container to store data that needs to survive a Deep power down.</dd></dl>
<p><a class="anchor" id="pmu_syncwait_warning_anchor"></a></p><dl class="section warning"><dt>Warning</dt><dd>Each PMU block register read and write performs at least one "wait" period that may take up to 100us to complete due to hardware synchronization within the module. <b>All</b> the functions in this driver make at least one such register access. Impact on performance should be carefully considered especially when calling PMU driver functions in ISRs context and high-priority threads. If a PMU block register read/write preempts another PMU block register read/write, the procedure is repeated until no preemption is detected, which leads to additional "wait" period, and thus delays.</dd></dl>
<p><a class="anchor" id="pmu_deeppowerdownprocedure_anchor"></a></p><dl class="section user"><dt>Deep power down procedure:</dt><dd>Entering Deep power down mode requires register changes in both <a class="el" href="a00458.html#a7e05310c08aef36772c83730159154ab">NSS_PMU_T.PCON</a> and ARM's SCB.SCR register. The function <a class="el" href="a00458.html#ga1af1ed037e3824d314f7a01649cf2800">Chip_PMU_PowerMode_EnterDeepPowerDown</a> abstracts away the necessary register changes. <br />
 When the wakeup pin functionality is enabled - using <a class="el" href="a00458.html#ga1dbdb908395ac42fec4702149e86c0af">Chip_PMU_SetWakeupPinEnabled</a> - correct usage of the Deep power down mode requires more involvement from the application. Entering the low power mode can fail, dependent on the state of the WAKEUP pin when the call is made, and the application code must take this possibility into account.<ul>
<li>In case the WAKEUP pin is high, the digital part of the PMU has no problems transitioning to the different internal states, and will arrive at the request Deep power down mode. Code will not be resumed.</li>
<li>In case the wakeup pin low, the desired state cannot be entered. Instead, the processor will go to Sleep (the Sleep Deep mode) with the IC <b>not</b> going to Deep Power Down (nor to Deep Sleep). The Deep power down request is not cleared however, but kept pending. The pending request is continually re-checked at the rate of the TFRO, i.e. at 32 kHz. <br />
 When an interrupt arrives, the ARM core will clear the sleep signal. This happens independently from the sampling of the wakeup pin. There are two possible outcomes at the next re-check of the pending request:<ul>
<li>Either the sleep signal has been cleared, or the wakeup pin is still low. In that case, Deep power down mode is <b>not</b> entered. Instead, code execution resumes. <br />
 The function <a class="el" href="a00458.html#ga1af1ed037e3824d314f7a01649cf2800">Chip_PMU_PowerMode_EnterDeepPowerDown</a> <b>will</b> return. The function implementation ensures the pending Deep power down request has been cleared before it returns.</li>
<li>Otherwise, if both the sleep signal has not yet been cleared and the wakeup pin is high again, Deep power down mode is entered belatedly.</li>
</ul>
</li>
</ul>
Unfortunately, this leads to an increased code complexity for the application, as it must implement a code flow that can deal with the different outcomes. Applications using both the Deep power down mode <em>and</em> the wakeup pin functionality should follow the below recommendations.<ul>
<li>Wrap the complete code flow from reset to Deep power down in a loop (line 3). In case <a class="el" href="a00458.html#ga1af1ed037e3824d314f7a01649cf2800">Chip_PMU_PowerMode_EnterDeepPowerDown</a> (line 9) returns, this will ensure that correct code can run.</li>
<li>Inside each loop, always check whether the wakeup pin is low, and act correspondingly (lines 2, 5, 7). This will ensure that a second attempt to enter the Deep power down mode, at the end of the second section of the loop, now has a bigger chance to succeed.</li>
<li>Before calling <a class="el" href="a00458.html#ga1af1ed037e3824d314f7a01649cf2800">Chip_PMU_PowerMode_EnterDeepPowerDown</a>, start a timer which generates an interrupt after a short interval, and enable the interrupt (line 8). This will ensure that only a very short amount of time is lost in the more expensive Sleep mode (when compared to the current consumption in Deep power down).</li>
</ul>
Combining all this results in a recommended basic application framework similar to this pseudo code: <div class="fragment"><div class="line"> 1. <a class="code" href="a00428.html#gae8d2d761b984f48c3dbb27dd32a8c119">Board_Init</a>();</div><div class="line"> 2. store cause of wakeup in local variable</div><div class="line"> 3. <span class="keywordflow">for</span>(;;) {</div><div class="line"> 4.    initialize drivers and modules</div><div class="line"> 5.    perform requested tasks, per the local variable<span class="stringliteral">&#39;s value</span></div><div class="line"><span class="stringliteral"> 6.    de-initialize drivers and modules</span></div><div class="line"><span class="stringliteral"> 7.    reset local variable to WAKEUP</span></div><div class="line"><span class="stringliteral"> 8.    start a timer, enabling its interrupt, and implementing a (dummy) interrupt handler.</span></div><div class="line"><span class="stringliteral"> 9.    Chip_PMU_PowerMode_EnterDeepPowerDown(true or false);</span></div><div class="line"><span class="stringliteral">10. }</span></div></div><!-- fragment --></dd></dl>
<dl class="section user"><dt>Example 1 - Using Sleep mode while measuring temperature:</dt><dd>Executed under main context: <div class="fragment"><div class="line">    <a class="code" href="a00463.html#ga12715c6340d203b52e3ab2893b3b48fe">Chip_TSen_Init</a>(<a class="code" href="a00433.html#ga22d19a2d93c60fbd0e06cdce66fae3a0">NSS_TSEN</a>);</div><div class="line">    <a class="code" href="a00463.html#ga1969ede5469c451da2650e4f89775500">Chip_TSen_Int_SetEnabledMask</a>(<a class="code" href="a00433.html#ga22d19a2d93c60fbd0e06cdce66fae3a0">NSS_TSEN</a>, <a class="code" href="a00463.html#ggad27a8a342c257af92cff3f4b82d50365a57370af1fa6260ccd070f261b9d10744">TSEN_INT_MEASUREMENT_RDY</a>);</div><div class="line">    <a class="code" href="a00446.html#gaa7a55182d0998e1ea13efd6875167cf0">NVIC_EnableIRQ</a>(<a class="code" href="a00435.html#gga7e1129cd8a196f4284d41db3e82ad5c8a47a61c8f8b323ce1e0315d29e0abda6d">TSEN_IRQn</a>);</div><div class="line">    <a class="code" href="a00463.html#gafd2de76fa6d4792a5d34cf6aefa470a6">Chip_TSen_Start</a>(<a class="code" href="a00433.html#ga22d19a2d93c60fbd0e06cdce66fae3a0">NSS_TSEN</a>);</div><div class="line">    <a class="code" href="a00458.html#gaf9474d0c37f1179ebe0edf523883452c">Chip_PMU_PowerMode_EnterSleep</a>();</div><div class="line">    <span class="comment">/* Code execution resumes here after the ISR has been serviced. */</span></div></div><!-- fragment --> <br />
 Executed under interrupt: <div class="fragment"><div class="line">    <span class="comment">/* To be called under interrupt from TSEN_IRQHandler */</span></div><div class="line">    <span class="keywordflow">if</span> ((<a class="code" href="a00463.html#gae96e3197a3a84603840ccc96a4bc0d18">Chip_TSen_Int_GetRawStatus</a>(<a class="code" href="a00433.html#ga22d19a2d93c60fbd0e06cdce66fae3a0">NSS_TSEN</a>) &amp; <a class="code" href="a00463.html#ggad27a8a342c257af92cff3f4b82d50365a57370af1fa6260ccd070f261b9d10744">TSEN_INT_MEASUREMENT_RDY</a>)) {</div><div class="line">        <a class="code" href="a00463.html#ga1db626565b096379c0beb73ec2ee253e">Chip_TSen_Int_ClearRawStatus</a>(<a class="code" href="a00433.html#ga22d19a2d93c60fbd0e06cdce66fae3a0">NSS_TSEN</a>, <a class="code" href="a00463.html#ggad27a8a342c257af92cff3f4b82d50365a57370af1fa6260ccd070f261b9d10744">TSEN_INT_MEASUREMENT_RDY</a>);</div><div class="line">        <span class="keywordtype">int</span> native = <a class="code" href="a00463.html#gafde8ef3e9a591f3b54e95da7150880c1">Chip_TSen_GetValue</a>(<a class="code" href="a00433.html#ga22d19a2d93c60fbd0e06cdce66fae3a0">NSS_TSEN</a>);</div><div class="line">        temperature = <a class="code" href="a00463.html#ga2a6f02b8028524e96b9760d9dd055947">Chip_TSen_NativeToCelsius</a>(native, 10);</div><div class="line">        <span class="comment">/* If the temperature is 21.2C, the variable &quot;temperature&quot; will be equal to 212. */</span></div><div class="line">    }</div></div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>Example 2 - Using Deep Sleep mode while counting when a pin is pulled high:</dt><dd>Executed under main context: <div class="fragment"><div class="line">    <a class="code" href="a00461.html#ga9ebc8bbc7bfdfa33953283afe6b90eac">Chip_SysCon_StartLogic_SetPIORisingEdge</a>(<a class="code" href="a00461.html#ggab1048a7c8ccb3daa33dd8f0882a57599aa29b3cb065b739282eab606879c9df38">SYSCON_STARTSOURCE_PIO0_1</a>);</div><div class="line">    <a class="code" href="a00461.html#ga8ceb9924b91514247027ccf2be1d69bf">Chip_SysCon_StartLogic_SetEnabledMask</a>(<a class="code" href="a00461.html#ggab1048a7c8ccb3daa33dd8f0882a57599aa29b3cb065b739282eab606879c9df38">SYSCON_STARTSOURCE_PIO0_1</a>);</div><div class="line">    <a class="code" href="a00461.html#gac2f2f79c6e63321bfafaeb649032ce3b">Chip_SysCon_StartLogic_ClearStatus</a>(<a class="code" href="a00461.html#ggab1048a7c8ccb3daa33dd8f0882a57599a7c3c57328a8a0783d1ae5675f98b8abb">SYSCON_STARTSOURCE_ALL</a>);</div><div class="line">    <a class="code" href="a00446.html#gaa7a55182d0998e1ea13efd6875167cf0">NVIC_EnableIRQ</a>(<a class="code" href="a00435.html#gga7e1129cd8a196f4284d41db3e82ad5c8a1a46a575f8160e4eee50b146825a9452">PIO0_1_IRQn</a>);</div><div class="line">    <span class="keywordflow">while</span> (1) {</div><div class="line">        <a class="code" href="a00458.html#gacee0d5eace81c8634b66862102478e6d">Chip_PMU_PowerMode_EnterDeepSleep</a>();</div><div class="line">        <span class="comment">/* Further handling of the event &quot;PIO1 pulled high / variable &#39;counter&#39; incremented&quot;. */</span></div><div class="line">        <span class="comment">/* ... */</span></div><div class="line">    }</div></div><!-- fragment --> <br />
 Executed under interrupt: <div class="fragment"><div class="line">    <span class="comment">/* To be called under interrupt from PIO0_1_IRQHandler */</span></div><div class="line">    <span class="keywordflow">if</span> ((<a class="code" href="a00461.html#ga680f64aaff0600e1386568f4be3a7218">Chip_SysCon_StartLogic_GetStatus</a>() &amp; <a class="code" href="a00461.html#ggab1048a7c8ccb3daa33dd8f0882a57599aa29b3cb065b739282eab606879c9df38">SYSCON_STARTSOURCE_PIO0_1</a>)) {</div><div class="line">        <a class="code" href="a00461.html#gac2f2f79c6e63321bfafaeb649032ce3b">Chip_SysCon_StartLogic_ClearStatus</a>(<a class="code" href="a00461.html#ggab1048a7c8ccb3daa33dd8f0882a57599aa29b3cb065b739282eab606879c9df38">SYSCON_STARTSOURCE_PIO0_1</a>);</div><div class="line">        counter++;</div><div class="line">    }</div></div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>Example 3 - Using Deep Power Down mode and keep track of the wake-up reasons:</dt><dd>Executed under main context: <div class="fragment"><div class="line">    uint32_t counters[4];</div><div class="line">    <a class="code" href="a00458.html#gadd02ac110402447536dcca375df4cd72">Chip_PMU_GetRetainedData</a>(counters, 0, 4);</div><div class="line">    </div><div class="line">    <a class="code" href="a00458.html#gad4c5057187d94a4ef13f01ebb8b4a731">PMU_DPD_WAKEUPREASON_T</a> reason = <a class="code" href="a00458.html#gaef096829b6b4445cc6c006589aac0681">Chip_PMU_PowerMode_GetDPDWakeupReason</a>();</div><div class="line">    <span class="keywordflow">if</span> (reason == <a class="code" href="a00458.html#ggad4c5057187d94a4ef13f01ebb8b4a731aef152d15a9a8eebd342de7f6513c4711">PMU_DPD_WAKEUPREASON_NONE</a>) {</div><div class="line">        <span class="comment">/* POR or RESETN pin asserted - (re-)setup and (re-)initialize */</span></div><div class="line">        memset(counters, 0, <span class="keyword">sizeof</span>(counters));</div><div class="line">        <a class="code" href="a00458.html#ga1dbdb908395ac42fec4702149e86c0af">Chip_PMU_SetWakeupPinEnabled</a>(<span class="keyword">true</span>);</div><div class="line">    }</div><div class="line">    <span class="keywordflow">else</span> {</div><div class="line">        <a class="code" href="a00433.html#ga28301f76c53b643912da7c538f74e2c6">ASSERT</a>(reason &lt; 4);</div><div class="line">        <span class="comment">/* PMU_DPD_WAKEUPREASON_NFCPOWER: Waking up from Deep Power Down due to the presence of an NFC field */</span></div><div class="line">        <span class="comment">/* PMU_DPD_WAKEUPREASON_WAKEUPPIN: Waking up from Deep Power Down due to Wakeup pin toggled low */</span></div><div class="line">        <span class="comment">/* PMU_DPD_WAKEUPREASON_RTC: Waking up from Deep Power Down due to RTC down counter expired */</span></div><div class="line">        counters[reason]++;</div><div class="line">    }</div><div class="line">    </div><div class="line">    <a class="code" href="a00458.html#gae502a3b16171568e51b23103aa5cbb2b">Chip_PMU_SetRetainedData</a>(counters, 0, 4);</div><div class="line">    <a class="code" href="a00434.html#ga30f8dffbc3aff9e560b8609c6ca80c13">Chip_Clock_System_BusyWait_ms</a>(4000); <span class="comment">/* Give a little time for a possible debugger to break in. */</span></div><div class="line">    <a class="code" href="a00458.html#ga1af1ed037e3824d314f7a01649cf2800">Chip_PMU_PowerMode_EnterDeepPowerDown</a>(<span class="keyword">false</span>);</div></div><!-- fragment --></dd></dl>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:a00658"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00458.html#a00658">NSS_PMU_T</a></td></tr>
<tr class="separator:a00658"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gad4c5057187d94a4ef13f01ebb8b4a731"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00458.html#gad4c5057187d94a4ef13f01ebb8b4a731">PMU_DPD_WAKEUPREASON_T</a> { <br />
&#160;&#160;<a class="el" href="a00458.html#ggad4c5057187d94a4ef13f01ebb8b4a731a5196c81200aee598f1847e1efdac698d">PMU_DPD_WAKEUPREASON_RTC</a> = 1, 
<br />
&#160;&#160;<a class="el" href="a00458.html#ggad4c5057187d94a4ef13f01ebb8b4a731a8c0b72c21db1a92a84ed2507230085f5">PMU_DPD_WAKEUPREASON_NFCPOWER</a> = 2, 
<br />
&#160;&#160;<a class="el" href="a00458.html#ggad4c5057187d94a4ef13f01ebb8b4a731a0a09d2a2e9fa4f2543f70c99bda1aedc">PMU_DPD_WAKEUPREASON_WAKEUPPIN</a> = 3, 
<br />
&#160;&#160;<a class="el" href="a00458.html#ggad4c5057187d94a4ef13f01ebb8b4a731aef152d15a9a8eebd342de7f6513c4711">PMU_DPD_WAKEUPREASON_NONE</a> = 0xFF
<br />
 }</td></tr>
<tr class="separator:gad4c5057187d94a4ef13f01ebb8b4a731"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga12e6e6d3c89303c25181f33c61225462"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00458.html#ga12e6e6d3c89303c25181f33c61225462">PMU_RTC_CLOCKSOURCE_T</a> { <br />
&#160;&#160;<a class="el" href="a00458.html#gga12e6e6d3c89303c25181f33c61225462aeffa1773d7fff6333ecc011c973e82b0">PMU_RTC_CLOCKSOURCE_NONE</a> = 0, 
<br />
&#160;&#160;<a class="el" href="a00458.html#gga12e6e6d3c89303c25181f33c61225462ad78f09e2ac3f40c2ebb8862dab0b2918">PMU_RTC_CLOCKSOURCE_TFRO</a> = 1
<br />
 }</td></tr>
<tr class="separator:ga12e6e6d3c89303c25181f33c61225462"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8394a797d90823f05a23cc01853224f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00458.html#gaa8394a797d90823f05a23cc01853224f">PMU_INT_T</a> { <br />
&#160;&#160;<a class="el" href="a00458.html#ggaa8394a797d90823f05a23cc01853224fa88886a73aac86c08df785b8165ce5e11">PMU_INT_BROWNOUT</a> = (1 &lt;&lt; 0), 
<br />
&#160;&#160;<a class="el" href="a00458.html#ggaa8394a797d90823f05a23cc01853224fa0b8f904730a6a4cfefec311599f1dcb2">PMU_INT_NFCPOWER</a> = (1 &lt;&lt; 1), 
<br />
&#160;&#160;<a class="el" href="a00458.html#ggaa8394a797d90823f05a23cc01853224faea32f99e07118c46f3480ae086467464">PMU_INT_NONE</a> = 0, 
<br />
&#160;&#160;<a class="el" href="a00458.html#ggaa8394a797d90823f05a23cc01853224faab2a5b429e45626b513982402da8320c">PMU_INT_ALL</a> = 0x3
<br />
 }</td></tr>
<tr class="separator:gaa8394a797d90823f05a23cc01853224f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5287dce4d392a5a0c691543e47afa60f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00458.html#ga5287dce4d392a5a0c691543e47afa60f">PMU_STATUS_T</a> { <br />
&#160;&#160;<a class="el" href="a00458.html#gga5287dce4d392a5a0c691543e47afa60fa90b264a0b3cc6078b0428108ead13f1a">PMU_STATUS_BROWNOUT</a> = (1 &lt;&lt; 5), 
<br />
&#160;&#160;<a class="el" href="a00458.html#gga5287dce4d392a5a0c691543e47afa60fa3619c9134035c2117f8318a02439c010">PMU_STATUS_VDD_NFC</a> = (1 &lt;&lt; 7)
<br />
 }</td></tr>
<tr class="separator:ga5287dce4d392a5a0c691543e47afa60f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaf9474d0c37f1179ebe0edf523883452c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00458.html#gaf9474d0c37f1179ebe0edf523883452c">Chip_PMU_PowerMode_EnterSleep</a> (void)</td></tr>
<tr class="separator:gaf9474d0c37f1179ebe0edf523883452c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacee0d5eace81c8634b66862102478e6d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00458.html#gacee0d5eace81c8634b66862102478e6d">Chip_PMU_PowerMode_EnterDeepSleep</a> (void)</td></tr>
<tr class="separator:gacee0d5eace81c8634b66862102478e6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1af1ed037e3824d314f7a01649cf2800"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00458.html#ga1af1ed037e3824d314f7a01649cf2800">Chip_PMU_PowerMode_EnterDeepPowerDown</a> (bool enableSwitching)</td></tr>
<tr class="separator:ga1af1ed037e3824d314f7a01649cf2800"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef096829b6b4445cc6c006589aac0681"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00458.html#gad4c5057187d94a4ef13f01ebb8b4a731">PMU_DPD_WAKEUPREASON_T</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00458.html#gaef096829b6b4445cc6c006589aac0681">Chip_PMU_PowerMode_GetDPDWakeupReason</a> (void)</td></tr>
<tr class="separator:gaef096829b6b4445cc6c006589aac0681"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa6a8b8c55c507ec2bcb4f965a5fe6705"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00458.html#gaa6a8b8c55c507ec2bcb4f965a5fe6705">Chip_PMU_Switch_GetVDDBat</a> (void)</td></tr>
<tr class="separator:gaa6a8b8c55c507ec2bcb4f965a5fe6705"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7cb74ee59ab87c65c1ba2fbb74c83e79"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00458.html#ga7cb74ee59ab87c65c1ba2fbb74c83e79">Chip_PMU_Switch_GetVNFC</a> (void)</td></tr>
<tr class="separator:ga7cb74ee59ab87c65c1ba2fbb74c83e79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49d6eeaf641dec113e934dac07146390"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00458.html#ga49d6eeaf641dec113e934dac07146390">Chip_PMU_Switch_OpenVDDBat</a> (void)</td></tr>
<tr class="separator:ga49d6eeaf641dec113e934dac07146390"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc0b596a1a5a4a2aeaa807f6e1dab349"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00458.html#gadc0b596a1a5a4a2aeaa807f6e1dab349">Chip_PMU_SetBODEnabled</a> (bool enabled)</td></tr>
<tr class="separator:gadc0b596a1a5a4a2aeaa807f6e1dab349"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga66cf590ab53abdb39f504aa603123245"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00458.html#ga66cf590ab53abdb39f504aa603123245">Chip_PMU_GetBODEnabled</a> (void)</td></tr>
<tr class="separator:ga66cf590ab53abdb39f504aa603123245"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1dbdb908395ac42fec4702149e86c0af"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00458.html#ga1dbdb908395ac42fec4702149e86c0af">Chip_PMU_SetWakeupPinEnabled</a> (bool enabled)</td></tr>
<tr class="separator:ga1dbdb908395ac42fec4702149e86c0af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga69c37446d8b221926eb4aa4ecad12b2c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00458.html#ga69c37446d8b221926eb4aa4ecad12b2c">Chip_PMU_GetWakeupPinEnabled</a> (void)</td></tr>
<tr class="separator:ga69c37446d8b221926eb4aa4ecad12b2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga388db7034063c86fd8275682a5997f96"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00458.html#ga388db7034063c86fd8275682a5997f96">Chip_PMU_SetRTCClockSource</a> (<a class="el" href="a00458.html#ga12e6e6d3c89303c25181f33c61225462">PMU_RTC_CLOCKSOURCE_T</a> source)</td></tr>
<tr class="separator:ga388db7034063c86fd8275682a5997f96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga50cc170b0c94700ebb9c9bc99dae52bf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00458.html#ga12e6e6d3c89303c25181f33c61225462">PMU_RTC_CLOCKSOURCE_T</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00458.html#ga50cc170b0c94700ebb9c9bc99dae52bf">Chip_PMU_GetRTCClockSource</a> (void)</td></tr>
<tr class="separator:ga50cc170b0c94700ebb9c9bc99dae52bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae502a3b16171568e51b23103aa5cbb2b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00458.html#gae502a3b16171568e51b23103aa5cbb2b">Chip_PMU_SetRetainedData</a> (uint32_t *pData, int offset, int size)</td></tr>
<tr class="separator:gae502a3b16171568e51b23103aa5cbb2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd02ac110402447536dcca375df4cd72"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00458.html#gadd02ac110402447536dcca375df4cd72">Chip_PMU_GetRetainedData</a> (uint32_t *pData, int offset, int size)</td></tr>
<tr class="separator:gadd02ac110402447536dcca375df4cd72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab6b002ff8a4bd48569898396ad305c44"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00458.html#ga5287dce4d392a5a0c691543e47afa60f">PMU_STATUS_T</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00458.html#gab6b002ff8a4bd48569898396ad305c44">Chip_PMU_GetStatus</a> (void)</td></tr>
<tr class="separator:gab6b002ff8a4bd48569898396ad305c44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9eb3ef6a2c8cf6483a480ba0c5ebdef3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00458.html#ga9eb3ef6a2c8cf6483a480ba0c5ebdef3">Chip_PMU_Int_SetEnabledMask</a> (<a class="el" href="a00458.html#gaa8394a797d90823f05a23cc01853224f">PMU_INT_T</a> mask)</td></tr>
<tr class="separator:ga9eb3ef6a2c8cf6483a480ba0c5ebdef3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5187199bed4e92a9f4eac7119a9fb8f2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00458.html#gaa8394a797d90823f05a23cc01853224f">PMU_INT_T</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00458.html#ga5187199bed4e92a9f4eac7119a9fb8f2">Chip_PMU_Int_GetEnabledMask</a> (void)</td></tr>
<tr class="separator:ga5187199bed4e92a9f4eac7119a9fb8f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga735cdce0bfae730113f91a7c039f8140"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00458.html#gaa8394a797d90823f05a23cc01853224f">PMU_INT_T</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00458.html#ga735cdce0bfae730113f91a7c039f8140">Chip_PMU_Int_GetRawStatus</a> (void)</td></tr>
<tr class="separator:ga735cdce0bfae730113f91a7c039f8140"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacfd4f1d8784232733334f4d75258bb63"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00458.html#gacfd4f1d8784232733334f4d75258bb63">Chip_PMU_Int_ClearRawStatus</a> (<a class="el" href="a00458.html#gaa8394a797d90823f05a23cc01853224f">PMU_INT_T</a> flags)</td></tr>
<tr class="separator:gacfd4f1d8784232733334f4d75258bb63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac391bd195080a9ef4fb9ed06ee9dd6a8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00458.html#gac391bd195080a9ef4fb9ed06ee9dd6a8">Chip_PMU_SetAutoPowerEnabled</a> (bool enabled)</td></tr>
<tr class="separator:gac391bd195080a9ef4fb9ed06ee9dd6a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga293a54296fa9cf19353a245d593ab5cf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00458.html#ga293a54296fa9cf19353a245d593ab5cf">Chip_PMU_GetAutoPowerEnabled</a> (void)</td></tr>
<tr class="separator:ga293a54296fa9cf19353a245d593ab5cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<hr/><h2 class="groupheader">Data Structure Documentation</h2>
<a name="a00658" id="a00658"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00658">&#9670;&nbsp;</a></span>NSS_PMU_T</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct NSS_PMU_T</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>NSS Power Management Unit register block structure </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a7e05310c08aef36772c83730159154ab"></a><a class="el" href="a00437.html#gaec43007d9998a0a0e01faede4133d6be">__IO</a> uint32_t</td>
<td class="fieldname">
PCON</td>
<td class="fielddoc">
<p>Power control Register </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a1646c4b45a7c925cda2d888002fc94d8"></a><a class="el" href="a00437.html#gaec43007d9998a0a0e01faede4133d6be">__IO</a> uint32_t</td>
<td class="fieldname">
GPREG[5]</td>
<td class="fielddoc">
<p>General purpose Registers 0..4 </p>
</td></tr>
<tr><td class="fieldtype">
<a id="aacc366ffd77dd7c4a384b3fe078a4eea"></a><a class="el" href="a00437.html#gaf63697ed9952cc71e1225efe205f6cd3">__I</a> uint32_t</td>
<td class="fieldname">
PSTAT</td>
<td class="fielddoc">
<p>Power Management Unit status register </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a39fbdbb7ad559315fa9c23de59936655"></a><a class="el" href="a00437.html#gaf63697ed9952cc71e1225efe205f6cd3">__I</a> uint32_t</td>
<td class="fieldname">
RESERVED1</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="a0c94199d31d111351019cc8f9616ec03"></a><a class="el" href="a00437.html#gaf63697ed9952cc71e1225efe205f6cd3">__I</a> uint32_t</td>
<td class="fieldname">
ACCSTAT</td>
<td class="fielddoc">
<p>Access status register </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a7b220b3277466b0213be83512e0017f8"></a><a class="el" href="a00437.html#gaec43007d9998a0a0e01faede4133d6be">__IO</a> uint32_t</td>
<td class="fieldname">
LDO1V6</td>
<td class="fielddoc">
<p>Analog 1.6V LDO trimming </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a13d8c36a296a876371d8e463cfce0bc5"></a><a class="el" href="a00437.html#gaf63697ed9952cc71e1225efe205f6cd3">__I</a> uint32_t</td>
<td class="fieldname">
RESERVED2</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="a7e25b1f72b5e87a82a161fea80087c23"></a><a class="el" href="a00437.html#gaec43007d9998a0a0e01faede4133d6be">__IO</a> uint32_t</td>
<td class="fieldname">
TMRCLKCTRL</td>
<td class="fielddoc">
<p>Timer clock control register </p>
</td></tr>
<tr><td class="fieldtype">
<a id="aadaeb8eaf11a1ac2952008e4f5aea459"></a><a class="el" href="a00437.html#gaec43007d9998a0a0e01faede4133d6be">__IO</a> uint32_t</td>
<td class="fieldname">
IMSC</td>
<td class="fielddoc">
<p>Interrupt mask set and clear register </p>
</td></tr>
<tr><td class="fieldtype">
<a id="aef20f9db3bdcf52941c8ac42f14a3c19"></a><a class="el" href="a00437.html#gaf63697ed9952cc71e1225efe205f6cd3">__I</a> uint32_t</td>
<td class="fieldname">
RIS</td>
<td class="fielddoc">
<p>Raw interrupt status register </p>
</td></tr>
<tr><td class="fieldtype">
<a id="ab93d8e22f60836895e96cc388310dd90"></a><a class="el" href="a00437.html#gaf63697ed9952cc71e1225efe205f6cd3">__I</a> uint32_t</td>
<td class="fieldname">
MIS</td>
<td class="fielddoc">
<p>Masked interrupt status register </p>
</td></tr>
<tr><td class="fieldtype">
<a id="afc0ed459ed55267df34cf3774e7c029d"></a><a class="el" href="a00437.html#ga7e25d9380f9ef903923964322e71f2f6">__O</a> uint32_t</td>
<td class="fieldname">
ICR</td>
<td class="fielddoc">
<p>Interrupt clear register </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="gad4c5057187d94a4ef13f01ebb8b4a731"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad4c5057187d94a4ef13f01ebb8b4a731">&#9670;&nbsp;</a></span>PMU_DPD_WAKEUPREASON_T</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="a00458.html#gad4c5057187d94a4ef13f01ebb8b4a731">PMU_DPD_WAKEUPREASON_T</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Possible reasons for waking up from Deep power down </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggad4c5057187d94a4ef13f01ebb8b4a731a5196c81200aee598f1847e1efdac698d"></a>PMU_DPD_WAKEUPREASON_RTC&#160;</td><td class="fielddoc"><p>RTC wakeup-downcounter expired </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad4c5057187d94a4ef13f01ebb8b4a731a8c0b72c21db1a92a84ed2507230085f5"></a>PMU_DPD_WAKEUPREASON_NFCPOWER&#160;</td><td class="fielddoc"><p>Power detected in the VNFC domain </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad4c5057187d94a4ef13f01ebb8b4a731a0a09d2a2e9fa4f2543f70c99bda1aedc"></a>PMU_DPD_WAKEUPREASON_WAKEUPPIN&#160;</td><td class="fielddoc"><p>WAKEUP pin negative edge detected </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad4c5057187d94a4ef13f01ebb8b4a731aef152d15a9a8eebd342de7f6513c4711"></a>PMU_DPD_WAKEUPREASON_NONE&#160;</td><td class="fielddoc"><p>IC hasen't woken-up from Deep power down since last POR event, RESETN pin assertion or Sleep/DeepSleep mode entry </p>
</td></tr>
</table>

</div>
</div>
<a id="ga12e6e6d3c89303c25181f33c61225462"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga12e6e6d3c89303c25181f33c61225462">&#9670;&nbsp;</a></span>PMU_RTC_CLOCKSOURCE_T</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="a00458.html#ga12e6e6d3c89303c25181f33c61225462">PMU_RTC_CLOCKSOURCE_T</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Possible clock sources for the RTC block </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga12e6e6d3c89303c25181f33c61225462aeffa1773d7fff6333ecc011c973e82b0"></a>PMU_RTC_CLOCKSOURCE_NONE&#160;</td><td class="fielddoc"><p>None of the clock sources is selected for the RTC block </p>
</td></tr>
<tr><td class="fieldname"><a id="gga12e6e6d3c89303c25181f33c61225462ad78f09e2ac3f40c2ebb8862dab0b2918"></a>PMU_RTC_CLOCKSOURCE_TFRO&#160;</td><td class="fielddoc"><p>Represents the TFRO as clock source for the RTC block </p>
</td></tr>
</table>

</div>
</div>
<a id="gaa8394a797d90823f05a23cc01853224f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa8394a797d90823f05a23cc01853224f">&#9670;&nbsp;</a></span>PMU_INT_T</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="a00458.html#gaa8394a797d90823f05a23cc01853224f">PMU_INT_T</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Possible PMU interrupt flags </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggaa8394a797d90823f05a23cc01853224fa88886a73aac86c08df785b8165ce5e11"></a>PMU_INT_BROWNOUT&#160;</td><td class="fielddoc"><p>Interrupt that is triggered when a Brown-Out is detected </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa8394a797d90823f05a23cc01853224fa0b8f904730a6a4cfefec311599f1dcb2"></a>PMU_INT_NFCPOWER&#160;</td><td class="fielddoc"><p>Interrupt that is triggered when power in the VNFC domain is detected </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa8394a797d90823f05a23cc01853224faea32f99e07118c46f3480ae086467464"></a>PMU_INT_NONE&#160;</td><td class="fielddoc"><p>Disable all Interrupts </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa8394a797d90823f05a23cc01853224faab2a5b429e45626b513982402da8320c"></a>PMU_INT_ALL&#160;</td><td class="fielddoc"><p>Enable all Interrupts </p>
</td></tr>
</table>

</div>
</div>
<a id="ga5287dce4d392a5a0c691543e47afa60f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5287dce4d392a5a0c691543e47afa60f">&#9670;&nbsp;</a></span>PMU_STATUS_T</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="a00458.html#ga5287dce4d392a5a0c691543e47afa60f">PMU_STATUS_T</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Possible status conditions of the PMU block (simultaneous bits are possible) </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga5287dce4d392a5a0c691543e47afa60fa90b264a0b3cc6078b0428108ead13f1a"></a>PMU_STATUS_BROWNOUT&#160;</td><td class="fielddoc"><p>Indicates whether a Brown-Out condition is currently being detected </p>
</td></tr>
<tr><td class="fieldname"><a id="gga5287dce4d392a5a0c691543e47afa60fa3619c9134035c2117f8318a02439c010"></a>PMU_STATUS_VDD_NFC&#160;</td><td class="fielddoc"><p>Indicates whether power in the VNFC domain is currently being detected </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gaf9474d0c37f1179ebe0edf523883452c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf9474d0c37f1179ebe0edf523883452c">&#9670;&nbsp;</a></span>Chip_PMU_PowerMode_EnterSleep()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Chip_PMU_PowerMode_EnterSleep </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the chip into Sleep power mode. </p><dl class="section note"><dt>Note</dt><dd>The program execution will be blocked inside this function for as long as the chip is in Sleep mode. After the chip exits Sleep mode and the respective ISR is executed, the execution will be resumed and this function will return. </dd>
<dd>
The observer flags that indicate which power modes were entered are cleared before entering this standby mode. Refer to <b>Power</b> <b>Modes</b> section for more details on the Sleep mode. </dd></dl>

</div>
</div>
<a id="gacee0d5eace81c8634b66862102478e6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacee0d5eace81c8634b66862102478e6d">&#9670;&nbsp;</a></span>Chip_PMU_PowerMode_EnterDeepSleep()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Chip_PMU_PowerMode_EnterDeepSleep </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the chip into Deep Sleep power mode. </p><dl class="section note"><dt>Note</dt><dd>The program execution will be blocked inside this function for as long as the chip is in Deep Sleep mode. After the chip exits Deep Sleep mode and the respective ISR is executed, the execution will be resumed and this function will return. </dd>
<dd>
All peripheral clocks must be disabled beforehand except for the Timers and Watchdog, if required. The power state after wakeup of some blocks must also be configured beforehand. Please refer to <a class="el" href="a00461.html">SysCon driver</a> documentation. </dd>
<dd>
The observer flags that indicate which power modes were entered are cleared before entering this standby mode. Refer to <b>Power</b> <b>Modes</b> section for more details on the Deep Sleep mode. </dd></dl>

</div>
</div>
<a id="ga1af1ed037e3824d314f7a01649cf2800"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1af1ed037e3824d314f7a01649cf2800">&#9670;&nbsp;</a></span>Chip_PMU_PowerMode_EnterDeepPowerDown()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Chip_PMU_PowerMode_EnterDeepPowerDown </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enableSwitching</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><em>Attempts</em> to put the chip into Deep power down power mode. </p><dl class="section warning"><dt>Warning</dt><dd>- There is a possibility the attempt will fail. In that case, different behaviors are possible. See <a class="el" href="a00458.html#pmu_deeppowerdownprocedure_anchor">Deep power down procedure</a> for important details. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enableSwitching</td><td>: Enables/Disables the automatic switching mechanism before entering Deep power down. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>- Setting <code>enableSwitching</code> to 'true' has impact on power consumption during Deep power down. See <a class="el" href="a00458.html#pmu_power_source_switches_par">Power Source switches</a> chapter. </dd>
<dd>
- Once in Deep power down mode, it is no longer possible to start a debug session, hence, special care must be taken when calling <a class="el" href="a00458.html#ga1af1ed037e3824d314f7a01649cf2800">Chip_PMU_PowerMode_EnterDeepPowerDown</a> with short "break-in" time between boot and the function call. In case Debug build is used, it is possible to introduce a 500ms delay by approaching an NFC field before entering Deep power down. This functionality is embedded in the <a class="el" href="a00458.html#ga1af1ed037e3824d314f7a01649cf2800">Chip_PMU_PowerMode_EnterDeepPowerDown</a> function and allows starting a debug session in ICs that would otherwise never accept a debug connection anymore. See <a class="el" href="a00768.html">SW Debug Considerations</a> for more details. </dd></dl>

</div>
</div>
<a id="gaef096829b6b4445cc6c006589aac0681"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaef096829b6b4445cc6c006589aac0681">&#9670;&nbsp;</a></span>Chip_PMU_PowerMode_GetDPDWakeupReason()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00458.html#gad4c5057187d94a4ef13f01ebb8b4a731">PMU_DPD_WAKEUPREASON_T</a> Chip_PMU_PowerMode_GetDPDWakeupReason </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieves the reason for the last wakeup from Deep power down. </p><dl class="section warning"><dt>Warning</dt><dd>Changing the power mode before calling this function will reset the register <a class="el" href="a00458.html#a7e05310c08aef36772c83730159154ab">NSS_PMU_T.PCON</a> which maintains the wakeup reason. This means the wakeup reason from Deep power down is lost<ul>
<li>after a reset: POR event or RESETN pin toggling</li>
<li>when going to Sleep or Deep sleep low power mode: <a class="el" href="a00458.html#gaf9474d0c37f1179ebe0edf523883452c">Chip_PMU_PowerMode_EnterSleep</a> or <a class="el" href="a00458.html#gacee0d5eace81c8634b66862102478e6d">Chip_PMU_PowerMode_EnterDeepSleep</a></li>
</ul>
</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>An enumeration value with the wakeup reason. This value will be <a class="el" href="a00458.html#ggad4c5057187d94a4ef13f01ebb8b4a731aef152d15a9a8eebd342de7f6513c4711">PMU_DPD_WAKEUPREASON_NONE</a> when the register <a class="el" href="a00458.html#a7e05310c08aef36772c83730159154ab">NSS_PMU_T.PCON</a> has been reset. </dd></dl>

</div>
</div>
<a id="gaa6a8b8c55c507ec2bcb4f965a5fe6705"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa6a8b8c55c507ec2bcb4f965a5fe6705">&#9670;&nbsp;</a></span>Chip_PMU_Switch_GetVDDBat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Chip_PMU_Switch_GetVDDBat </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the status of the VDDBAT pin power source switch </p><dl class="section return"><dt>Returns</dt><dd>True if the switch is closed, false otherwise. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Please refer to detailed documentation section for more details on how the automatic switching mechanism works. </dd></dl>

</div>
</div>
<a id="ga7cb74ee59ab87c65c1ba2fbb74c83e79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7cb74ee59ab87c65c1ba2fbb74c83e79">&#9670;&nbsp;</a></span>Chip_PMU_Switch_GetVNFC()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Chip_PMU_Switch_GetVNFC </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the status of the VNFC power source switch </p><dl class="section return"><dt>Returns</dt><dd>True if the switch is closed, false otherwise. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Please refer to detailed documentation section for more details on how the automatic switching mechanism works. </dd></dl>

</div>
</div>
<a id="ga49d6eeaf641dec113e934dac07146390"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga49d6eeaf641dec113e934dac07146390">&#9670;&nbsp;</a></span>Chip_PMU_Switch_OpenVDDBat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Chip_PMU_Switch_OpenVDDBat </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Forces the VDDBAT switch to its initial open state </p><dl class="section note"><dt>Note</dt><dd>The VBAT switch connects the VDDBAT pin to the VDD_ALON power domain. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The IC will enter the "Off" state if no power is present in the VNFC power domain or switch to VNFC power otherwise. See <a class="el" href="a00458.html#pmu_poweroffmode_anchor">Off mode</a> for more details. </dd></dl>

</div>
</div>
<a id="gadc0b596a1a5a4a2aeaa807f6e1dab349"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadc0b596a1a5a4a2aeaa807f6e1dab349">&#9670;&nbsp;</a></span>Chip_PMU_SetBODEnabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Chip_PMU_SetBODEnabled </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enabled</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enables/Disables the Brown-Out detection </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enabled</td><td>: If set to true enables the BOD, otherwise it disables it </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga66cf590ab53abdb39f504aa603123245"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga66cf590ab53abdb39f504aa603123245">&#9670;&nbsp;</a></span>Chip_PMU_GetBODEnabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Chip_PMU_GetBODEnabled </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the Brown-Out detection enabled status </p><dl class="section return"><dt>Returns</dt><dd>If true the Brown-Out detection is enabled, otherwise it is disabled </dd></dl>

</div>
</div>
<a id="ga1dbdb908395ac42fec4702149e86c0af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1dbdb908395ac42fec4702149e86c0af">&#9670;&nbsp;</a></span>Chip_PMU_SetWakeupPinEnabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Chip_PMU_SetWakeupPinEnabled </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enabled</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enables/Disables the wakeup pin functionality </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enabled</td><td>: If set to true enables the wakeup pin functionality, otherwise it disables it </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>For more details on how the wakeup pin is configured, refer to the "Wakeup Pin" section </dd></dl>

</div>
</div>
<a id="ga69c37446d8b221926eb4aa4ecad12b2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga69c37446d8b221926eb4aa4ecad12b2c">&#9670;&nbsp;</a></span>Chip_PMU_GetWakeupPinEnabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Chip_PMU_GetWakeupPinEnabled </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the wakeup pin functionality enabled status </p><dl class="section return"><dt>Returns</dt><dd>If true the wakeup pin functionality is enabled, otherwise it is disabled </dd></dl>
<dl class="section note"><dt>Note</dt><dd>For more details on how the wakeup pin is configured, refer to the "Wakeup Pin" section </dd></dl>

</div>
</div>
<a id="ga388db7034063c86fd8275682a5997f96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga388db7034063c86fd8275682a5997f96">&#9670;&nbsp;</a></span>Chip_PMU_SetRTCClockSource()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Chip_PMU_SetRTCClockSource </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00458.html#ga12e6e6d3c89303c25181f33c61225462">PMU_RTC_CLOCKSOURCE_T</a>&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the RTC block clock source. As there is only one possible source, this function effectively allows you to disable all RTC functionality. Gating the clock by providing <a class="el" href="a00458.html#gga12e6e6d3c89303c25181f33c61225462aeffa1773d7fff6333ecc011c973e82b0">PMU_RTC_CLOCKSOURCE_NONE</a> as value for <code>source</code> will disable both the up <b>and</b> the down counter in the RTC, i.e. will disable the calendaring functionality (it becomes impossible to keep track of absolute time) <b>and</b> the wake-up possibility from Deep Power Down mode after a configured number of seconds. Gating the clock for the RTC will save a modest amount of power (in the order of 20 nA). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>: see <a class="el" href="a00458.html#gad4c5057187d94a4ef13f01ebb8b4a731">PMU_DPD_WAKEUPREASON_T</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The default RTC block clock source is the TFRO: <a class="el" href="a00458.html#gga12e6e6d3c89303c25181f33c61225462ad78f09e2ac3f40c2ebb8862dab0b2918">PMU_RTC_CLOCKSOURCE_TFRO</a>. </dd></dl>

</div>
</div>
<a id="ga50cc170b0c94700ebb9c9bc99dae52bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga50cc170b0c94700ebb9c9bc99dae52bf">&#9670;&nbsp;</a></span>Chip_PMU_GetRTCClockSource()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00458.html#ga12e6e6d3c89303c25181f33c61225462">PMU_RTC_CLOCKSOURCE_T</a> Chip_PMU_GetRTCClockSource </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the RTC block clock source. </p><dl class="section return"><dt>Returns</dt><dd>The clock source of the RTC block </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The default RTC block clock source is the TFRO: <a class="el" href="a00458.html#gga12e6e6d3c89303c25181f33c61225462ad78f09e2ac3f40c2ebb8862dab0b2918">PMU_RTC_CLOCKSOURCE_TFRO</a>. </dd></dl>

</div>
</div>
<a id="gae502a3b16171568e51b23103aa5cbb2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae502a3b16171568e51b23103aa5cbb2b">&#9670;&nbsp;</a></span>Chip_PMU_SetRetainedData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Chip_PMU_SetRetainedData </td>
          <td>(</td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>pData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the required data words into the retained data section of the PMU </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pData</td><td>: A pointer to the data words to be set </td></tr>
    <tr><td class="paramname">offset</td><td>: The offset, in number of words, to where to set the first word </td></tr>
    <tr><td class="paramname">size</td><td>: The size, in words, of the data to set </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The content of the retained data section of the PMU will only be lost after a POR or an external reset (RESETN pin asserted). </dd>
<dd>
The retained data section length is 5 words, thus, the function will assert that the offset + size does not exceed 5 words. </dd></dl>

</div>
</div>
<a id="gadd02ac110402447536dcca375df4cd72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadd02ac110402447536dcca375df4cd72">&#9670;&nbsp;</a></span>Chip_PMU_GetRetainedData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Chip_PMU_GetRetainedData </td>
          <td>(</td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>pData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the required data words stored in the retained data section of the PMU </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pData</td><td>: A pointer to where to place the retrieved data words </td></tr>
    <tr><td class="paramname">offset</td><td>: The offset, in number of words, to where to get the first word from </td></tr>
    <tr><td class="paramname">size</td><td>: The size, in words, of the data to get </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The retained data section length is 5 words, thus, the function will assert that the offset + size does not exceed 5 words. </dd></dl>

</div>
</div>
<a id="gab6b002ff8a4bd48569898396ad305c44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab6b002ff8a4bd48569898396ad305c44">&#9670;&nbsp;</a></span>Chip_PMU_GetStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00458.html#ga5287dce4d392a5a0c691543e47afa60f">PMU_STATUS_T</a> Chip_PMU_GetStatus </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the status information from the PMU block </p><dl class="section return"><dt>Returns</dt><dd>Status conditions currently asserted in the PMU block </dd></dl>
<dl class="section note"><dt>Note</dt><dd>A bit set to 1 means that the corresponding status condition is present </dd>
<dd>
This function will provide the current status bit of the PMU block (once the conditions is not present anymore, the status bit will be cleared). </dd></dl>

</div>
</div>
<a id="ga9eb3ef6a2c8cf6483a480ba0c5ebdef3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9eb3ef6a2c8cf6483a480ba0c5ebdef3">&#9670;&nbsp;</a></span>Chip_PMU_Int_SetEnabledMask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Chip_PMU_Int_SetEnabledMask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00458.html#gaa8394a797d90823f05a23cc01853224f">PMU_INT_T</a>&#160;</td>
          <td class="paramname"><em>mask</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enables/Disables the PMU interrupts </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mask</td><td>: interrupt enabled mask to set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5187199bed4e92a9f4eac7119a9fb8f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5187199bed4e92a9f4eac7119a9fb8f2">&#9670;&nbsp;</a></span>Chip_PMU_Int_GetEnabledMask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00458.html#gaa8394a797d90823f05a23cc01853224f">PMU_INT_T</a> Chip_PMU_Int_GetEnabledMask </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieves the PMU interrupt enabled mask </p><dl class="section return"><dt>Returns</dt><dd>Interrupt enabled mask </dd></dl>

</div>
</div>
<a id="ga735cdce0bfae730113f91a7c039f8140"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga735cdce0bfae730113f91a7c039f8140">&#9670;&nbsp;</a></span>Chip_PMU_Int_GetRawStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00458.html#gaa8394a797d90823f05a23cc01853224f">PMU_INT_T</a> Chip_PMU_Int_GetRawStatus </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieves a bitVector with the RAW PMU interrupt flags </p><dl class="section return"><dt>Returns</dt><dd>BitVector with the PMU RAW interrupt flags </dd></dl>
<dl class="section note"><dt>Note</dt><dd>A bit set to 1 means that the corresponding interrupt flag is set. </dd></dl>

</div>
</div>
<a id="gacfd4f1d8784232733334f4d75258bb63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacfd4f1d8784232733334f4d75258bb63">&#9670;&nbsp;</a></span>Chip_PMU_Int_ClearRawStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Chip_PMU_Int_ClearRawStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00458.html#gaa8394a797d90823f05a23cc01853224f">PMU_INT_T</a>&#160;</td>
          <td class="paramname"><em>flags</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clears the required PMU interrupt flags </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>: Bitvector indicating which interrupt flags to clear </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac391bd195080a9ef4fb9ed06ee9dd6a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac391bd195080a9ef4fb9ed06ee9dd6a8">&#9670;&nbsp;</a></span>Chip_PMU_SetAutoPowerEnabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Chip_PMU_SetAutoPowerEnabled </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enabled</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enables/Disables automatic power supply switching between Vbat and NFC power </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enabled</td><td>: If set to <code>true</code> enables the automatic switch-over, if <code>false</code> power is taken from VBAT exclusively. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga293a54296fa9cf19353a245d593ab5cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga293a54296fa9cf19353a245d593ab5cf">&#9670;&nbsp;</a></span>Chip_PMU_GetAutoPowerEnabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Chip_PMU_GetAutoPowerEnabled </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the automatic power supply switching enabled status </p><dl class="section return"><dt>Returns</dt><dd>If <code>true</code> the automatic switch-over is enabled, otherwise it is fixed to VBAT power. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Tue Oct 20 2020 08:24:34 for NHS31xx SW API by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.14 </li>
  </ul>
</div>
</body>
</html>
