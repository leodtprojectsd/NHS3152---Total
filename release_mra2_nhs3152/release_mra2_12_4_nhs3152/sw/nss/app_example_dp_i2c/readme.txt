/**
 * @defgroup APP_NSS_I2C i2c: I2C communication example
 * @ingroup APPS_NSS
 *
 * @par Introduction
 *  This is an example application demonstrating how to make use of the @ref I2C_NSS "I2C Driver" or the
 *  @ref MODS_NSS_I2CBBM "I2C bit-bang module" @n
 *  Three build configurations are defined:
 *   - @c SLAVE - Implements I2C slave functionality using the I2C HW block
 *   - @c MASTER_HW - Implements I2C master functionality using the I2C HW block
 *   - @c MASTER_BB - Implements I2C master functionality using the I2C bit-bang module
 *   .
 *
 * @par SLAVE
 *  When setting the Debug configuration @b Debug_SLAVE active, the code from the source file @c slave.c will be
 *  compiled. The resulting application is an I2C slave, listening on #I2C_SLAVE_ADDRESS, and providing a portion of a
 *  text to the I2C master upon each transfer. @n
 *  While I2C communication is ongoing, a LED is lit.
 *
 * @par MASTER_HW
 *  When setting the Debug configuration @b Debug_MASTER_HW active, the code from the source file @c master_hw.c will be
 *  compiled. The resulting application is an I2C master, using the HW I2C block. @n
 *  The program will perpetually retrieve a portion of a text, dump the retrieved bytes in a single-record NDEF message,
 *  wait some time, and repeat the process. @n
 *  While I2C communication is ongoing, a LED is lit.
 *
 * @par MASTER_BB
 *  When setting the Debug configuration @b Debug_MASTER_BB active, the code from the source file @c master_bb.c will be
 *  compiled. The resulting application is an I2C master, using the I2C bit-bang module. @n
 *  The program will behave identical to @c MASTER_HW, except that the I2C communication will be slower. Any two PIOs
 *  can be used for I2C communication using this bit-bang module, but @b PIO0_4 and @b PIO0_5 are chosen in this
 *  application to make it trivial switching between @c MASTER_HW and @c MASTER_BB, both w.r.t. the source code and the
 *  HW setup.
 *  @note The NHS3100W8 gold bump version packages does not bring out the I2C pins connected to the HW I2C block. The
 *      @ref MODS_NSS_I2CBBM "I2C bit-bang module", is then available for use to include I2C functionality in your
 *      programs. @ref MODS_NSS_I2CBBM_DFT "Diversity settings" are available to remap the @c CLK and @c DAT lines to
 *      two of @b PIO0_0, @b PIO0_6, @b PIO0_10 and @b PIO0_11.
 *
 * @par Setup
 *  To demonstrate, two standard demo boards can be used. The NHS3100TEMODB boards "NHS3100 Temperature Monitoring
 *  Demo Board" can be bought directly on https://www.nxp.com/NTAGSMARTSENSOR or via several distributors.
 *  For any I2C communication, external pull-ups must be provided. The NHS3100TEMODB boards have provisions to use two
 *  additional PIOs to fulfill this role: 
 *  - One NHS3100TEMODB board can act as a slave device. No adaptations to the board are required.
 *  - A second NHS3100TEMODB board can act as a master device. The locations @c R3 and @c R4 on the board must be
 *      stuffed with a 10K resistor each. @b PIO0_3 is configured in the application code, providing the pull-up
 *      functionality to @b PIO0_4 and @b PIO0_5.
 *  . 
 *   
 *  @dot
 *  digraph G {
 *      rankdir = LR;
 *      edge [weight=2, arrowhead=none];
 *      splines=line;
 *  
 *      node [shape = record];
 *      master [label = "{ Master device | {<p3>PIO 3|<p4>PIO 4|<p5>PIO 5} }"];
 *      slave [label = "{ {<p3>PIO 3 | <p4>PIO 4 | <p5>PIO 5} | Slave device }"];
 *      r34 [label = "{ { <r3> R3 | <r4> R4} }"];
 *  
 *      x [shape = point];
 *      y [shape = point];
 *  
 *      master:p4 -> x -> slave:p4;
 *      master:p5 -> y -> slave:p5;
 *      master:p3 -> r34:r3 -> x;
 *      master:p3 -> r34:r4 -> y;
 *  }
 *  @enddot
 *   
 *  See also the schematics of the board, available in the SDK under the @em docs folder.
 *
 *  With @c R3 and @c R4 stuffed on one board, connect pin @b PIO0_4 of each board to each other, and connect pin
 *  @b PIO0_5 of each board to each other.
 *
 *  Flash the unchanged board with the build from @c Debug_SLAVE, and the other board with the build from either 
 *  @c Debug_MASTER_HW or @c Debug_MASTER_BB. When firmware is running on both, use a tag reader to read out the
 *  ever-changing textual data on the master device, received via I2C from the slave device.
 *  @note The slave device does not provide any NDEF message via its NFC interface, only the master device.
 *
 * @par Tag reader
 *  - on Android: any NFC-enabled Android phone can be used to read out the textual data generated by the tag without
 *      any APP installed or active.
 *  - on iOS: NXP's <a href="https://itunes.apple.com/us/app/nfc-taginfo-by-nxp/id1246143596">NFC TagInfo</a> APP
 *      can be used to read out the data generated by the tag.
 *  - on Windows and macOS: the <em>NTAG SmartSensor Automator</em> application, available in the SDK under
 *      <em>sw/crossplatform/comm</em>, can be used to read out the data generated by the tag.
 *  .
 */
