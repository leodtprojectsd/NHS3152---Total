<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NHS31xx storage - Maximizing storage for equisized samples: storage: NVM Storage module</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="nxp-logo_small.jpg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NHS31xx storage - Maximizing storage for equisized samples
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('index.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">storage: NVM Storage module </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The storage module allows an application to store samples <b> all of identical size</b> in non-volatile memories EEPROM and FLASH.</p>
<p>It will:</p><ul>
<li>abstract away where and how the samples are stored</li>
<li>provide an easy interface via which samples can be written to and read from</li>
<li>utilize all bits, placing all samples back to back, maximizing storage capacity</li>
<li>minimize FLASH program operations, thereby avoiding the time penalty, voltage drop and current consumption that comes with every FLASH program operation</li>
<li>move data from EEPROM to FLASH automatically whenever necessary to make sure the newest data is always in EEPROM</li>
<li>allow application-specific compression of the data just before moving data from EEPROM to FLASH</li>
<li>allow application-specific decompression of the data before they are read out again</li>
<li>recover its full state based on the contents of the non-volatile memory alone</li>
</ul>
<p>The storage module will use general purpose registers, EEPROM and FLASH to store bits of data. The usage of the three types of memories is prioritized. When a new sample is to be stored:</p><ul>
<li>first an attempt is made to store it in the general purpose registers ("cached").</li>
<li>when this is not possible, the storage module tries to store it (together with all the cached samples) in EEPROM <br />
 After moving data to EEPROM, the general purpose registers are re-used.</li>
<li>only when a sufficient amount of samples are stored in EEPROM, all the data is moved to FLASH. <br />
 After moving data to FLASH, the EEPROM is re-used.</li>
</ul>
<p>Writing samples always means appending them to the already written samples; it is not possible to edit the already written stream of bits. When reading out, the user can control the starting read position using a sequence number. It is automatically deduced where the corresponding sample is written, whether it is compressed, and what needs to be done to be able to return the requested sample(s).</p>
<dl class="section user"><dt>Hardening</dt><dd>The storage module provides a ready-made solution to maximize storage of samples in persistent memory. It can:<ul>
<li>store more than 10.000 samples without hitting the write endurance limit of both EEPROM and FLASH</li>
<li>recover state from unexpected resets</li>
<li>recover all or most of the samples in case of data corruption (this may occur when the battery is degraded and can no longer supply the minimum voltage when the load increases during a write operation in EEPROM or FLASH)</li>
</ul>
It is not possible to fully recover data under all circumstances. The storage module guarantees that only the last few samples may get lost. The number is dependent on the number of the reserved general purpose registers and the size of a sample, both of which (and more) can be tweaked using diversity settings.</dd></dl>
<dl class="section user"><dt>Diversity</dt><dd>This module supports diversity settings. Some settings define the type and size of the sample. Others define the EEPROM and FLASH regions placed under control of this module. The rest of the settings control the behavior of the module. Check <a class="el" href="a00177.html">Diversity Settings</a> for all diversity settings. <br />
 It is expected that each application that requires this module includes it and configures the diversity settings of the module according to its specific needs.</dd></dl>
<dl class="section user"><dt>Memory Requirements</dt><dd>The storage module requires a large chunk of SRAM, called its workarea - see <a class="el" href="a00002.html#a95fd6ccd851ad8813a21f6ade2190084">STORAGE_WORKAREA</a> and <a class="el" href="a00177.html#ga4b69ffeada7d6e645ed70b84786850f9">STORAGE_WORKAREA_SIZE</a>. This is used for two purposes:<ul>
<li>When storing samples, and a move from EEPROM to FLASH is required, the assigned compress callback - see <a class="el" href="a00002.html#aaa81898e5c033740fad627b87fed62af">STORAGE_COMPRESS_CB</a> - is given a pointer inside this SRAM memory. The output is then stored in FLASH.</li>
<li>When reading samples from FLASH, the assigned decompress callback - see <a class="el" href="a00002.html#a6edf730655366069960c566384171a4b">STORAGE_DECOMPRESS_CB</a> - is called as little as possible: its output is cached in the work area to speed up subsequent reads.</li>
</ul>
If two operations in your code require such a big chunk of memory, you can overlap them if they don't have to operate concurrently. Diversity setting <a class="el" href="a00002.html#a95fd6ccd851ad8813a21f6ade2190084">STORAGE_WORKAREA</a> can be used for this.</dd></dl>
<dl class="section user"><dt>How to use the module</dt><dd><ol type="1">
<li>Define the best diversity settings for your application or accept the default ones.</li>
<li>Initialize the EEPROM driver and the storage module, in that order.</li>
<li>Read and write samples as necessary, in any order or quantity that is required for your use case.</li>
<li>De-initialize the storage module and the EEPROM driver, in that order.</li>
</ol>
</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">    <span class="keywordtype">int</span> n;</div><div class="line">    uint8_t one = 1;</div><div class="line">    uint8_t ten[10] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};</div><div class="line"></div><div class="line">    Chip_EEPROM_Init(NSS_EEPROM);</div><div class="line">    <a class="code" href="a00176.html#gad04fe4fa8e78ef5572e4a39dec188c31">Storage_Init</a>();</div><div class="line">    <a class="code" href="a00176.html#ga345ce91da83ce1cea789068dfb587ed5">Storage_Reset</a>(<span class="keyword">false</span>);</div><div class="line"></div><div class="line">    <a class="code" href="a00176.html#ga820a105a6412fe21e8598f2c682664af">Storage_Write</a>(&amp;one, 1);</div><div class="line">    <a class="code" href="a00176.html#ga82112f49c64c590b321e1e02caf077f5">Storage_Seek</a>(0);</div><div class="line"></div><div class="line">    n = <a class="code" href="a00176.html#gad82b015bb0ed48f90d9782a4b29f52ff">Storage_Read</a>(&amp;one, 1); <span class="comment">/* one will remain 1 */</span></div><div class="line">    ASSERT(n == 1);</div><div class="line"></div><div class="line">    <a class="code" href="a00176.html#ga820a105a6412fe21e8598f2c682664af">Storage_Write</a>(ten, 10);</div><div class="line">    <span class="comment">/*  Read index:    x</span></div><div class="line"><span class="comment">     * Data stored: 1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9</span></div><div class="line"><span class="comment">     * Write index:                                  x</span></div><div class="line"><span class="comment">     */</span></div><div class="line"></div><div class="line">    <a class="code" href="a00176.html#ga82112f49c64c590b321e1e02caf077f5">Storage_Seek</a>(0);</div><div class="line">    n = <a class="code" href="a00176.html#gad82b015bb0ed48f90d9782a4b29f52ff">Storage_Read</a>(ten, 7); <span class="comment">/* ten will become {1, 0, 1, 2, 3, 4, 5, 7, 8, 9} */</span></div><div class="line">    ASSERT(n == 7);</div><div class="line">    <span class="comment">/*  Read index:                      x</span></div><div class="line"><span class="comment">     * Data stored: 1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9</span></div><div class="line"><span class="comment">     * Write index:                                  x</span></div><div class="line"><span class="comment">     */</span></div><div class="line"></div><div class="line">    n = <a class="code" href="a00176.html#gad82b015bb0ed48f90d9782a4b29f52ff">Storage_Read</a>(ten, 100); <span class="comment">/* ten will become {6, 7, 8, 9, 3, 4, 5, 7, 8, 9} */</span></div><div class="line">    ASSERT(n == 4);</div><div class="line">    <span class="comment">/*  Read index:                                  x</span></div><div class="line"><span class="comment">     * Data stored: 1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9</span></div><div class="line"><span class="comment">     * Write index:                                  x</span></div><div class="line"><span class="comment">     */</span></div><div class="line"></div><div class="line">    <a class="code" href="a00176.html#ga75abea0be7fefec6285224dc0f82f5ac">Storage_DeInit</a>();</div></div><!-- fragment --> </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>These functions are not re-entrant. Calling these functions from multiple threads or in an interrupt is highly discouraged. </dd>
<dd>
The storage module requires the exclusive use of <em>at</em> <em>least</em> <em>one</em> register in the always-on domain (see <a class="el" href="a00177.html#gaa0b4af28ee1307ce6c560e71d5a6c742">STORAGE_FIRST_ALON_REGISTER</a>). Under no circumstance may the reserved registers be touched from outside the storage module. </dd>
<dd>
Although the storage module is able to recover after a power loss or going to Power-off, it is slow in doing so. The slow recovery time only occurs once as long as no changes to the NVM are made (e.g. by calling <a class="el" href="a00176.html#ga820a105a6412fe21e8598f2c682664af">Storage_Write</a>). </dd></dl>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Tue Oct 20 2020 08:24:37 for NHS31xx storage - Maximizing storage for equisized samples by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.14 </li>
  </ul>
</div>
</body>
</html>
