<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NHS31xx SW API: iap: In Application Programming driver</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="nxp-logo_small.jpg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NHS31xx SW API
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('a00455.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">iap: In Application Programming driver<div class="ingroups"><a class="el" href="a00427.html">Drivers</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>The In Application Programming driver (IAP) API implements a wrapper for the actual code which is in ROM, and which is exposed via the binary IAP interface. The driver exposes the following features:</p><ol type="1">
<li>Read factory settings.</li>
<li>Prepare (unprotect) sectors for flash erase/program operations.</li>
<li>Erase flash sectors.</li>
<li>Erase flash pages.</li>
<li>Copy the data from RAM/EEPROM and write to flash.</li>
<li>Perform blank checking of the flash sectors.</li>
<li>Read Part Identification.</li>
<li>Read boot code version.</li>
<li>Read UID (Unique Identification) which is the device serial number.</li>
<li>Perform comparison of two memory spaces.</li>
</ol>
<p>The "Prepare" command will unprotect the sectors, and upon success execution of the flash operations including sector erase, page erase, and program commands, the touched sectors will be protected automatically.</p>
<dl class="section warning"><dt>Warning</dt><dd>To erase/program the flash, the system clock must be set to a clock frequency of minimum 125kHz.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>Please refer to the chapter "In Application Programming Firmware" of the User Manual for details on the IAP interface.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>During an erase or program operation, the flash is not accessible, hence if the Interrupt Vector Table is placed in Flash (default setup) the application should make sure that no interrupts are triggered. To disable all interrupts please refer to <a class="el" href="a00448.html#ga092b96b23f27f6b4258ce84add3b1528" title="Disable IRQ Interrupts. ">__disable_irq(void)</a>.</dd></dl>
<dl class="section user"><dt>Example1 - Erase flash sector 10 and write 4 pages (e.g. 64 bytes per page)</dt><dd>of data to the start address of sector 10<ul>
<li>Data : stored in ram buffer "buffer[256]"</li>
<li>Flash address : start address of sector 10. (Since each sector contain 16 pages, the first page in sector 10 is 10 * 16 = 160. Since sectors are 1024 bytes, the start address of sector 10 is 10 * 1024 = 10240.)</li>
<li>System clock : 8 MHz</li>
</ul>
<div class="fragment"><div class="line">    uint32_t offset;</div><div class="line">    uint32_t content;</div><div class="line">    <span class="keywordtype">void</span> *pFlash;</div><div class="line">    <a class="code" href="a00455.html#ga730c525085067a5f69a1029de14003ff">IAP_STATUS_T</a> result;</div><div class="line"></div><div class="line">    result = <a class="code" href="a00455.html#ga6ef706904f920e961af86c373921c8c7">Chip_IAP_Flash_PrepareSector</a>(10, 10);</div><div class="line">    <a class="code" href="a00433.html#ga28301f76c53b643912da7c538f74e2c6">ASSERT</a>(result == <a class="code" href="a00455.html#gga730c525085067a5f69a1029de14003ffa162325c59cc455ac24d79e9b5d7278f5">IAP_STATUS_CMD_SUCCESS</a>);</div><div class="line"></div><div class="line">    result = <a class="code" href="a00455.html#ga99cf673b9c835e7ec66fc901251bacff">Chip_IAP_Flash_EraseSector</a>(10, 10, 8000);</div><div class="line">    <a class="code" href="a00433.html#ga28301f76c53b643912da7c538f74e2c6">ASSERT</a>(result == <a class="code" href="a00455.html#gga730c525085067a5f69a1029de14003ffa162325c59cc455ac24d79e9b5d7278f5">IAP_STATUS_CMD_SUCCESS</a>);</div><div class="line"></div><div class="line">    result = <a class="code" href="a00455.html#ga44bd48c7813e360d66de6184d414fd89">Chip_IAP_Flash_SectorBlankCheck</a>(10, 10, &amp;offset, &amp;content); <span class="comment">/* Optional */</span></div><div class="line">    <a class="code" href="a00433.html#ga28301f76c53b643912da7c538f74e2c6">ASSERT</a>(result == <a class="code" href="a00455.html#gga730c525085067a5f69a1029de14003ffa162325c59cc455ac24d79e9b5d7278f5">IAP_STATUS_CMD_SUCCESS</a>);</div><div class="line"></div><div class="line">    result = <a class="code" href="a00455.html#ga6ef706904f920e961af86c373921c8c7">Chip_IAP_Flash_PrepareSector</a>(10, 10);</div><div class="line">    <a class="code" href="a00433.html#ga28301f76c53b643912da7c538f74e2c6">ASSERT</a>(result == <a class="code" href="a00455.html#gga730c525085067a5f69a1029de14003ffa162325c59cc455ac24d79e9b5d7278f5">IAP_STATUS_CMD_SUCCESS</a>);</div><div class="line"></div><div class="line">    pFlash = (<span class="keywordtype">void</span> *)10240; <span class="comment">/* pFlash points to start address of sector 10 */</span></div><div class="line">    result = <a class="code" href="a00455.html#ga89f955abdbb7830862fee9b0fa8a5e73">Chip_IAP_Flash_Program</a>(buffer, pFlash, 256, 8000);</div><div class="line">    <a class="code" href="a00433.html#ga28301f76c53b643912da7c538f74e2c6">ASSERT</a>(result == <a class="code" href="a00455.html#gga730c525085067a5f69a1029de14003ffa162325c59cc455ac24d79e9b5d7278f5">IAP_STATUS_CMD_SUCCESS</a>);</div><div class="line"></div><div class="line">    result = <a class="code" href="a00455.html#gadeed0ce03e9ba7db17dc40b354e2f9b9">Chip_IAP_Compare</a>(buffer, pFlash, 256, &amp;offset); <span class="comment">/* Optional */</span></div><div class="line">    <a class="code" href="a00433.html#ga28301f76c53b643912da7c538f74e2c6">ASSERT</a>(result == <a class="code" href="a00455.html#gga730c525085067a5f69a1029de14003ffa162325c59cc455ac24d79e9b5d7278f5">IAP_STATUS_CMD_SUCCESS</a>);</div></div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>Example 2 - Load RTC factory calibration value into RTC</dt><dd><div class="fragment"><div class="line">    uint32_t rtcCal = <a class="code" href="a00455.html#gaf73987bd61f9cabc6d113a77612cfe18">Chip_IAP_ReadFactorySettings</a>((uint32_t) &amp;<a class="code" href="a00433.html#ga0ac2db8886b6fc2962d0919d77089bb7">NSS_RTC</a>-&gt;CAL);</div><div class="line">    <a class="code" href="a00459.html#ga92bd08679d14bccd760d4d5dda26bf2e">Chip_RTC_SetCalibration</a>(<a class="code" href="a00433.html#ga0ac2db8886b6fc2962d0919d77089bb7">NSS_RTC</a>, (<span class="keywordtype">int</span>)rtcCal);</div></div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>Example 3 - Read Part ID, boot version &amp; UID</dt><dd><div class="fragment"><div class="line">    uint32_t partID = <a class="code" href="a00455.html#ga1131cc48e25490e38beb2449ab73d303">Chip_IAP_ReadPartID</a>();</div><div class="line">    <span class="keywordtype">int</span> bootVersion = <a class="code" href="a00455.html#ga0149a7c56cae8c5a278b3a677d4d1173">Chip_IAP_ReadBootVersion</a>() &amp; 0x0000FFFF; <span class="comment">/* Mask off byte2 and byte3 */</span></div><div class="line">    uint32_t uid[4];</div><div class="line">    <a class="code" href="a00455.html#gaef2716487d9601b21482ed22b30ff29c">Chip_IAP_ReadUID</a>(uid);</div></div><!-- fragment --></dd></dl>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga730c525085067a5f69a1029de14003ff"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00455.html#ga730c525085067a5f69a1029de14003ff">IAP_STATUS_T</a> { <br />
&#160;&#160;<a class="el" href="a00455.html#gga730c525085067a5f69a1029de14003ffa162325c59cc455ac24d79e9b5d7278f5">IAP_STATUS_CMD_SUCCESS</a> = 0, 
<br />
&#160;&#160;<a class="el" href="a00455.html#gga730c525085067a5f69a1029de14003ffaab47e56bd365e3ffd7fd2217da940644">IAP_STATUS_INVALID_COMMAND</a> = 1, 
<br />
&#160;&#160;<a class="el" href="a00455.html#gga730c525085067a5f69a1029de14003ffabee1a9d0c08b04dbcdab37729ab30087">IAP_STATUS_SRC_ADDR_ERROR</a> = 2, 
<br />
&#160;&#160;<a class="el" href="a00455.html#gga730c525085067a5f69a1029de14003ffa23fe1b89f4116ec0c5fb9482075569d5">IAP_STATUS_DST_ADDR_ERROR</a> = 3, 
<br />
&#160;&#160;<a class="el" href="a00455.html#gga730c525085067a5f69a1029de14003ffab821def9a263eb71b00dcda6a6f276bf">IAP_STATUS_SRC_ADDR_NOT_MAPPED</a> = 4, 
<br />
&#160;&#160;<a class="el" href="a00455.html#gga730c525085067a5f69a1029de14003ffa46b8ac6cb700728fc6e31254a67a941f">IAP_STATUS_DST_ADDR_NOT_MAPPED</a> = 5, 
<br />
&#160;&#160;<a class="el" href="a00455.html#gga730c525085067a5f69a1029de14003ffaaf98be1b7204cf66199fb60790435f96">IAP_STATUS_COUNT_ERROR</a> = 6, 
<br />
&#160;&#160;<a class="el" href="a00455.html#gga730c525085067a5f69a1029de14003ffad542f261c1ac8aad8e47034326c27f41">IAP_STATUS_INVALID_SECTOR</a> = 7, 
<br />
&#160;&#160;<a class="el" href="a00455.html#gga730c525085067a5f69a1029de14003ffa1aa4d4374cc563962ddfee6f1b7d9c58">IAP_STATUS_SECTOR_NOT_BLANK</a> = 8, 
<br />
&#160;&#160;<a class="el" href="a00455.html#gga730c525085067a5f69a1029de14003ffa6ae8f6fd94035c1d57a689a70cc8aedf">IAP_STATUS_SECTOR_NOT_PREPARED</a> = 9, 
<br />
&#160;&#160;<a class="el" href="a00455.html#gga730c525085067a5f69a1029de14003ffa8071b8a191f91c17472c141fd313fcf1">IAP_STATUS_COMPARE_ERROR</a> = 10, 
<br />
&#160;&#160;<a class="el" href="a00455.html#gga730c525085067a5f69a1029de14003ffa190212085f6f9e74295237e4150588c9">IAP_STATUS_BUSY</a> = 11, 
<br />
&#160;&#160;<a class="el" href="a00455.html#gga730c525085067a5f69a1029de14003ffa991c7f9cc194aa216e5c1b395e89490d">IAP_STATUS_PARAM_ERROR</a> = 12, 
<br />
&#160;&#160;<a class="el" href="a00455.html#gga730c525085067a5f69a1029de14003ffa880bbe4b94480fdf5ab17a32e4c7012b">IAP_STATUS_ADDR_ERROR</a> = 13
<br />
 }</td></tr>
<tr class="separator:ga730c525085067a5f69a1029de14003ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaf73987bd61f9cabc6d113a77612cfe18"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00455.html#gaf73987bd61f9cabc6d113a77612cfe18">Chip_IAP_ReadFactorySettings</a> (uint32_t address)</td></tr>
<tr class="separator:gaf73987bd61f9cabc6d113a77612cfe18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1131cc48e25490e38beb2449ab73d303"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00455.html#ga1131cc48e25490e38beb2449ab73d303">Chip_IAP_ReadPartID</a> (void)</td></tr>
<tr class="separator:ga1131cc48e25490e38beb2449ab73d303"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0149a7c56cae8c5a278b3a677d4d1173"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00455.html#ga0149a7c56cae8c5a278b3a677d4d1173">Chip_IAP_ReadBootVersion</a> (void)</td></tr>
<tr class="separator:ga0149a7c56cae8c5a278b3a677d4d1173"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef2716487d9601b21482ed22b30ff29c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00455.html#gaef2716487d9601b21482ed22b30ff29c">Chip_IAP_ReadUID</a> (uint32_t uid[4])</td></tr>
<tr class="separator:gaef2716487d9601b21482ed22b30ff29c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ef706904f920e961af86c373921c8c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00455.html#ga730c525085067a5f69a1029de14003ff">IAP_STATUS_T</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00455.html#ga6ef706904f920e961af86c373921c8c7">Chip_IAP_Flash_PrepareSector</a> (uint32_t sectorStart, uint32_t sectorEnd)</td></tr>
<tr class="separator:ga6ef706904f920e961af86c373921c8c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga99cf673b9c835e7ec66fc901251bacff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00455.html#ga730c525085067a5f69a1029de14003ff">IAP_STATUS_T</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00455.html#ga99cf673b9c835e7ec66fc901251bacff">Chip_IAP_Flash_EraseSector</a> (uint32_t sectorStart, uint32_t sectorEnd, uint32_t kHzSysClk)</td></tr>
<tr class="separator:ga99cf673b9c835e7ec66fc901251bacff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae1888c895c6b80d977bb13bdb37fa324"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00455.html#ga730c525085067a5f69a1029de14003ff">IAP_STATUS_T</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00455.html#gae1888c895c6b80d977bb13bdb37fa324">Chip_IAP_Flash_ErasePage</a> (uint32_t pageStart, uint32_t pageEnd, uint32_t kHzSysClk)</td></tr>
<tr class="separator:gae1888c895c6b80d977bb13bdb37fa324"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89f955abdbb7830862fee9b0fa8a5e73"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00455.html#ga730c525085067a5f69a1029de14003ff">IAP_STATUS_T</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00455.html#ga89f955abdbb7830862fee9b0fa8a5e73">Chip_IAP_Flash_Program</a> (const void *pSrc, const void *pFlash, uint32_t size, uint32_t kHzSysClk)</td></tr>
<tr class="separator:ga89f955abdbb7830862fee9b0fa8a5e73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44bd48c7813e360d66de6184d414fd89"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00455.html#ga730c525085067a5f69a1029de14003ff">IAP_STATUS_T</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00455.html#ga44bd48c7813e360d66de6184d414fd89">Chip_IAP_Flash_SectorBlankCheck</a> (uint32_t sectorStart, uint32_t sectorEnd, uint32_t *pOffset, uint32_t *pContent)</td></tr>
<tr class="separator:ga44bd48c7813e360d66de6184d414fd89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadeed0ce03e9ba7db17dc40b354e2f9b9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00455.html#ga730c525085067a5f69a1029de14003ff">IAP_STATUS_T</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00455.html#gadeed0ce03e9ba7db17dc40b354e2f9b9">Chip_IAP_Compare</a> (const void *pAddress1, const void *pAddress2, uint32_t size, uint32_t *pOffset)</td></tr>
<tr class="separator:gadeed0ce03e9ba7db17dc40b354e2f9b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga730c525085067a5f69a1029de14003ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga730c525085067a5f69a1029de14003ff">&#9670;&nbsp;</a></span>IAP_STATUS_T</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="a00455.html#ga730c525085067a5f69a1029de14003ff">IAP_STATUS_T</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Possible return codes from the IAP </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga730c525085067a5f69a1029de14003ffa162325c59cc455ac24d79e9b5d7278f5"></a>IAP_STATUS_CMD_SUCCESS&#160;</td><td class="fielddoc"><p>SUCCESS </p>
</td></tr>
<tr><td class="fieldname"><a id="gga730c525085067a5f69a1029de14003ffaab47e56bd365e3ffd7fd2217da940644"></a>IAP_STATUS_INVALID_COMMAND&#160;</td><td class="fielddoc"><p>Command number is invalid </p>
</td></tr>
<tr><td class="fieldname"><a id="gga730c525085067a5f69a1029de14003ffabee1a9d0c08b04dbcdab37729ab30087"></a>IAP_STATUS_SRC_ADDR_ERROR&#160;</td><td class="fielddoc"><p>Source address not on word boundary </p>
</td></tr>
<tr><td class="fieldname"><a id="gga730c525085067a5f69a1029de14003ffa23fe1b89f4116ec0c5fb9482075569d5"></a>IAP_STATUS_DST_ADDR_ERROR&#160;</td><td class="fielddoc"><p>Destination address not on word or 64 byte boundary </p>
</td></tr>
<tr><td class="fieldname"><a id="gga730c525085067a5f69a1029de14003ffab821def9a263eb71b00dcda6a6f276bf"></a>IAP_STATUS_SRC_ADDR_NOT_MAPPED&#160;</td><td class="fielddoc"><p>Source address is out of range </p>
</td></tr>
<tr><td class="fieldname"><a id="gga730c525085067a5f69a1029de14003ffa46b8ac6cb700728fc6e31254a67a941f"></a>IAP_STATUS_DST_ADDR_NOT_MAPPED&#160;</td><td class="fielddoc"><p>Destination address is out of range </p>
</td></tr>
<tr><td class="fieldname"><a id="gga730c525085067a5f69a1029de14003ffaaf98be1b7204cf66199fb60790435f96"></a>IAP_STATUS_COUNT_ERROR&#160;</td><td class="fielddoc"><p>Byte count is not multiple of 4 or is not a permitted value </p>
</td></tr>
<tr><td class="fieldname"><a id="gga730c525085067a5f69a1029de14003ffad542f261c1ac8aad8e47034326c27f41"></a>IAP_STATUS_INVALID_SECTOR&#160;</td><td class="fielddoc"><p>Sector number is invalid </p>
</td></tr>
<tr><td class="fieldname"><a id="gga730c525085067a5f69a1029de14003ffa1aa4d4374cc563962ddfee6f1b7d9c58"></a>IAP_STATUS_SECTOR_NOT_BLANK&#160;</td><td class="fielddoc"><p>Sector is not blank </p>
</td></tr>
<tr><td class="fieldname"><a id="gga730c525085067a5f69a1029de14003ffa6ae8f6fd94035c1d57a689a70cc8aedf"></a>IAP_STATUS_SECTOR_NOT_PREPARED&#160;</td><td class="fielddoc"><p>Sector is not prepared, or still protected </p>
</td></tr>
<tr><td class="fieldname"><a id="gga730c525085067a5f69a1029de14003ffa8071b8a191f91c17472c141fd313fcf1"></a>IAP_STATUS_COMPARE_ERROR&#160;</td><td class="fielddoc"><p>Compare error which means the data buffers contain different content </p>
</td></tr>
<tr><td class="fieldname"><a id="gga730c525085067a5f69a1029de14003ffa190212085f6f9e74295237e4150588c9"></a>IAP_STATUS_BUSY&#160;</td><td class="fielddoc"><p>Flash hardware is busy </p>
</td></tr>
<tr><td class="fieldname"><a id="gga730c525085067a5f69a1029de14003ffa991c7f9cc194aa216e5c1b395e89490d"></a>IAP_STATUS_PARAM_ERROR&#160;</td><td class="fielddoc"><p>Insufficient number of parameters </p>
</td></tr>
<tr><td class="fieldname"><a id="gga730c525085067a5f69a1029de14003ffa880bbe4b94480fdf5ab17a32e4c7012b"></a>IAP_STATUS_ADDR_ERROR&#160;</td><td class="fielddoc"><p>Address is not on word boundary </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gaf73987bd61f9cabc6d113a77612cfe18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf73987bd61f9cabc6d113a77612cfe18">&#9670;&nbsp;</a></span>Chip_IAP_ReadFactorySettings()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t Chip_IAP_ReadFactorySettings </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>address</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read factory settings for calibration registers </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>: Address of the targeted calibration register that needs to read the factory setting, Please see the user manual to find out which registers have factory setting available. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Output parameter for the factory setting </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function asserts that the requested address does correspond to a supported factory setting. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>As part of this API call, EEPROM is de-initialized before the IAP command execution, if it was already in initialized state. Following that, it will get initialized back after the IAP command gets executed. Thus the execution time for this function will vary depending on the state of EEPROM prior to calling this function. </dd></dl>

</div>
</div>
<a id="ga1131cc48e25490e38beb2449ab73d303"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1131cc48e25490e38beb2449ab73d303">&#9670;&nbsp;</a></span>Chip_IAP_ReadPartID()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t Chip_IAP_ReadPartID </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read Part Identification Number </p><dl class="section return"><dt>Returns</dt><dd>Part Identification Number read via IAP command. </dd></dl>

</div>
</div>
<a id="ga0149a7c56cae8c5a278b3a677d4d1173"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0149a7c56cae8c5a278b3a677d4d1173">&#9670;&nbsp;</a></span>Chip_IAP_ReadBootVersion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Chip_IAP_ReadBootVersion </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read boot version number </p><dl class="section return"><dt>Returns</dt><dd>Boot version number. Read as:<ul>
<li>&lt;Byte 3&gt; : Reserved.</li>
<li>&lt;Byte 2&gt; : Reserved.</li>
<li>&lt;Byte 1&gt; : Major Version Number, 8 bits.</li>
<li>&lt;Byte 0&gt; : Minor Version Number, 8 bits, LSB.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Mask operation is required in order to get the correct version number. </dd></dl>

</div>
</div>
<a id="gaef2716487d9601b21482ed22b30ff29c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaef2716487d9601b21482ed22b30ff29c">&#9670;&nbsp;</a></span>Chip_IAP_ReadUID()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Chip_IAP_ReadUID </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>uid</em>[4]</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read UID - the device serial number </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uid</td><td>: array with caller allocated space of 4 words that will be filled with the UID. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>As part of this API call, EEPROM is de-initialized before the IAP command execution, if it was already in initialized state. Following that, it will get initialized back after the IAP command gets executed. Thus the execution time for this function will vary depending on the state of EEPROM prior to calling this function. </dd></dl>

</div>
</div>
<a id="ga6ef706904f920e961af86c373921c8c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6ef706904f920e961af86c373921c8c7">&#9670;&nbsp;</a></span>Chip_IAP_Flash_PrepareSector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00455.html#ga730c525085067a5f69a1029de14003ff">IAP_STATUS_T</a> Chip_IAP_Flash_PrepareSector </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>sectorStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>sectorEnd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prepare (i.e. unprotect) the flash sectors </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sectorStart</td><td>: The first sector that will be unprotected. </td></tr>
    <tr><td class="paramname">sectorEnd</td><td>: The last sector that will be unprotected. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Result of the operation. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Both the start sector and end sector are inclusive. </dd>
<dd>
Please keep the claimed RAM area untouched. Refer to user manual for more details. </dd></dl>

</div>
</div>
<a id="ga99cf673b9c835e7ec66fc901251bacff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga99cf673b9c835e7ec66fc901251bacff">&#9670;&nbsp;</a></span>Chip_IAP_Flash_EraseSector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00455.html#ga730c525085067a5f69a1029de14003ff">IAP_STATUS_T</a> Chip_IAP_Flash_EraseSector </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>sectorStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>sectorEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>kHzSysClk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Erase flash sectors </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sectorStart</td><td>: The first sector to be erased. </td></tr>
    <tr><td class="paramname">sectorEnd</td><td>: The last sector to be erased. </td></tr>
    <tr><td class="paramname">kHzSysClk</td><td>: The actual CPU clock speed in kHz. This parameter will be ignored for chips without external clock. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Result of the operation. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Both the start sector and end sector are inclusive. </dd>
<dd>
<a class="el" href="a00455.html#ga6ef706904f920e961af86c373921c8c7">Chip_IAP_Flash_PrepareSector</a> must be called in advance for all sectors. </dd>
<dd>
For page level erase, please refer to API <a class="el" href="a00455.html#gae1888c895c6b80d977bb13bdb37fa324">Chip_IAP_Flash_ErasePage</a>. </dd>
<dd>
Please keep the claimed RAM area untouched. Refer to user manual for more details. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>If the Interrupt Vector Table is placed in Flash (default setup) disable all interrupts: <a class="el" href="a00448.html#ga092b96b23f27f6b4258ce84add3b1528" title="Disable IRQ Interrupts. ">__disable_irq(void)</a> </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>If interrupts were disabled, enable them again: <a class="el" href="a00448.html#ga6fea83fe11c9a07924fb1ef316a9c76c" title="Enable IRQ Interrupts. ">__enable_irq(void)</a> </dd></dl>

</div>
</div>
<a id="gae1888c895c6b80d977bb13bdb37fa324"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae1888c895c6b80d977bb13bdb37fa324">&#9670;&nbsp;</a></span>Chip_IAP_Flash_ErasePage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00455.html#ga730c525085067a5f69a1029de14003ff">IAP_STATUS_T</a> Chip_IAP_Flash_ErasePage </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pageStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pageEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>kHzSysClk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Erase flash pages </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pageStart</td><td>: The first page to be erased. </td></tr>
    <tr><td class="paramname">pageEnd</td><td>: The last page to be erased. </td></tr>
    <tr><td class="paramname">kHzSysClk</td><td>: The actual CPU clock speed in kHz. This parameter will be ignored for chips without external clock. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Result of the operation. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Both the start page and end page are inclusive. </dd>
<dd>
<a class="el" href="a00455.html#ga6ef706904f920e961af86c373921c8c7">Chip_IAP_Flash_PrepareSector</a> must be called in advance for all sectors involved. </dd>
<dd>
For sector level erase, please refer to API <a class="el" href="a00455.html#ga99cf673b9c835e7ec66fc901251bacff">Chip_IAP_Flash_EraseSector</a>. </dd>
<dd>
Please keep the claimed RAM area untouched. Refer to user manual for more details. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>If the Interrupt Vector Table is placed in Flash (default setup) disable all interrupts: <a class="el" href="a00448.html#ga092b96b23f27f6b4258ce84add3b1528" title="Disable IRQ Interrupts. ">__disable_irq(void)</a> </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>If interrupts were disabled, enable them again: <a class="el" href="a00448.html#ga6fea83fe11c9a07924fb1ef316a9c76c" title="Enable IRQ Interrupts. ">__enable_irq(void)</a> </dd></dl>

</div>
</div>
<a id="ga89f955abdbb7830862fee9b0fa8a5e73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga89f955abdbb7830862fee9b0fa8a5e73">&#9670;&nbsp;</a></span>Chip_IAP_Flash_Program()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00455.html#ga730c525085067a5f69a1029de14003ff">IAP_STATUS_T</a> Chip_IAP_Flash_Program </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>pSrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>pFlash</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>kHzSysClk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy data from RAM and write/program to flash </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pSrc</td><td>: The ram or EEPROM address where the data is copied from. Must be word (32 bits) aligned. </td></tr>
    <tr><td class="paramname">pFlash</td><td>: The flash address where the data is copied to. Must be page (64 bytes) aligned. </td></tr>
    <tr><td class="paramname">size</td><td>: Number of bytes to be copied from RAM to flash. Must be multiple of 64. </td></tr>
    <tr><td class="paramname">kHzSysClk</td><td>: The actual CPU clock speed in kHz. This parameter will be ignored for chips without external clock. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Result of the operation. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This API implements the IAP command "Copy RAM to Flash" listed in user manual. </dd>
<dd>
The involved pages (or sectors) must be erased before this function is called, unless partial page write is intended (see note below). </dd>
<dd>
If partial page writes are intended:<ul>
<li>User needs to ensure that the region of the page to be written is previously erased (all 0xFFs)</li>
<li>User needs to ensure that the region of the page to be left untouched is overwritten with the same data or with all 0xFFs</li>
<li>User needs to ensure that partial writes are always in a word boundary (the content of one word shall not be written more than once after erasing)</li>
</ul>
Typical flow:<ol type="1">
<li>Erase page (content is FFFFFFFF FFFFFFFF ... FFFFFFFF)</li>
<li>Write first word 0x01234567 by writing "01234567 FFFFFFFF ... FFFFFFFF" (content becomes 01234567 FFFFFFFF ... FFFFFFFF)</li>
<li>Write second word 0x89ABCDEF by either:<ul>
<li>writing "FFFFFFFF 89ABCDEF ... FFFFFFFF", or</li>
<li>writing "01234567 89ABCDEF ... FFFFFFFF" (content becomes 01234567 89ABCDEF ... FFFFFFFF)</li>
</ul>
</li>
</ol>
Writing to the first and second word after this flow requires a new erase procedure, but writing words 3 to 16 not. </dd>
<dd>
Please keep the claimed RAM area untouched. Refer to user manual for more details. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>If the Interrupt Vector Table is placed in Flash (default setup) disable all interrupts: <a class="el" href="a00448.html#ga092b96b23f27f6b4258ce84add3b1528" title="Disable IRQ Interrupts. ">__disable_irq(void)</a> </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>If interrupts were disabled, enable them again: <a class="el" href="a00448.html#ga6fea83fe11c9a07924fb1ef316a9c76c" title="Enable IRQ Interrupts. ">__enable_irq(void)</a> </dd></dl>

</div>
</div>
<a id="ga44bd48c7813e360d66de6184d414fd89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga44bd48c7813e360d66de6184d414fd89">&#9670;&nbsp;</a></span>Chip_IAP_Flash_SectorBlankCheck()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00455.html#ga730c525085067a5f69a1029de14003ff">IAP_STATUS_T</a> Chip_IAP_Flash_SectorBlankCheck </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>sectorStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>sectorEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>pOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>pContent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Blank check on flash sectors </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sectorStart</td><td>: The first sector to be checked. </td></tr>
    <tr><td class="paramname">sectorEnd</td><td>: The last sector to be checked. </td></tr>
    <tr><td class="paramname">pOffset</td><td>: output parameter with the (word) offset for the first non-blank word; when the result is <a class="el" href="a00455.html#gga730c525085067a5f69a1029de14003ffa1aa4d4374cc563962ddfee6f1b7d9c58">IAP_STATUS_SECTOR_NOT_BLANK</a> . </td></tr>
    <tr><td class="paramname">pContent</td><td>: output parameter with the value of the first non-blank word; when the result is <a class="el" href="a00455.html#gga730c525085067a5f69a1029de14003ffa1aa4d4374cc563962ddfee6f1b7d9c58">IAP_STATUS_SECTOR_NOT_BLANK</a> . </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Result of the operation. </dd></dl>
<dl class="section note"><dt>Note</dt><dd><code>pOffset</code> and/or <code>pContent</code> may be <code>NULL</code>. In that case, offset and/or content are not reported, but the function still performs. </dd></dl>

</div>
</div>
<a id="gadeed0ce03e9ba7db17dc40b354e2f9b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadeed0ce03e9ba7db17dc40b354e2f9b9">&#9670;&nbsp;</a></span>Chip_IAP_Compare()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00455.html#ga730c525085067a5f69a1029de14003ff">IAP_STATUS_T</a> Chip_IAP_Compare </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>pAddress1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>pAddress2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>pOffset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compare two memory spaces to find out if their contents are same. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pAddress1</td><td>: The start address of the memory block to be compared. Must be word (32 bits) aligned. </td></tr>
    <tr><td class="paramname">pAddress2</td><td>: The start address of the memory block to compare with. Must be word (32 bits) aligned. </td></tr>
    <tr><td class="paramname">size</td><td>: Number of bytes to be compared. Must be multiple of 4. </td></tr>
    <tr><td class="paramname">pOffset</td><td>: The output parameter with the (word) offset for the first unequal words; when the compare result is <a class="el" href="a00455.html#gga730c525085067a5f69a1029de14003ffa8071b8a191f91c17472c141fd313fcf1">IAP_STATUS_COMPARE_ERROR</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Result of the operation. </dd></dl>
<dl class="section note"><dt>Note</dt><dd><code>pOffset</code> may be <code>NULL</code>. In that case, offset is not reported, but the function still performs. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Tue Oct 20 2020 08:24:34 for NHS31xx SW API by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.14 </li>
  </ul>
</div>
</body>
</html>
