<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NHS31xx SW API: rtc: Real-Time Clock driver</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="nxp-logo_small.jpg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NHS31xx SW API
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('a00459.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">rtc: Real-Time Clock driver<div class="ingroups"><a class="el" href="a00427.html">Drivers</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>The Real-Time Clock (RTC) module has two main features: </p><dl>
<dt>Time up-counter  </dt>
<dd>This records the time (e.g. seconds since epoch, which can be converted in year/month/day, hour/minute/second). </dd>
<dt>Wake-up down-counter  </dt>
<dd>This counter counts down to zero and can 'wake-up' the chip from standby modes: Sleep, Deep Sleep and Deep Power Down.</dd>
</dl>
<p>Both the counters step on a "tick". A tick consists of a number of TFRO pulses. The TFRO is calibrated during production to run at about 32768 Hz on reset, one tick is typically about 32768 TFRO pulses and thus 1 second. The exact number of TFRO clocks to make 1 second is loaded during boot time and stored in the RTCCAL register. Both the TFRO oscillator and the RTC HW block are part of the always-on power domain.</p>
<dl class="section user"><dt>Time up-counter</dt><dd>As soon as the TFRO is connected, the up-counter starts incrementing. This happens independently from the power mode and the ARM state. See <a class="el" href="a00458.html">pmu: Power Management Unit driver</a> for details on TFRO configuration.</dd></dl>
<dl class="section user"><dt>Wake-up down-counter</dt><dd>The down-counter is by default disabled. It needs to be explicitly enabled and started in order to count. When active, the counter counts down, independently from the power mode and the ARM state. When the down-counter reaches zero, a wake-up event is generated. This allows the chip to 'wake-up' from Sleep, Deep Sleep, and Deep Power Down.</dd></dl>
<dl class="section user"><dt></dt><dd>In Deep Power Down mode, the IC will wake up unconditionally when the down-counter reaches zero. It is not required to configure the NVIC and or any other start logic for waking up from the Deep Power Down mode. A reset signal is generated and a full boot process is run. SW execution is <em>not</em> resumed, and no interrupt function is called. The application can instead check at startup whether the <a class="el" href="a00458.html#ggad4c5057187d94a4ef13f01ebb8b4a731a5196c81200aee598f1847e1efdac698d">PMU_DPD_WAKEUPREASON_RTC</a> flag is set.</dd></dl>
<dl class="section user"><dt></dt><dd>In other modes (Active, Sleep, Deep Sleep), when the down-counter reaches zero, an RTC interrupt is generated that forks to two slots in the NVIC: the standard RTC peripheral interrupt <a class="el" href="a00435.html#gga7e1129cd8a196f4284d41db3e82ad5c8adcc0f2770f7f57f75fac3d8bcac0e858">RTC_IRQn</a> and the secondary interrupt <a class="el" href="a00435.html#gga7e1129cd8a196f4284d41db3e82ad5c8acb78595213a93320c69323a72a020572">RTCPWREQ_IRQn</a> via Start Logic. <br />
 See <a class="el" href="a00446.html">NVIC API</a> and <a class="el" href="a00461.html#startLogic_anchor">System wake-up start logic</a> for more details.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>There can be other 'wake-up' reasons from various standby modes. See <a class="el" href="a00458.html">pmu: Power Management Unit driver</a> for details.</dd></dl>
<dl class="section user"><dt>In order to operate the RTC module</dt><dd><ul>
<li>up-counter: <a class="el" href="a00459.html#ga454781d125e16d730581d8a9ef42eea9">Chip_RTC_Time_GetValue</a> and <a class="el" href="a00459.html#gacc9b42f869a58aa0c5072677543c0d03">Chip_RTC_Time_SetValue</a> provide R/W access.</li>
<li>down-counter:<ol type="1">
<li>Use <a class="el" href="a00459.html#ga4428e6f8613fdf5f298563c659b8c2f2">Chip_RTC_Wakeup_SetControl</a> to operate the down-counter.</li>
<li>Use <a class="el" href="a00459.html#ga70e595639e1113b7979dd0dd951fc0b0">Chip_RTC_Wakeup_SetReload</a> to configure the down-counter.</li>
<li>Set <a class="el" href="a00459.html#ggacd51ff9a80124d48dd3565b4f1ab7befabd7bb1eabe82266e61bf43f6ab02d678">RTC_INT_WAKEUP</a> with <a class="el" href="a00459.html#ga9bd47669775fb500740fe0514e8497ef">Chip_RTC_Int_SetEnabledMask</a> to enable</li>
<li>Additional steps are necessary to operate the down-counter function with various states of standby. See the examples below.</li>
</ol>
</li>
</ul>
<a class="anchor" id="RTC_WARNING"></a></dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Each RTC block register read and write action requires at least one <code>wait</code> period. A single wait period can take up to 100us to complete due to hardware synchronization within the module. All functions in this driver make at least one such register access unless stated otherwise. This impacts performance and should be taken into account, especially when calling RTC driver functions in an interrupt context. If an RTC block register read/write preempts another RTC block register read/write, the procedure is repeated leading to another <code>wait</code> period, until no preemption is detected.</dd></dl>
<dl class="section user"><dt>Example 1 - RTC down-counter: wake-up from Sleep Mode</dt><dd><br />
 Initialization (once): <div class="fragment"><div class="line">    <a class="code" href="a00459.html#gab6b99630837bc371be71b12e45d9972c">Chip_RTC_Init</a>(<a class="code" href="a00433.html#ga0ac2db8886b6fc2962d0919d77089bb7">NSS_RTC</a>);</div><div class="line">    <a class="code" href="a00459.html#ga4428e6f8613fdf5f298563c659b8c2f2">Chip_RTC_Wakeup_SetControl</a>(<a class="code" href="a00433.html#ga0ac2db8886b6fc2962d0919d77089bb7">NSS_RTC</a>, <a class="code" href="a00459.html#ggaecca952591fa1f2ceaec56d6658f5a71a807302a07c800fbc5b0f850bc6c6100f">RTC_WAKEUPCTRL_ENABLE</a> | <a class="code" href="a00459.html#ggaecca952591fa1f2ceaec56d6658f5a71a5ab3f3142659cbe6d6e6f036a3b933d9">RTC_WAKEUPCTRL_AUTO</a>);</div><div class="line">    <a class="code" href="a00459.html#ga9bd47669775fb500740fe0514e8497ef">Chip_RTC_Int_SetEnabledMask</a>(<a class="code" href="a00433.html#ga0ac2db8886b6fc2962d0919d77089bb7">NSS_RTC</a>, <a class="code" href="a00459.html#ggacd51ff9a80124d48dd3565b4f1ab7befabd7bb1eabe82266e61bf43f6ab02d678">RTC_INT_WAKEUP</a>);</div><div class="line">    <a class="code" href="a00446.html#gaa7a55182d0998e1ea13efd6875167cf0">NVIC_EnableIRQ</a>(<a class="code" href="a00435.html#gga7e1129cd8a196f4284d41db3e82ad5c8adcc0f2770f7f57f75fac3d8bcac0e858">RTC_IRQn</a>);</div></div><!-- fragment --> <br />
 Activation: <div class="fragment"><div class="line">    <a class="code" href="a00459.html#ga70e595639e1113b7979dd0dd951fc0b0">Chip_RTC_Wakeup_SetReload</a>(<a class="code" href="a00433.html#ga0ac2db8886b6fc2962d0919d77089bb7">NSS_RTC</a>, 10);</div><div class="line">    <a class="code" href="a00458.html#gaf9474d0c37f1179ebe0edf523883452c">Chip_PMU_PowerMode_EnterSleep</a>();</div><div class="line">    <span class="comment">/* RTC_IRQHandler is called after 10 seconds. System resumes here after ISR has been serviced. */</span></div><div class="line">    <span class="comment">/* ... */</span></div></div><!-- fragment --> <br />
 RTC interrupt handling: <div class="fragment"><div class="line">    <span class="comment">/* To be called under interrupt from RTC_IRQHandler */</span></div><div class="line">    <span class="keywordflow">if</span> (<a class="code" href="a00459.html#gab3d7e4ae96507e384610f4f3fc027e24">Chip_RTC_Int_GetRawStatus</a>(<a class="code" href="a00433.html#ga0ac2db8886b6fc2962d0919d77089bb7">NSS_RTC</a>) &amp; <a class="code" href="a00459.html#ggacd51ff9a80124d48dd3565b4f1ab7befabd7bb1eabe82266e61bf43f6ab02d678">RTC_INT_WAKEUP</a>) {</div><div class="line">        <a class="code" href="a00459.html#ga8c3793cee7fa7a5e3705f741a1b37213">Chip_RTC_Int_ClearRawStatus</a>(<a class="code" href="a00433.html#ga0ac2db8886b6fc2962d0919d77089bb7">NSS_RTC</a>, <a class="code" href="a00459.html#ggacd51ff9a80124d48dd3565b4f1ab7befabd7bb1eabe82266e61bf43f6ab02d678">RTC_INT_WAKEUP</a>);</div><div class="line">        <span class="comment">/* Further handling of the event &quot;down-counter expired&quot;. */</span></div><div class="line">        <span class="comment">/* ... */</span></div><div class="line">    }</div></div><!-- fragment --> <br />
 </dd></dl>
<dl class="section user"><dt>Example 2 - RTC down-counter: wake-up from Deep Sleep Mode, and manual start.</dt><dd>This example is using <a class="el" href="a00461.html#startLogic_anchor">System wake-up start logic</a> <br />
 <br />
 Initialization (once): <div class="fragment"><div class="line">    <a class="code" href="a00459.html#gab6b99630837bc371be71b12e45d9972c">Chip_RTC_Init</a>(<a class="code" href="a00433.html#ga0ac2db8886b6fc2962d0919d77089bb7">NSS_RTC</a>);</div><div class="line">    <a class="code" href="a00459.html#ga4428e6f8613fdf5f298563c659b8c2f2">Chip_RTC_Wakeup_SetControl</a>(<a class="code" href="a00433.html#ga0ac2db8886b6fc2962d0919d77089bb7">NSS_RTC</a>, <a class="code" href="a00459.html#ggaecca952591fa1f2ceaec56d6658f5a71a807302a07c800fbc5b0f850bc6c6100f">RTC_WAKEUPCTRL_ENABLE</a>);</div><div class="line">    <a class="code" href="a00459.html#ga9bd47669775fb500740fe0514e8497ef">Chip_RTC_Int_SetEnabledMask</a>(<a class="code" href="a00433.html#ga0ac2db8886b6fc2962d0919d77089bb7">NSS_RTC</a>, <a class="code" href="a00459.html#ggacd51ff9a80124d48dd3565b4f1ab7befabd7bb1eabe82266e61bf43f6ab02d678">RTC_INT_WAKEUP</a>);</div><div class="line">    <a class="code" href="a00461.html#ga8ceb9924b91514247027ccf2be1d69bf">Chip_SysCon_StartLogic_SetEnabledMask</a>(<a class="code" href="a00461.html#ggab1048a7c8ccb3daa33dd8f0882a57599a37fc5a2f28f20cfe90c95a400f467aaf">SYSCON_STARTSOURCE_RTC</a>);</div><div class="line">    <a class="code" href="a00461.html#gac2f2f79c6e63321bfafaeb649032ce3b">Chip_SysCon_StartLogic_ClearStatus</a>(<a class="code" href="a00461.html#ga40de714649cdb7a7fd2c71980f708ce8">Chip_SysCon_StartLogic_GetEnabledMask</a>());</div><div class="line">    <a class="code" href="a00446.html#gaa7a55182d0998e1ea13efd6875167cf0">NVIC_EnableIRQ</a>(<a class="code" href="a00435.html#gga7e1129cd8a196f4284d41db3e82ad5c8acb78595213a93320c69323a72a020572">RTCPWREQ_IRQn</a>);</div></div><!-- fragment --> <br />
 Activation: <div class="fragment"><div class="line">    <a class="code" href="a00459.html#ga70e595639e1113b7979dd0dd951fc0b0">Chip_RTC_Wakeup_SetReload</a>(<a class="code" href="a00433.html#ga0ac2db8886b6fc2962d0919d77089bb7">NSS_RTC</a>, 10);</div><div class="line">    <span class="comment">/* When RTC_WAKEUPCTRL_AUTO is not set, RTC_WAKEUPCTRL_START is required to start the down-counter. */</span></div><div class="line">    <a class="code" href="a00459.html#ga4428e6f8613fdf5f298563c659b8c2f2">Chip_RTC_Wakeup_SetControl</a>(<a class="code" href="a00433.html#ga0ac2db8886b6fc2962d0919d77089bb7">NSS_RTC</a>, <a class="code" href="a00459.html#ggaecca952591fa1f2ceaec56d6658f5a71a807302a07c800fbc5b0f850bc6c6100f">RTC_WAKEUPCTRL_ENABLE</a> | <a class="code" href="a00459.html#ggaecca952591fa1f2ceaec56d6658f5a71a40b69dd87ccaf7c8b619b008876ffb3f">RTC_WAKEUPCTRL_START</a>);</div><div class="line">    <a class="code" href="a00458.html#gacee0d5eace81c8634b66862102478e6d">Chip_PMU_PowerMode_EnterDeepSleep</a>();</div><div class="line">    <span class="comment">/* RTC_IRQHandler is called after 10 seconds. System resumes here after ISR has been serviced. */</span></div><div class="line">    <span class="comment">/* ... */</span></div></div><!-- fragment --> <br />
 RTC interrupt handling: <div class="fragment"><div class="line">    <span class="comment">/* To be called under interrupt from RTCPWREQ_IRQHandler */</span></div><div class="line">    <span class="keywordflow">if</span> (<a class="code" href="a00461.html#ga680f64aaff0600e1386568f4be3a7218">Chip_SysCon_StartLogic_GetStatus</a>() &amp; <a class="code" href="a00461.html#ggab1048a7c8ccb3daa33dd8f0882a57599a37fc5a2f28f20cfe90c95a400f467aaf">SYSCON_STARTSOURCE_RTC</a>) {</div><div class="line">        <a class="code" href="a00461.html#gac2f2f79c6e63321bfafaeb649032ce3b">Chip_SysCon_StartLogic_ClearStatus</a>(<a class="code" href="a00461.html#ggab1048a7c8ccb3daa33dd8f0882a57599a37fc5a2f28f20cfe90c95a400f467aaf">SYSCON_STARTSOURCE_RTC</a>);</div><div class="line">        <span class="comment">/* Further handling of the event &quot;down-counter expired&quot;. */</span></div><div class="line">        <span class="comment">/* ... */</span></div><div class="line">    }</div></div><!-- fragment --> <br />
 </dd></dl>
<dl class="section user"><dt>Example 3 - RTC "wake-up down-counter" with Deep Power Down Mode</dt><dd><br />
 Initialization (once): <div class="fragment"><div class="line">    <span class="keywordflow">if</span> (<a class="code" href="a00458.html#gaef096829b6b4445cc6c006589aac0681">Chip_PMU_PowerMode_GetDPDWakeupReason</a>() == <a class="code" href="a00458.html#ggad4c5057187d94a4ef13f01ebb8b4a731a5196c81200aee598f1847e1efdac698d">PMU_DPD_WAKEUPREASON_RTC</a>) {</div><div class="line">        <span class="comment">/* Handling of the event &quot;down-counter expired&quot;. */</span></div><div class="line">        <span class="comment">/* ... */</span></div><div class="line">    }</div><div class="line">    <a class="code" href="a00459.html#gab6b99630837bc371be71b12e45d9972c">Chip_RTC_Init</a>(<a class="code" href="a00433.html#ga0ac2db8886b6fc2962d0919d77089bb7">NSS_RTC</a>);</div><div class="line">    <a class="code" href="a00459.html#ga4428e6f8613fdf5f298563c659b8c2f2">Chip_RTC_Wakeup_SetControl</a>(<a class="code" href="a00433.html#ga0ac2db8886b6fc2962d0919d77089bb7">NSS_RTC</a>, <a class="code" href="a00459.html#ggaecca952591fa1f2ceaec56d6658f5a71a807302a07c800fbc5b0f850bc6c6100f">RTC_WAKEUPCTRL_ENABLE</a> | <a class="code" href="a00459.html#ggaecca952591fa1f2ceaec56d6658f5a71a5ab3f3142659cbe6d6e6f036a3b933d9">RTC_WAKEUPCTRL_AUTO</a>);</div></div><!-- fragment --> <br />
 Activation: <div class="fragment"><div class="line">    <a class="code" href="a00459.html#ga70e595639e1113b7979dd0dd951fc0b0">Chip_RTC_Wakeup_SetReload</a>(<a class="code" href="a00433.html#ga0ac2db8886b6fc2962d0919d77089bb7">NSS_RTC</a>, 10);</div><div class="line">    <a class="code" href="a00458.html#ga1af1ed037e3824d314f7a01649cf2800">Chip_PMU_PowerMode_EnterDeepPowerDown</a>(<span class="keyword">false</span>);</div><div class="line">    <a class="code" href="a00433.html#ga28301f76c53b643912da7c538f74e2c6">ASSERT</a>(<span class="keyword">false</span>); <span class="comment">/* System does not resume here. Unreachable. */</span></div></div><!-- fragment --> <br />
 RTC interrupt service routine will not be called as NVIC is not active during Deep Power Down mode. </dd></dl>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:a00662"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00459.html#a00662">NSS_RTC_T</a></td></tr>
<tr class="separator:a00662"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gaecca952591fa1f2ceaec56d6658f5a71"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00459.html#gaecca952591fa1f2ceaec56d6658f5a71">RTC_WAKEUPCTRL_T</a> { <br />
&#160;&#160;<a class="el" href="a00459.html#ggaecca952591fa1f2ceaec56d6658f5a71a807302a07c800fbc5b0f850bc6c6100f">RTC_WAKEUPCTRL_ENABLE</a> = (1 &lt;&lt; 0), 
<br />
&#160;&#160;<a class="el" href="a00459.html#ggaecca952591fa1f2ceaec56d6658f5a71a5ab3f3142659cbe6d6e6f036a3b933d9">RTC_WAKEUPCTRL_AUTO</a> = (1 &lt;&lt; 1), 
<br />
&#160;&#160;<a class="el" href="a00459.html#ggaecca952591fa1f2ceaec56d6658f5a71a40b69dd87ccaf7c8b619b008876ffb3f">RTC_WAKEUPCTRL_START</a> = (1 &lt;&lt; 2), 
<br />
&#160;&#160;<a class="el" href="a00459.html#ggaecca952591fa1f2ceaec56d6658f5a71a9b70cca00c3f44b808027cefa32da5cb">RTC_WAKEUPCTRL_DISABLE</a> = 0
<br />
 }</td></tr>
<tr class="separator:gaecca952591fa1f2ceaec56d6658f5a71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd51ff9a80124d48dd3565b4f1ab7bef"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00459.html#gacd51ff9a80124d48dd3565b4f1ab7bef">RTC_INT_T</a> { <br />
&#160;&#160;<a class="el" href="a00459.html#ggacd51ff9a80124d48dd3565b4f1ab7befabd7bb1eabe82266e61bf43f6ab02d678">RTC_INT_WAKEUP</a> = (1 &lt;&lt; 0), 
<br />
&#160;&#160;<a class="el" href="a00459.html#ggacd51ff9a80124d48dd3565b4f1ab7befa83ed18d726d010f0d4787fe6a4dc6455">RTC_INT_ALL</a> = 0x01, 
<br />
&#160;&#160;<a class="el" href="a00459.html#ggacd51ff9a80124d48dd3565b4f1ab7befa345674b0e128b417b89fa15f6920b02c">RTC_INT_NONE</a> = 0
<br />
 }</td></tr>
<tr class="separator:gacd51ff9a80124d48dd3565b4f1ab7bef"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gab6b99630837bc371be71b12e45d9972c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00459.html#gab6b99630837bc371be71b12e45d9972c">Chip_RTC_Init</a> (<a class="el" href="a00459.html#a00662">NSS_RTC_T</a> *pRTC)</td></tr>
<tr class="separator:gab6b99630837bc371be71b12e45d9972c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6aa5c2fbc6ab66d6a9682d7bb29b670e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00459.html#ga6aa5c2fbc6ab66d6a9682d7bb29b670e">Chip_RTC_DeInit</a> (<a class="el" href="a00459.html#a00662">NSS_RTC_T</a> *pRTC)</td></tr>
<tr class="separator:ga6aa5c2fbc6ab66d6a9682d7bb29b670e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92bd08679d14bccd760d4d5dda26bf2e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00459.html#ga92bd08679d14bccd760d4d5dda26bf2e">Chip_RTC_SetCalibration</a> (<a class="el" href="a00459.html#a00662">NSS_RTC_T</a> *pRTC, int calibValue)</td></tr>
<tr class="separator:ga92bd08679d14bccd760d4d5dda26bf2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb189d9ce6e3848de2b38f8a47df0e8c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00459.html#gaeb189d9ce6e3848de2b38f8a47df0e8c">Chip_RTC_GetCalibration</a> (<a class="el" href="a00459.html#a00662">NSS_RTC_T</a> *pRTC)</td></tr>
<tr class="separator:gaeb189d9ce6e3848de2b38f8a47df0e8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4428e6f8613fdf5f298563c659b8c2f2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00459.html#ga4428e6f8613fdf5f298563c659b8c2f2">Chip_RTC_Wakeup_SetControl</a> (<a class="el" href="a00459.html#a00662">NSS_RTC_T</a> *pRTC, <a class="el" href="a00459.html#gaecca952591fa1f2ceaec56d6658f5a71">RTC_WAKEUPCTRL_T</a> control)</td></tr>
<tr class="separator:ga4428e6f8613fdf5f298563c659b8c2f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga31858360ef4fa6a85446d064fa3b5146"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00459.html#gaecca952591fa1f2ceaec56d6658f5a71">RTC_WAKEUPCTRL_T</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00459.html#ga31858360ef4fa6a85446d064fa3b5146">Chip_RTC_Wakeup_GetControl</a> (<a class="el" href="a00459.html#a00662">NSS_RTC_T</a> *pRTC)</td></tr>
<tr class="separator:ga31858360ef4fa6a85446d064fa3b5146"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga70e595639e1113b7979dd0dd951fc0b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00459.html#ga70e595639e1113b7979dd0dd951fc0b0">Chip_RTC_Wakeup_SetReload</a> (<a class="el" href="a00459.html#a00662">NSS_RTC_T</a> *pRTC, int ticks)</td></tr>
<tr class="separator:ga70e595639e1113b7979dd0dd951fc0b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga500d57348b3bb6f30674db693dbf43f9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00459.html#ga500d57348b3bb6f30674db693dbf43f9">Chip_RTC_Wakeup_GetReload</a> (<a class="el" href="a00459.html#a00662">NSS_RTC_T</a> *pRTC)</td></tr>
<tr class="separator:ga500d57348b3bb6f30674db693dbf43f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa12c427041298fc8ce3d27de085892ea"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00459.html#gaa12c427041298fc8ce3d27de085892ea">Chip_RTC_Wakeup_GetRemaining</a> (<a class="el" href="a00459.html#a00662">NSS_RTC_T</a> *pRTC)</td></tr>
<tr class="separator:gaa12c427041298fc8ce3d27de085892ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9912d1de565665113c15bf3e36cc2331"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00459.html#ga9912d1de565665113c15bf3e36cc2331">Chip_RTC_Wakeup_IsRunning</a> (<a class="el" href="a00459.html#a00662">NSS_RTC_T</a> *pRTC)</td></tr>
<tr class="separator:ga9912d1de565665113c15bf3e36cc2331"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga454781d125e16d730581d8a9ef42eea9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00459.html#ga454781d125e16d730581d8a9ef42eea9">Chip_RTC_Time_GetValue</a> (<a class="el" href="a00459.html#a00662">NSS_RTC_T</a> *pRTC)</td></tr>
<tr class="separator:ga454781d125e16d730581d8a9ef42eea9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc9b42f869a58aa0c5072677543c0d03"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00459.html#gacc9b42f869a58aa0c5072677543c0d03">Chip_RTC_Time_SetValue</a> (<a class="el" href="a00459.html#a00662">NSS_RTC_T</a> *pRTC, int tickValue)</td></tr>
<tr class="separator:gacc9b42f869a58aa0c5072677543c0d03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9bd47669775fb500740fe0514e8497ef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00459.html#ga9bd47669775fb500740fe0514e8497ef">Chip_RTC_Int_SetEnabledMask</a> (<a class="el" href="a00459.html#a00662">NSS_RTC_T</a> *pRTC, <a class="el" href="a00459.html#gacd51ff9a80124d48dd3565b4f1ab7bef">RTC_INT_T</a> mask)</td></tr>
<tr class="separator:ga9bd47669775fb500740fe0514e8497ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ad25b91c3dec03093d3e6ef02428047"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00459.html#gacd51ff9a80124d48dd3565b4f1ab7bef">RTC_INT_T</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00459.html#ga4ad25b91c3dec03093d3e6ef02428047">Chip_RTC_Int_GetEnabledMask</a> (<a class="el" href="a00459.html#a00662">NSS_RTC_T</a> *pRTC)</td></tr>
<tr class="separator:ga4ad25b91c3dec03093d3e6ef02428047"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3d7e4ae96507e384610f4f3fc027e24"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00459.html#gacd51ff9a80124d48dd3565b4f1ab7bef">RTC_INT_T</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00459.html#gab3d7e4ae96507e384610f4f3fc027e24">Chip_RTC_Int_GetRawStatus</a> (<a class="el" href="a00459.html#a00662">NSS_RTC_T</a> *pRTC)</td></tr>
<tr class="separator:gab3d7e4ae96507e384610f4f3fc027e24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c3793cee7fa7a5e3705f741a1b37213"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00459.html#ga8c3793cee7fa7a5e3705f741a1b37213">Chip_RTC_Int_ClearRawStatus</a> (<a class="el" href="a00459.html#a00662">NSS_RTC_T</a> *pRTC, <a class="el" href="a00459.html#gacd51ff9a80124d48dd3565b4f1ab7bef">RTC_INT_T</a> flags)</td></tr>
<tr class="separator:ga8c3793cee7fa7a5e3705f741a1b37213"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<hr/><h2 class="groupheader">Data Structure Documentation</h2>
<a name="a00662" id="a00662"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00662">&#9670;&nbsp;</a></span>NSS_RTC_T</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct NSS_RTC_T</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>RTC block register block structure </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="afa8ba49c3c8db3ed2d7f4312226bad5e"></a>volatile uint32_t</td>
<td class="fieldname">
CR</td>
<td class="fielddoc">
<p>&lt; Defines 'read / write' permissions Control register </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a5741cf0a79a57f81c828b29660b55d35"></a>volatile uint32_t</td>
<td class="fieldname">
SR</td>
<td class="fielddoc">
<p>&lt; Defines 'read / write' permissions Status register </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a0fc80d07ea056c518b5eb00a49d4be9a"></a>volatile uint32_t</td>
<td class="fieldname">
CAL</td>
<td class="fielddoc">
<p>&lt; Defines 'read / write' permissions TFRO counts per 'tick' calibration value </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a979728bd3e884ebb4b8d65ca827ac608"></a>volatile uint32_t</td>
<td class="fieldname">
SLEEPT</td>
<td class="fielddoc">
<p>&lt; Defines 'read / write' permissions "Wake-up down-counter" tick value - Amount of ticks until a 'wake-up' event </p>
</td></tr>
<tr><td class="fieldtype">
<a id="acdec94fdddcdf5a2a7879d3ca67d91dc"></a>volatile const uint32_t</td>
<td class="fieldname">
VAL</td>
<td class="fielddoc">
<p>&lt; Defines 'read only' permissions Current (remaining) "wake-up down-counter" tick value </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a34b7adaa723c3aae160e468a94e78b6e"></a>volatile uint32_t</td>
<td class="fieldname">
IMSC</td>
<td class="fielddoc">
<p>&lt; Defines 'read / write' permissions Interrupt mask set/clear register - Enable/disable interrupt </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a631dd6cb258aef79568fcda472b79396"></a>volatile const uint32_t</td>
<td class="fieldname">
RIS</td>
<td class="fielddoc">
<p>&lt; Defines 'read only' permissions Raw Interrupt status register </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a354e7f9dd445f1733f221906139846cb"></a>volatile const uint32_t</td>
<td class="fieldname">
MIS</td>
<td class="fielddoc">
<p>&lt; Defines 'read only' permissions Masked interrupt status register </p>
</td></tr>
<tr><td class="fieldtype">
<a id="acf6b4a0bddd951d73a63bc8fa863c26f"></a>volatile uint32_t</td>
<td class="fieldname">
ICR</td>
<td class="fielddoc">
<p>&lt; Defines 'write only' permissions Interrupt clear register </p>
</td></tr>
<tr><td class="fieldtype">
<a id="aa82f94b583e98879bb55155693404d2e"></a>volatile const uint32_t</td>
<td class="fieldname">
ACCSTAT</td>
<td class="fielddoc">
<p>&lt; Defines 'read only' permissions Access status register </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a72558984417c249d34c5bb86d256e9ac"></a>volatile const uint32_t</td>
<td class="fieldname">
RESERVED[2]</td>
<td class="fielddoc">
<p>&lt; Defines 'read only' permissions </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a75c15929532badeb31e5af63f2556745"></a>volatile uint32_t</td>
<td class="fieldname">
TIME</td>
<td class="fielddoc">
<p>&lt; Defines 'read / write' permissions Real-time clock "time up-counter" value </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="gaecca952591fa1f2ceaec56d6658f5a71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaecca952591fa1f2ceaec56d6658f5a71">&#9670;&nbsp;</a></span>RTC_WAKEUPCTRL_T</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="a00459.html#gaecca952591fa1f2ceaec56d6658f5a71">RTC_WAKEUPCTRL_T</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>RTC "wake-up down-counter" control. For use with <a class="el" href="a00459.html#ga4428e6f8613fdf5f298563c659b8c2f2">Chip_RTC_Wakeup_SetControl</a> and <a class="el" href="a00459.html#ga31858360ef4fa6a85446d064fa3b5146">Chip_RTC_Wakeup_GetControl</a> </p><dl class="section note"><dt>Note</dt><dd><ul>
<li>Counting of the "Wake-up down-counter" is enabled when control field is:<ul>
<li><a class="el" href="a00459.html#ggaecca952591fa1f2ceaec56d6658f5a71a807302a07c800fbc5b0f850bc6c6100f">RTC_WAKEUPCTRL_ENABLE</a> | <a class="el" href="a00459.html#ggaecca952591fa1f2ceaec56d6658f5a71a5ab3f3142659cbe6d6e6f036a3b933d9">RTC_WAKEUPCTRL_AUTO</a></li>
<li><a class="el" href="a00459.html#ggaecca952591fa1f2ceaec56d6658f5a71a807302a07c800fbc5b0f850bc6c6100f">RTC_WAKEUPCTRL_ENABLE</a> | <a class="el" href="a00459.html#ggaecca952591fa1f2ceaec56d6658f5a71a40b69dd87ccaf7c8b619b008876ffb3f">RTC_WAKEUPCTRL_START</a></li>
</ul>
</li>
<li>Clearing <a class="el" href="a00459.html#ggaecca952591fa1f2ceaec56d6658f5a71a807302a07c800fbc5b0f850bc6c6100f">RTC_WAKEUPCTRL_ENABLE</a> halts the "wake-up down-counter"</li>
<li>When <a class="el" href="a00459.html#ggaecca952591fa1f2ceaec56d6658f5a71a5ab3f3142659cbe6d6e6f036a3b933d9">RTC_WAKEUPCTRL_AUTO</a> is set, <a class="el" href="a00459.html#ggaecca952591fa1f2ceaec56d6658f5a71a40b69dd87ccaf7c8b619b008876ffb3f">RTC_WAKEUPCTRL_START</a> is ignored</li>
<li>When <a class="el" href="a00459.html#ggaecca952591fa1f2ceaec56d6658f5a71a5ab3f3142659cbe6d6e6f036a3b933d9">RTC_WAKEUPCTRL_AUTO</a> is cleared, loading a new value with <a class="el" href="a00459.html#ga70e595639e1113b7979dd0dd951fc0b0">Chip_RTC_Wakeup_SetReload</a> clears <a class="el" href="a00459.html#ggaecca952591fa1f2ceaec56d6658f5a71a40b69dd87ccaf7c8b619b008876ffb3f">RTC_WAKEUPCTRL_START</a>, and halts counting of the "Wake-up down-counter".</li>
</ul>
</dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggaecca952591fa1f2ceaec56d6658f5a71a807302a07c800fbc5b0f850bc6c6100f"></a>RTC_WAKEUPCTRL_ENABLE&#160;</td><td class="fielddoc"><p>Enables "wake-up down-counter" </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaecca952591fa1f2ceaec56d6658f5a71a5ab3f3142659cbe6d6e6f036a3b933d9"></a>RTC_WAKEUPCTRL_AUTO&#160;</td><td class="fielddoc"><p>Enables the automatic start/restart of the "wake-up down-counter", each time a tick value is written in <a class="el" href="a00459.html#a979728bd3e884ebb4b8d65ca827ac608">NSS_RTC_T.SLEEPT</a> with <a class="el" href="a00459.html#ga70e595639e1113b7979dd0dd951fc0b0">Chip_RTC_Wakeup_SetReload()</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaecca952591fa1f2ceaec56d6658f5a71a40b69dd87ccaf7c8b619b008876ffb3f"></a>RTC_WAKEUPCTRL_START&#160;</td><td class="fielddoc"><p>Starts counting of "wake-up down-counter" with tick value loaded with <a class="el" href="a00459.html#ga70e595639e1113b7979dd0dd951fc0b0">Chip_RTC_Wakeup_SetReload</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaecca952591fa1f2ceaec56d6658f5a71a9b70cca00c3f44b808027cefa32da5cb"></a>RTC_WAKEUPCTRL_DISABLE&#160;</td><td class="fielddoc"><p>Disables "wake-up down-counter" and stops counting </p>
</td></tr>
</table>

</div>
</div>
<a id="gacd51ff9a80124d48dd3565b4f1ab7bef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacd51ff9a80124d48dd3565b4f1ab7bef">&#9670;&nbsp;</a></span>RTC_INT_T</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="a00459.html#gacd51ff9a80124d48dd3565b4f1ab7bef">RTC_INT_T</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>RTC block interrupt bitfields </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggacd51ff9a80124d48dd3565b4f1ab7befabd7bb1eabe82266e61bf43f6ab02d678"></a>RTC_INT_WAKEUP&#160;</td><td class="fielddoc"><p>"wake-up down-counter" has reached 0 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggacd51ff9a80124d48dd3565b4f1ab7befa83ed18d726d010f0d4787fe6a4dc6455"></a>RTC_INT_ALL&#160;</td><td class="fielddoc"><p>All RTC interrupt bits </p>
</td></tr>
<tr><td class="fieldname"><a id="ggacd51ff9a80124d48dd3565b4f1ab7befa345674b0e128b417b89fa15f6920b02c"></a>RTC_INT_NONE&#160;</td><td class="fielddoc"><p>No RTC interrupt </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gab6b99630837bc371be71b12e45d9972c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab6b99630837bc371be71b12e45d9972c">&#9670;&nbsp;</a></span>Chip_RTC_Init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Chip_RTC_Init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00459.html#a00662">NSS_RTC_T</a> *&#160;</td>
          <td class="paramname"><em>pRTC</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enables ARM access to RTC block via APB bus </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pRTC</td><td>: The base address of the RTC peripheral on the chip </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This RTC driver requires that TFRO clock connection to RTC is enabled. TFRO is connected to RTC by default after a full-system reset. </dd></dl>

</div>
</div>
<a id="ga6aa5c2fbc6ab66d6a9682d7bb29b670e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6aa5c2fbc6ab66d6a9682d7bb29b670e">&#9670;&nbsp;</a></span>Chip_RTC_DeInit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Chip_RTC_DeInit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00459.html#a00662">NSS_RTC_T</a> *&#160;</td>
          <td class="paramname"><em>pRTC</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Halts the counting of "wake-up down-counter" and disables ARM access to RTC block via APB bus.<br />
This function:</p><ol type="1">
<li>Disables "wake-up down-counter" operation</li>
<li>Disables "wake-up down-counter" interrupt</li>
<li>Disables ARM access to RTC block via APB clock</li>
</ol>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pRTC</td><td>: The base address of the RTC peripheral on the chip </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>This function performs two synchronized register accesses. Impact on runtime performance and other same and lower-priority contexts should be carefully considered. See <a class="el" href="a00459.html#RTC_WARNING">warning section</a>. </dd></dl>

</div>
</div>
<a id="ga92bd08679d14bccd760d4d5dda26bf2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga92bd08679d14bccd760d4d5dda26bf2e">&#9670;&nbsp;</a></span>Chip_RTC_SetCalibration()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Chip_RTC_SetCalibration </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00459.html#a00662">NSS_RTC_T</a> *&#160;</td>
          <td class="paramname"><em>pRTC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>calibValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the number of TFRO clock pulses in one RTC 'tick' </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pRTC</td><td>: The base address of the RTC peripheral on the chip </td></tr>
    <tr><td class="paramname">calibValue</td><td>16-bit value indicating the number of TFRO clock pulses in one tick. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>This function performs a synchronized register access. Impact on runtime performance and other same and lower-priority contexts should be carefully considered. See <a class="el" href="a00459.html#RTC_WARNING">warning section</a>. </dd></dl>

</div>
</div>
<a id="gaeb189d9ce6e3848de2b38f8a47df0e8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeb189d9ce6e3848de2b38f8a47df0e8c">&#9670;&nbsp;</a></span>Chip_RTC_GetCalibration()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Chip_RTC_GetCalibration </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00459.html#a00662">NSS_RTC_T</a> *&#160;</td>
          <td class="paramname"><em>pRTC</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the number of TFRO clock pulses in one RTC 'tick' </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pRTC</td><td>: The base address of the RTC peripheral on the chip </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>16-bit value indicating the number of TFRO clock pulses in one tick. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function performs a synchronized register access. Impact on runtime performance and other same and lower-priority contexts should be carefully considered. See <a class="el" href="a00459.html#RTC_WARNING">warning section</a>. </dd></dl>

</div>
</div>
<a id="ga4428e6f8613fdf5f298563c659b8c2f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4428e6f8613fdf5f298563c659b8c2f2">&#9670;&nbsp;</a></span>Chip_RTC_Wakeup_SetControl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Chip_RTC_Wakeup_SetControl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00459.html#a00662">NSS_RTC_T</a> *&#160;</td>
          <td class="paramname"><em>pRTC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00459.html#gaecca952591fa1f2ceaec56d6658f5a71">RTC_WAKEUPCTRL_T</a>&#160;</td>
          <td class="paramname"><em>control</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Controls the operation of "wake-up down-counter" </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pRTC</td><td>: The base address of the RTC peripheral on the chip </td></tr>
    <tr><td class="paramname">control</td><td>: Bitfield of Control Mode of type <a class="el" href="a00459.html#gaecca952591fa1f2ceaec56d6658f5a71">RTC_WAKEUPCTRL_T</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00459.html#gaecca952591fa1f2ceaec56d6658f5a71">RTC_WAKEUPCTRL_T</a> for operation details </dd></dl>
<dl class="section note"><dt>Note</dt><dd>RTC interrupt MUST be enabled to wake up from various standby modes (Sleep/Deep Sleep/Deep Power Down). </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function performs a synchronized register access. Impact on runtime performance and other same and lower-priority contexts should be carefully considered. See <a class="el" href="a00459.html#RTC_WARNING">warning section</a>. </dd></dl>

</div>
</div>
<a id="ga31858360ef4fa6a85446d064fa3b5146"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga31858360ef4fa6a85446d064fa3b5146">&#9670;&nbsp;</a></span>Chip_RTC_Wakeup_GetControl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00459.html#gaecca952591fa1f2ceaec56d6658f5a71">RTC_WAKEUPCTRL_T</a> Chip_RTC_Wakeup_GetControl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00459.html#a00662">NSS_RTC_T</a> *&#160;</td>
          <td class="paramname"><em>pRTC</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the control register of the "wake-up down-counter" operation </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pRTC</td><td>: The base address of the RTC peripheral on the chip </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bitfield of Control state. </dd></dl>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="a00459.html#ggaecca952591fa1f2ceaec56d6658f5a71a40b69dd87ccaf7c8b619b008876ffb3f">RTC_WAKEUPCTRL_START</a> bit is cleared when "wake-up down-counter" reaches zero, or when a new tick is loaded with <a class="el" href="a00459.html#ga70e595639e1113b7979dd0dd951fc0b0">Chip_RTC_Wakeup_SetReload</a> without <a class="el" href="a00459.html#ggaecca952591fa1f2ceaec56d6658f5a71a5ab3f3142659cbe6d6e6f036a3b933d9">RTC_WAKEUPCTRL_AUTO</a> </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function performs a synchronized register access. Impact on runtime performance and other same and lower-priority contexts should be carefully considered. See <a class="el" href="a00459.html#RTC_WARNING">warning section</a>. </dd></dl>

</div>
</div>
<a id="ga70e595639e1113b7979dd0dd951fc0b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga70e595639e1113b7979dd0dd951fc0b0">&#9670;&nbsp;</a></span>Chip_RTC_Wakeup_SetReload()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Chip_RTC_Wakeup_SetReload </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00459.html#a00662">NSS_RTC_T</a> *&#160;</td>
          <td class="paramname"><em>pRTC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ticks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the "wake-up down-counter" ticks. This tick value is decremented until it reaches zero, and the RTC interrupt is generated, thus a 'wake-up' event </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pRTC</td><td>: The base address of the RTC peripheral on the chip </td></tr>
    <tr><td class="paramname">ticks</td><td>: 24bit unsigned number of ticks (seconds) to wake-up. Acceptable value from 0 to 16,777,215 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>RTC interrupt MUST be enabled to wake up from various standby modes (Sleep/Deep Sleep/Deep Power Down). </dd>
<dd>
When <a class="el" href="a00459.html#ggaecca952591fa1f2ceaec56d6658f5a71a5ab3f3142659cbe6d6e6f036a3b933d9">RTC_WAKEUPCTRL_AUTO</a> bit is set, calling <a class="el" href="a00459.html#ga4428e6f8613fdf5f298563c659b8c2f2">Chip_RTC_Wakeup_SetControl</a> starts the "wake-up down-counter". </dd>
<dd>
Without <a class="el" href="a00459.html#ggaecca952591fa1f2ceaec56d6658f5a71a5ab3f3142659cbe6d6e6f036a3b933d9">RTC_WAKEUPCTRL_AUTO</a> bit, setting a "wake-up down-counter" value clears <a class="el" href="a00459.html#ggaecca952591fa1f2ceaec56d6658f5a71a40b69dd87ccaf7c8b619b008876ffb3f">RTC_WAKEUPCTRL_START</a>. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function performs a synchronized register access. Impact on runtime performance and other same and lower-priority contexts should be carefully considered. See <a class="el" href="a00459.html#RTC_WARNING">warning section</a>. </dd></dl>

</div>
</div>
<a id="ga500d57348b3bb6f30674db693dbf43f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga500d57348b3bb6f30674db693dbf43f9">&#9670;&nbsp;</a></span>Chip_RTC_Wakeup_GetReload()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Chip_RTC_Wakeup_GetReload </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00459.html#a00662">NSS_RTC_T</a> *&#160;</td>
          <td class="paramname"><em>pRTC</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the number of "wake-up down-counter" ticks (seconds) previously set by <a class="el" href="a00459.html#ga70e595639e1113b7979dd0dd951fc0b0">Chip_RTC_Wakeup_SetReload</a> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pRTC</td><td>: The base address of the RTC peripheral on the chip </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>24bit unsigned value of the number of ticks </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function does not return remaining ticks to a 'wake-up' event. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function performs a synchronized register access. Impact on runtime performance and other same and lower-priority contexts should be carefully considered. See <a class="el" href="a00459.html#RTC_WARNING">warning section</a>. </dd></dl>

</div>
</div>
<a id="gaa12c427041298fc8ce3d27de085892ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa12c427041298fc8ce3d27de085892ea">&#9670;&nbsp;</a></span>Chip_RTC_Wakeup_GetRemaining()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Chip_RTC_Wakeup_GetRemaining </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00459.html#a00662">NSS_RTC_T</a> *&#160;</td>
          <td class="paramname"><em>pRTC</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the remaining ("wake-up down-counter") ticks until 'wake-up' event occurs </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pRTC</td><td>: The base address of the RTC peripheral on the chip </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>24bit unsigned value of the remaining number of ticks to a 'wake-up' event </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function performs a synchronized register access. Impact on runtime performance and other same and lower-priority contexts should be carefully considered. See <a class="el" href="a00459.html#RTC_WARNING">warning section</a>. </dd></dl>

</div>
</div>
<a id="ga9912d1de565665113c15bf3e36cc2331"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9912d1de565665113c15bf3e36cc2331">&#9670;&nbsp;</a></span>Chip_RTC_Wakeup_IsRunning()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Chip_RTC_Wakeup_IsRunning </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00459.html#a00662">NSS_RTC_T</a> *&#160;</td>
          <td class="paramname"><em>pRTC</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Indicates whether or not the "wake-up-down-counter" is in fact running </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pRTC</td><td>: The base address of the RTC peripheral on the chip </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if it is running or false otherwise. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function performs synchronized register accesses. Impact on runtime performance and other same and lower-priority contexts should be carefully considered. See <a class="el" href="a00459.html#RTC_WARNING">warning section</a>. </dd></dl>

</div>
</div>
<a id="ga454781d125e16d730581d8a9ef42eea9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga454781d125e16d730581d8a9ef42eea9">&#9670;&nbsp;</a></span>Chip_RTC_Time_GetValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Chip_RTC_Time_GetValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00459.html#a00662">NSS_RTC_T</a> *&#160;</td>
          <td class="paramname"><em>pRTC</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the current 'tick' value of the "time up-counter" </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pRTC</td><td>: The base address of the RTC peripheral on the chip </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Current ticks since the TFRO clock was enabled (unless updated via <a class="el" href="a00459.html#gacc9b42f869a58aa0c5072677543c0d03">Chip_RTC_Time_SetValue</a>). </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Note that HW returns 'tick' in 32bit of unsigned magnitude, type-casted and returned as signed 'int' in <a class="el" href="a00459.html#ga454781d125e16d730581d8a9ef42eea9">Chip_RTC_Time_GetValue</a> </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function performs a synchronized register access. Impact on runtime performance and other same and lower-priority contexts should be carefully considered. See <a class="el" href="a00459.html#RTC_WARNING">warning section</a>. </dd></dl>

</div>
</div>
<a id="gacc9b42f869a58aa0c5072677543c0d03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacc9b42f869a58aa0c5072677543c0d03">&#9670;&nbsp;</a></span>Chip_RTC_Time_SetValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Chip_RTC_Time_SetValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00459.html#a00662">NSS_RTC_T</a> *&#160;</td>
          <td class="paramname"><em>pRTC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tickValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets a new 'tick' value to the "time up-counter". When using as an epoch, the number of seconds since that epoch can be written to the "time up-counter", so that it maintains the current date/time. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pRTC</td><td>: The base address of the RTC peripheral on the chip </td></tr>
    <tr><td class="paramname">tickValue</td><td>tick value to assign to "time up-counter". This value will be type-casted as unsigned 32-bit then applied to HW registers </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>This function performs a synchronized register access. Impact on runtime performance and other same and lower-priority contexts should be carefully considered. See <a class="el" href="a00459.html#RTC_WARNING">warning section</a>. </dd></dl>

</div>
</div>
<a id="ga9bd47669775fb500740fe0514e8497ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9bd47669775fb500740fe0514e8497ef">&#9670;&nbsp;</a></span>Chip_RTC_Int_SetEnabledMask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Chip_RTC_Int_SetEnabledMask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00459.html#a00662">NSS_RTC_T</a> *&#160;</td>
          <td class="paramname"><em>pRTC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00459.html#gacd51ff9a80124d48dd3565b4f1ab7bef">RTC_INT_T</a>&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enables/Disables the RTC interrupts. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pRTC</td><td>: The base address of the RTC block on the chip </td></tr>
    <tr><td class="paramname">mask</td><td>: Interrupt enabled mask to set </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Interrupt MUST be enabled to wake up from Sleep/Deep Sleep states </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function performs a synchronized register access. Impact on runtime performance and other same and lower-priority contexts should be carefully considered. See <a class="el" href="a00459.html#RTC_WARNING">warning section</a>. </dd></dl>

</div>
</div>
<a id="ga4ad25b91c3dec03093d3e6ef02428047"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4ad25b91c3dec03093d3e6ef02428047">&#9670;&nbsp;</a></span>Chip_RTC_Int_GetEnabledMask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00459.html#gacd51ff9a80124d48dd3565b4f1ab7bef">RTC_INT_T</a> Chip_RTC_Int_GetEnabledMask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00459.html#a00662">NSS_RTC_T</a> *&#160;</td>
          <td class="paramname"><em>pRTC</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieves the RTC interrupt enabled mask. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pRTC</td><td>: base address of the RTC block on chip. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Interrupt enabled mask </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function performs a synchronized register access. Impact on runtime performance and other same and lower-priority contexts should be carefully considered. See <a class="el" href="a00459.html#RTC_WARNING">warning section</a>. </dd></dl>

</div>
</div>
<a id="gab3d7e4ae96507e384610f4f3fc027e24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab3d7e4ae96507e384610f4f3fc027e24">&#9670;&nbsp;</a></span>Chip_RTC_Int_GetRawStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00459.html#gacd51ff9a80124d48dd3565b4f1ab7bef">RTC_INT_T</a> Chip_RTC_Int_GetRawStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00459.html#a00662">NSS_RTC_T</a> *&#160;</td>
          <td class="paramname"><em>pRTC</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieves a bitVector with the RAW RTC interrupt flags </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pRTC</td><td>: The base address of the RTC peripheral on the chip </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BitVector with the RTC RAW interrupt flags </dd></dl>
<dl class="section note"><dt>Note</dt><dd>A bit set to 1 means that the correspondent interrupt flag is set. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function performs a synchronized register access. Impact on runtime performance and other same and lower-priority contexts should be carefully considered. See <a class="el" href="a00459.html#RTC_WARNING">warning section</a>. </dd></dl>

</div>
</div>
<a id="ga8c3793cee7fa7a5e3705f741a1b37213"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8c3793cee7fa7a5e3705f741a1b37213">&#9670;&nbsp;</a></span>Chip_RTC_Int_ClearRawStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Chip_RTC_Int_ClearRawStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00459.html#a00662">NSS_RTC_T</a> *&#160;</td>
          <td class="paramname"><em>pRTC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00459.html#gacd51ff9a80124d48dd3565b4f1ab7bef">RTC_INT_T</a>&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clears the required RTC interrupt flags. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pRTC</td><td>: The base address of the RTC peripheral on the chip </td></tr>
    <tr><td class="paramname">flags</td><td>: Bitvector indicating which interrupt flags to clear </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>This function performs a synchronized register access. Impact on runtime performance and other same and lower-priority contexts should be carefully considered. See <a class="el" href="a00459.html#RTC_WARNING">warning section</a>. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Tue Oct 20 2020 08:24:34 for NHS31xx SW API by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.14 </li>
  </ul>
</div>
</body>
</html>
