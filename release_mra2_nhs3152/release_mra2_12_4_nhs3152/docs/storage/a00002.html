<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NHS31xx storage - Maximizing storage for equisized samples: storage.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="nxp-logo_small.jpg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NHS31xx storage - Maximizing storage for equisized samples
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('a00002.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">storage.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a href="a00002_source.html">Go to the source code of this file.</a></p>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><dl class="section user"><dt>Maintaining state</dt><dd>It is a crucial feature of this module to be able to resume operation at all times. Between de-initialization and re-initialization anything can happen, and no volatile memory can be trusted. Still, speed of operation is necessary. To be able to restore the exact state - done in <a class="el" href="a00176.html#gad04fe4fa8e78ef5572e4a39dec188c31">Storage_Init</a> - three different recovery structures are used:<ul>
<li><a class="el" href="a00002.html#a00181">RecoverInfo_t</a> - stored in the general purpose registers</li>
<li><a class="el" href="a00002.html#a00185">Hint_t</a> - stored on a fixed location in EEPROM</li>
<li><a class="el" href="a00002.html#a00189">Marker_t</a> - stored on a variable location, immediately after the last written sample in EEPROM</li>
</ul>
After recovery, state is maintained in SRAM using the structure <a class="el" href="a00002.html#a00193">Storage_Instance_t</a>, and in <a class="el" href="a00176.html#ga75abea0be7fefec6285224dc0f82f5ac">Storage_DeInit</a> at least two of the three recovery structures are updated. <br />
 The recovery structures are linked to each other as explained below.</dd></dl>
<ul>
<li><a class="el" href="a00002.html#a00181">RecoverInfo_t</a> This data is stored in the designated ALON register <a class="el" href="a00177.html#gaa0b4af28ee1307ce6c560e71d5a6c742">STORAGE_FIRST_ALON_REGISTER</a> and is by far the fastest and easiest way to recover the current state. It is always tried first. If its data is non-zero, the information is trusted and used.</li>
<li><a class="el" href="a00002.html#a00185">Hint_t</a> This data is stored in the last page of the assigned EEPROM region, and also enables recovery of the current state in a fast way. However, this structure may be out of date as it may not be updated at every change. The reason for not updating is to ensure the maximum number of writes (endurance) is never reached. However, this data will always accurately tell<ul>
<li>whether samples are stored or not</li>
<li>how much flash is occupied by data storage</li>
</ul>
It also provides a possible location to <a class="el" href="a00002.html#a00189">Marker_t</a>, which may be outdated.</li>
<li><a class="el" href="a00002.html#a00189">Marker_t</a> This data is always stored just after the last sample written in EEPROM. Its precise location is not known, as it is progressing together with the data. <a class="el" href="a00002.html#a00181">RecoverInfo_t</a> points to the start of this structure in the assigned EEPROM region; <a class="el" href="a00002.html#a00185">Hint_t</a> may point to it; if both are failing a full slow search is performed in the assigned EEPROM region.</li>
</ul>
<p>When a full backward search is performed during data recovery, we rely on the length of the marker to eliminate false positives, i.e. to ensure no bit sequence exists that looks like a valid marker but are in reality one or more samples stored in EEPROM. The comments near the code in <a class="el" href="a00002.html#a6a819a5d10e6edaab80a62b5832a4c59">FindMarker</a> explain the length and value of the marker avoid finding false positives. Yet, although extremely improbable, there is still a very tiny possibility that real-life data being stored in EEPROM results in such a false positive. Even then, most applications will never have the need to perform a full backward search, evading this problem. If your application is more likely to hit this, due to the use case being sufficiently different, and due to the samples being sufficiently similar, this module can be adapted to erase the full EEPROM after moving all data to FLASH - see <a class="el" href="a00002.html#a9f6c705aa5b6a14f8df25c16bf1cfdf2">MoveSamplesFromEepromToFlash</a>. During our continuous tests using randomized data of different lengths, we have never encountered this problem and therefore decided not to suffer the extra cost (time and power consumption) of implementing this.</p>
<dl class="section user"><dt>Recovering</dt><dd>In <a class="el" href="a00176.html#ga75abea0be7fefec6285224dc0f82f5ac">Storage_DeInit</a>, at least the ALON register (<a class="el" href="a00002.html#a00181">RecoverInfo_t</a>) and the EEPROM marker (<a class="el" href="a00002.html#a00189">Marker_t</a>) are updated. Assuming only one sample was added, the EEPROM contents would then change as visually depicted below:</dd></dl>
<dl class="section note"><dt>Note</dt><dd>the pictures below use this legend:<ul>
<li><code>aaa</code>, <code>bbb</code>, ... <code>fff:</code> samples, with bitsize <a class="el" href="a00177.html#gad01e6c1296544674eb74616a97afd3fc">STORAGE_BITSIZE</a></li>
<li><code>AA:</code> ALON register, formatted according to <a class="el" href="a00002.html#a00181">RecoverInfo_t</a></li>
<li><code>HH:</code> hint, formatted according to <a class="el" href="a00002.html#a00185">Hint_t</a></li>
<li><code>MMMMMMM:</code> marker, formatted according to <a class="el" href="a00002.html#a00189">Marker_t</a></li>
<li><code>BB:</code> block info, of size <a class="el" href="a00002.html#a4b7ab7ad7715d7364693a5224f85a937">FLASH_DATA_HEADER_SIZE</a></li>
<li><code>xxxx:</code> block bytes, the (compressed) data bytes moved from EEPROM and now stored in FLASH</li>
</ul>
<div class="fragment"><div class="line">  EEPROM                             EEPROM</div><div class="line"> with samples a..d                  with samples a..e</div><div class="line">+---------+                        +---------+</div><div class="line">| aaabbbc |                        | aaabbbc |</div><div class="line">| ccdddMM |     After calling      | ccdddee |</div><div class="line">| MMMMM   |     <a class="code" href="a00176.html#ga820a105a6412fe21e8598f2c682664af">Storage_Write</a>      | eMMMMMM |</div><div class="line">|         |     with n=1:          | MM      |</div><div class="line">|         |  ------------------&gt;   |         |</div><div class="line">|      HH |                        |      HH |</div><div class="line">+---------+                        +---------+</div></div><!-- fragment --></dd></dl>
<p>The ALON register will then point to the new location of the marker; while the hint will not be updated and will for sure contain faulty information.</p>
<div class="dotgraph">
<img src="dot_inline_dotgraph_1.png" alt="dot_inline_dotgraph_1.png" border="0" usemap="#dot_inline_dotgraph_1.map"/>
<map name="dot_inline_dotgraph_1.map" id="dot_inline_dotgraph_1.map"><area shape="rect" id="node1" href="a00177.html#gaa0b4af28ee1307ce6c560e71d5a6c742" title="ALON register" alt="" coords="57,5,188,53"/>
<area shape="rect" id="node2" href="a00002.html#a00189" title="Moving marker in EEPROM" alt="" coords="5,103,240,151"/>
<area shape="rect" id="node4" href="a00002.html#ad3aa100f3d8ee9fe205c5ea72f73fc0a" title="flashByteCursor" alt="" coords="53,200,193,248"/>
<area shape="rect" id="node3" href="a00002.html#aacec9cac5ccd08a849aacd321d30d25b" title="Hint information on a\nfixed EEPROM location" alt="" coords="265,101,466,152"/>
</map>
</div>
<p>When power gets lost, the ALON register contents is reset to <code>0</code>, and will then point to a faulty location as well.</p>
<div class="dotgraph">
<img src="dot_inline_dotgraph_2.png" alt="dot_inline_dotgraph_2.png" border="0" usemap="#dot_inline_dotgraph_2.map"/>
<map name="dot_inline_dotgraph_2.map" id="dot_inline_dotgraph_2.map"><area shape="rect" id="node1" href="a00177.html#gaa0b4af28ee1307ce6c560e71d5a6c742" title="ALON register" alt="" coords="5,5,136,53"/>
<area shape="rect" id="node2" href="a00002.html#a00189" title="Moving marker in EEPROM" alt="" coords="131,103,365,151"/>
<area shape="rect" id="node5" href="a00002.html#ad3aa100f3d8ee9fe205c5ea72f73fc0a" title="flashByteCursor" alt="" coords="178,200,318,248"/>
<area shape="rect" id="node3" href="a00002.html#aacec9cac5ccd08a849aacd321d30d25b" title="Hint information on a\nfixed EEPROM location" alt="" coords="390,101,591,152"/>
</map>
</div>
<p>Only the marker will then still be correct, which can be recovered only through a full backward search. When that is done, after leaving <a class="el" href="a00176.html#ga75abea0be7fefec6285224dc0f82f5ac">Storage_DeInit</a>, all three recovery structures will be correctly linked.</p>
<div class="dotgraph">
<img src="dot_inline_dotgraph_3.png" alt="dot_inline_dotgraph_3.png" border="0" usemap="#dot_inline_dotgraph_3.map"/>
<map name="dot_inline_dotgraph_3.map" id="dot_inline_dotgraph_3.map"><area shape="rect" id="node1" href="a00177.html#gaa0b4af28ee1307ce6c560e71d5a6c742" title="ALON register" alt="" coords="283,5,414,53"/>
<area shape="rect" id="node2" href="a00002.html#a00189" title="Moving marker in EEPROM" alt="" coords="231,103,466,151"/>
<area shape="rect" id="node4" href="a00002.html#ad3aa100f3d8ee9fe205c5ea72f73fc0a" title="flashByteCursor" alt="" coords="279,200,419,248"/>
<area shape="rect" id="node3" href="a00002.html#aacec9cac5ccd08a849aacd321d30d25b" title="Hint information on a\nfixed EEPROM location" alt="" coords="5,101,207,152"/>
</map>
</div>
<dl class="section user"><dt>Data corruption</dt><dd>When the battery is degrading, two scenarios can cause a corruption:<ul>
<li>the supplied voltage drops too much during a flash operation, hanging the IC or causing a reset. This can corrupt the FLASH portion being written to.</li>
<li>the supplied voltage drops too much during an EEPROM operation, hanging the IC or causing a reset. This can corrupt the EEPROM row being written to.</li>
</ul>
The storage module can be fully resilient against this: no data present in the non-volatile memories EEPROM and FLASH is lost and all samples can still be read out, with one exception: the samples written after the last update to the hint structure cannot be recovered, as no duplicate information is yet available.</dd></dl>
<p>After a hard reset, the general purpose registers are reset to 0, and the samples temporarily stored there are also lost. This brings the total number of minimum lost samples to <a class="el" href="a00177.html#ga6c078f740cf06f4b2fc346ea8cef148b">STORAGE_WRITE_RECOVERY_EVERY_X_SAMPLES</a> + <a class="el" href="a00177.html#ga2d3c0407efae913c029d74b8621c16fe">STORAGE_SAMPLE_ALON_CACHE_COUNT</a> - both are diversity settings the application can set.</p>
<dl class="section user"><dt>Using EEPROM <b>and</b> FLASH</dt><dd>Both EEPROM and FLASH are used to store data - in the form of equisized samples. Since writing to EEPROM is cheaper, faster and less complicated than writing to FLASH, it is the preferred storage medium. Whenever the size of all the samples stored in EEPROM is large enough - see <a class="el" href="a00177.html#ga9023fc3872517d220a8f817eeef29957">STORAGE_BLOCK_SIZE_IN_SAMPLES</a> - all that data is moved in one operation to FLASH. EEPROM is then completely empty, and new samples are then in EEPROM again.</dd></dl>
<p>The memory content changes are visually depicted below. If writing a new sample would increase the size to equal to or higher than <a class="el" href="a00177.html#ga9023fc3872517d220a8f817eeef29957">STORAGE_BLOCK_SIZE_IN_SAMPLES</a>, first the EEPROM contents are moved, then the new sample is written.</p>
<div class="fragment"><div class="line">  EEPROM                                 EEPROM</div><div class="line"> with samples a..e                      with sample f only</div><div class="line">+---------+                            +---------+</div><div class="line">| aaabbbc |                            | fffMMMM |</div><div class="line">| cc..... |                            | MMM     |</div><div class="line">| ....... |                            |         |</div><div class="line">| ....ddd |  ----------------------&gt;   |         |</div><div class="line">| eeeMMMM |                            |         |</div><div class="line">| MMM  HH |                            |      HH |</div><div class="line">+---------+                            +---------+</div><div class="line"></div><div class="line">  FLASH                                  FLASH</div><div class="line"> with one block moved from EEPROM       with two blocks moved from EEPROM</div><div class="line">+---------+                            +---------+</div><div class="line">| BBxxxxx |                            | BBxxxxx |</div><div class="line">| xxxxxxx |                            | xxxxxxx |</div><div class="line">| x       |  ----------------------&gt;   | xBBxxxx |</div><div class="line">|         |                            | xxxxx   |</div><div class="line">|         |                            |         |</div><div class="line">|         |                            |         |</div><div class="line">+---------+                            +---------+</div></div><!-- fragment --><dl class="section user"><dt>Caching data</dt><dd>To reduce the number of EEPROM flushes, data is initially <b>not</b> stored in non-volatile memories EEPROM and FLASH. Instead, the reserved general purpose registers are used to cache the data. The value is preserved when entering and leaving a deep power down, but any inadvertent reset clears the registers, losing the data. This is not a disadvantage, since the cached data will be moved to non-volatile memory before writing the hint The benefit is a reduction of the required EEPROM program operations. This helps in avoiding the write endurance limit even when storing massive amounts of data, and also reduces the stress on the battery when it nears end-of-life.</dd></dl>
<p><a class="anchor" id="storage_initializing_par"></a> </p><dl class="section user"><dt>Initializing</dt><dd>The implementation of <a class="el" href="a00176.html#gad04fe4fa8e78ef5572e4a39dec188c31">Storage_Init</a> tries to recover the complete state as fast as possible. This can be done when either the recovery info or the hint information points to a valid marker structure. When a slow search is required, the initialization function make sure a next call will be fast. <br />
 <a class="el" href="a00176.html#gad04fe4fa8e78ef5572e4a39dec188c31">Storage_Init</a> implements this flowchart:</dd></dl>
<div class="dotgraph">
<img src="dot_inline_dotgraph_4.png" alt="dot_inline_dotgraph_4.png" border="0" usemap="#dot_inline_dotgraph_4.map"/>
<map name="dot_inline_dotgraph_4.map" id="dot_inline_dotgraph_4.map"></map>
</div>
 
<p class="definition">Definition in file <a class="el" href="a00002_source.html">storage.c</a>.</p>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:a00181"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#a00181">RecoverInfo_t</a></td></tr>
<tr class="separator:a00181"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00185"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#a00185">Hint_t</a></td></tr>
<tr class="separator:a00185"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00189"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#a00189">Marker_t</a></td></tr>
<tr class="separator:a00189"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00193"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#a00193">Storage_Instance_t</a></td></tr>
<tr class="separator:a00193"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a51097af3fdea45986851a90fe37982b1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#a51097af3fdea45986851a90fe37982b1">EEPROM_ABSOLUTE_FIRST_BYTE_OFFSET</a>&#160;&#160;&#160;(<a class="el" href="a00177.html#ga89fe1736e393062639f3d7b64e76eeed">STORAGE_EEPROM_FIRST_ROW</a> * EEPROM_ROW_SIZE)</td></tr>
<tr class="separator:a51097af3fdea45986851a90fe37982b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d3116589e95d45f43dd42e5ba138b57"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#a5d3116589e95d45f43dd42e5ba138b57">EEPROM_ABSOLUTE_LAST_BYTE_OFFSET</a>&#160;&#160;&#160;(((<a class="el" href="a00177.html#ga601793e23c7072b845356fc186966c19">STORAGE_EEPROM_LAST_ROW</a> + 1) * EEPROM_ROW_SIZE) - 1)</td></tr>
<tr class="separator:a5d3116589e95d45f43dd42e5ba138b57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ea11f64fe607c5e2512425195ad5d73"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#a7ea11f64fe607c5e2512425195ad5d73">FLASH_CURSOR_TO_BYTE_ADDRESS</a>(flashByteCursor)&#160;&#160;&#160;((uint8_t *)(FLASH_START + (<a class="el" href="a00177.html#gadc56bda551d9bbea8ac33ac75c98ea6a">STORAGE_FLASH_FIRST_PAGE</a> * FLASH_PAGE_SIZE) + (flashByteCursor)))</td></tr>
<tr class="separator:a7ea11f64fe607c5e2512425195ad5d73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a107742a2e13dcf6270ce8da63f1784fb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#a107742a2e13dcf6270ce8da63f1784fb">FLASH_CURSOR_TO_PAGE</a>(flashByteCursor)&#160;&#160;&#160;(<a class="el" href="a00177.html#gadc56bda551d9bbea8ac33ac75c98ea6a">STORAGE_FLASH_FIRST_PAGE</a> + ((flashByteCursor) / FLASH_PAGE_SIZE))</td></tr>
<tr class="separator:a107742a2e13dcf6270ce8da63f1784fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83e5cf92d3e947253bc6e83c0c8d9e77"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#a83e5cf92d3e947253bc6e83c0c8d9e77">FLASH_PAGE_TO_ADDRESS</a>(type,  flashPage)&#160;&#160;&#160;((type)(FLASH_START + ((flashPage) * FLASH_PAGE_SIZE)))</td></tr>
<tr class="separator:a83e5cf92d3e947253bc6e83c0c8d9e77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a025359621a3e72503e8f5822477926"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#a8a025359621a3e72503e8f5822477926">FLASH_FIRST_BYTE_ADDRESS</a>&#160;&#160;&#160;<a class="el" href="a00002.html#a83e5cf92d3e947253bc6e83c0c8d9e77">FLASH_PAGE_TO_ADDRESS</a>(uint8_t *, <a class="el" href="a00177.html#gadc56bda551d9bbea8ac33ac75c98ea6a">STORAGE_FLASH_FIRST_PAGE</a>)</td></tr>
<tr class="separator:a8a025359621a3e72503e8f5822477926"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1801230677612489a71fceeefadfcd0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#aa1801230677612489a71fceeefadfcd0">FLASH_LAST_BYTE_ADDRESS</a>&#160;&#160;&#160;(<a class="el" href="a00002.html#a83e5cf92d3e947253bc6e83c0c8d9e77">FLASH_PAGE_TO_ADDRESS</a>(uint8_t *, <a class="el" href="a00177.html#gaa9d5b61492e536833e7ae705d1888f07">STORAGE_FLASH_LAST_PAGE</a> + 1) - 1)</td></tr>
<tr class="separator:aa1801230677612489a71fceeefadfcd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79ab8f2629e16d6de78e765b2cbbbe15"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#a79ab8f2629e16d6de78e765b2cbbbe15">FLASH_FIRST_WORD_ADDRESS</a>&#160;&#160;&#160;<a class="el" href="a00002.html#a83e5cf92d3e947253bc6e83c0c8d9e77">FLASH_PAGE_TO_ADDRESS</a>(uint32_t *, <a class="el" href="a00177.html#gadc56bda551d9bbea8ac33ac75c98ea6a">STORAGE_FLASH_FIRST_PAGE</a>)</td></tr>
<tr class="separator:a79ab8f2629e16d6de78e765b2cbbbe15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac264ea0b58d6d8daf0b68eb8d1502233"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#ac264ea0b58d6d8daf0b68eb8d1502233">FLASH_LAST_WORD_ADDRESS</a>&#160;&#160;&#160;(<a class="el" href="a00002.html#a83e5cf92d3e947253bc6e83c0c8d9e77">FLASH_PAGE_TO_ADDRESS</a>(uint32_t *, <a class="el" href="a00177.html#gaa9d5b61492e536833e7ae705d1888f07">STORAGE_FLASH_LAST_PAGE</a> + 1) - 1)</td></tr>
<tr class="separator:ac264ea0b58d6d8daf0b68eb8d1502233"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b7ab7ad7715d7364693a5224f85a937"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#a4b7ab7ad7715d7364693a5224f85a937">FLASH_DATA_HEADER_SIZE</a>&#160;&#160;&#160;<a class="el" href="a00177.html#ga2cf237c4f6960deeb7e47e092b5094fc">STORAGE_BLOCK_HEADER_SIZE</a></td></tr>
<tr class="separator:a4b7ab7ad7715d7364693a5224f85a937"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b5a80c719faf51e26891ceb706885cd"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#a7b5a80c719faf51e26891ceb706885cd">FLASH_BLOCK_SIZE</a>(bitCount)&#160;&#160;&#160;(4 * <a class="el" href="a00177.html#gad5156aa8d4f9dc31fcd5ff6efc9f5e42">STORAGE_IDIVUP</a>((bitCount) + <a class="el" href="a00002.html#a4b7ab7ad7715d7364693a5224f85a937">FLASH_DATA_HEADER_SIZE</a> * 8, 32))</td></tr>
<tr class="separator:a7b5a80c719faf51e26891ceb706885cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a0e208f7ef4eb70204794ceeeddf93c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#a8a0e208f7ef4eb70204794ceeeddf93c">MARKER_HEADER</a>&#160;&#160;&#160;((int)0x0000FFFF)</td></tr>
<tr class="separator:a8a0e208f7ef4eb70204794ceeeddf93c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9932f0627c3b75f5244245d134abcc49"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#a9932f0627c3b75f5244245d134abcc49">MARKER_FOOTER</a>&#160;&#160;&#160;((int)0x7FFFFFFF)</td></tr>
<tr class="separator:a9932f0627c3b75f5244245d134abcc49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26ce4ace770f604410e5a7be24569165"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#a26ce4ace770f604410e5a7be24569165">MARKER_CURSOR_ZERO_MASK</a>&#160;&#160;&#160;0xFFFF8003</td></tr>
<tr class="separator:a26ce4ace770f604410e5a7be24569165"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc56bda551d9bbea8ac33ac75c98ea6a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#adc56bda551d9bbea8ac33ac75c98ea6a">STORAGE_FLASH_FIRST_PAGE</a>&#160;&#160;&#160;<a class="el" href="a00002.html#a6a400e06f2edf1ffc365a5e2e64c6d31">sStorageFlashFirstPage</a></td></tr>
<tr class="separator:adc56bda551d9bbea8ac33ac75c98ea6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc9121aaa97e1eca96c84b3425032118"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#adc9121aaa97e1eca96c84b3425032118">FIRST_BITS_OF_CACHE_SIZE</a>&#160;&#160;&#160;13</td></tr>
<tr class="separator:adc9121aaa97e1eca96c84b3425032118"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18d649f1561f0c860e484c7fdf9df74a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#a18d649f1561f0c860e484c7fdf9df74a">SIZE_OF_HINT</a>&#160;&#160;&#160;4</td></tr>
<tr class="separator:a18d649f1561f0c860e484c7fdf9df74a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75ed8bd26aca85af0d2f11a01ef28880"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#a75ed8bd26aca85af0d2f11a01ef28880">INVERSE_HINT_ABSOLUTE_BYTE_OFFSET</a>&#160;&#160;&#160;((<a class="el" href="a00002.html#a5d3116589e95d45f43dd42e5ba138b57">EEPROM_ABSOLUTE_LAST_BYTE_OFFSET</a> + 1 - <a class="el" href="a00002.html#a18d649f1561f0c860e484c7fdf9df74a">SIZE_OF_HINT</a>))</td></tr>
<tr class="separator:a75ed8bd26aca85af0d2f11a01ef28880"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacec9cac5ccd08a849aacd321d30d25b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#aacec9cac5ccd08a849aacd321d30d25b">HINT_ABSOLUTE_BYTE_OFFSET</a>&#160;&#160;&#160;(<a class="el" href="a00002.html#a75ed8bd26aca85af0d2f11a01ef28880">INVERSE_HINT_ABSOLUTE_BYTE_OFFSET</a> - <a class="el" href="a00002.html#a18d649f1561f0c860e484c7fdf9df74a">SIZE_OF_HINT</a>)</td></tr>
<tr class="separator:aacec9cac5ccd08a849aacd321d30d25b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d7b6ac9b0010a76e7219a9e45c59362"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#a2d7b6ac9b0010a76e7219a9e45c59362">SIZE_OF_DUPLICATE_DATA</a>&#160;&#160;&#160;64</td></tr>
<tr class="separator:a2d7b6ac9b0010a76e7219a9e45c59362"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b65ffe06d12a5ce4a0ac3dbc5184022"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#a0b65ffe06d12a5ce4a0ac3dbc5184022">DUPLICATE_DATA_ABSOLUTE_BYTE_OFFSET</a>&#160;&#160;&#160;(<a class="el" href="a00002.html#a5d3116589e95d45f43dd42e5ba138b57">EEPROM_ABSOLUTE_LAST_BYTE_OFFSET</a> + 1 - (2 * EEPROM_ROW_SIZE))</td></tr>
<tr class="separator:a0b65ffe06d12a5ce4a0ac3dbc5184022"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6a3b701867c86fd64359d2b105548b1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#ab6a3b701867c86fd64359d2b105548b1">SIZE_OF_MARKER</a>&#160;&#160;&#160;12</td></tr>
<tr class="separator:ab6a3b701867c86fd64359d2b105548b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a756a1be4b449a2c065c2d40436328356"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#a756a1be4b449a2c065c2d40436328356">EEPROM_OVERHEAD_IN_BITS</a>&#160;&#160;&#160;((<a class="el" href="a00002.html#ab6a3b701867c86fd64359d2b105548b1">SIZE_OF_MARKER</a> + 2 * EEPROM_ROW_SIZE) * 8)</td></tr>
<tr class="separator:a756a1be4b449a2c065c2d40436328356"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a9fada3091f6ac60680d7c64c2ac6c1db"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#a9fada3091f6ac60680d7c64c2ac6c1db">LOCATION_T</a> { <br />
&#160;&#160;<a class="el" href="a00002.html#a9fada3091f6ac60680d7c64c2ac6c1dba32ce5f5a38b3b3e48bf355fe2d5f04fe">LOCATION_UNKNOWN</a>, 
<br />
&#160;&#160;<a class="el" href="a00002.html#a9fada3091f6ac60680d7c64c2ac6c1dbac1d84d000f28e68468e21ab6788872b1">LOCATION_CACHE</a>, 
<br />
&#160;&#160;<a class="el" href="a00002.html#a9fada3091f6ac60680d7c64c2ac6c1dba113ac2c7d5cdbeff51d8b9a111efc8ca">LOCATION_EEPROM</a>, 
<br />
&#160;&#160;<a class="el" href="a00002.html#a9fada3091f6ac60680d7c64c2ac6c1dba484c54b5bbce80e5b6bee441fc9bb1aa">LOCATION_FLASH</a>
<br />
 }</td></tr>
<tr class="separator:a9fada3091f6ac60680d7c64c2ac6c1db"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aaa81898e5c033740fad627b87fed62af"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#aaa81898e5c033740fad627b87fed62af">STORAGE_COMPRESS_CB</a> (int eepromByteOffset, int bitCount, void *pOut)</td></tr>
<tr class="separator:aaa81898e5c033740fad627b87fed62af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6edf730655366069960c566384171a4b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#a6edf730655366069960c566384171a4b">STORAGE_DECOMPRESS_CB</a> (const uint8_t *pData, int bitCount, void *pOut)</td></tr>
<tr class="separator:a6edf730655366069960c566384171a4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7234e2804def46fd82a323c29988a4ea"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#a7234e2804def46fd82a323c29988a4ea">Storage_DummyCompressCb</a> (int eepromByteOffset, int bitCount, void *pOut)</td></tr>
<tr class="separator:a7234e2804def46fd82a323c29988a4ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf1fb0ad99cd535196907129c71f1e9e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#aaf1fb0ad99cd535196907129c71f1e9e">Storage_DummyDecompressCb</a> (const uint8_t *pData, int bitCount, void *pOut)</td></tr>
<tr class="separator:aaf1fb0ad99cd535196907129c71f1e9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f26aa199deb27574f998a3f95868d8a"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#a7f26aa199deb27574f998a3f95868d8a">ResetInstance</a> (void)</td></tr>
<tr class="separator:a7f26aa199deb27574f998a3f95868d8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a061322d6eab88dc08412bf159efd914b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#a061322d6eab88dc08412bf159efd914b">ShiftAlignedData</a> (uint8_t *pTo, const uint8_t *pFrom, const int bitAlignment, const int bitCount)</td></tr>
<tr class="separator:a061322d6eab88dc08412bf159efd914b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0c7877e80c9706dd8af4fa40c27a401"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#aa0c7877e80c9706dd8af4fa40c27a401">ShiftUnalignedData</a> (uint8_t *pTo, const uint8_t *pFrom, const int bitAlignment, const int bitCount)</td></tr>
<tr class="separator:aa0c7877e80c9706dd8af4fa40c27a401"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a271ca24d6a2841a0f84ef9ef6487afda"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#a271ca24d6a2841a0f84ef9ef6487afda">CacheSample</a> (const <a class="el" href="a00177.html#gacdcc483479cdfdecfdd8908db2ad80ba">STORAGE_TYPE</a> *pSample)</td></tr>
<tr class="separator:a271ca24d6a2841a0f84ef9ef6487afda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bd9b376578591090fdcdb846a6815f6"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#a8bd9b376578591090fdcdb846a6815f6">GetCachedSample</a> (const int n, void *pData)</td></tr>
<tr class="separator:a8bd9b376578591090fdcdb846a6815f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa6e83d0957ecaca822b5e7d4742fb56"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#afa6e83d0957ecaca822b5e7d4742fb56">WriteToEeprom</a> (const int bitCursor, const void *pData, const int bitCount)</td></tr>
<tr class="separator:afa6e83d0957ecaca822b5e7d4742fb56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01f1423a2c76032a401695d892b8b507"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#a01f1423a2c76032a401695d892b8b507">ReadFromEeprom</a> (const unsigned int bitCursor, void *pData, const int bitCount)</td></tr>
<tr class="separator:a01f1423a2c76032a401695d892b8b507"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a819a5d10e6edaab80a62b5832a4c59"><td class="memItemLeft" align="right" valign="top">static unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#a6a819a5d10e6edaab80a62b5832a4c59">FindMarker</a> (<a class="el" href="a00002.html#a00189">Marker_t</a> *pMarker)</td></tr>
<tr class="separator:a6a819a5d10e6edaab80a62b5832a4c59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ff8f80115386c27583029b6f01a2cf6"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#a0ff8f80115386c27583029b6f01a2cf6">GetEepromCount</a> (void)</td></tr>
<tr class="separator:a0ff8f80115386c27583029b6f01a2cf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25d01d6c27a3fb8f12c7e16c10714011"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#a25d01d6c27a3fb8f12c7e16c10714011">GetFlashCount</a> (void)</td></tr>
<tr class="separator:a25d01d6c27a3fb8f12c7e16c10714011"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc7a5597cb0b1ab519de93d8f4d2ff99"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#acc7a5597cb0b1ab519de93d8f4d2ff99">StoreSamplesInEeprom</a> (const <a class="el" href="a00177.html#gacdcc483479cdfdecfdd8908db2ad80ba">STORAGE_TYPE</a> *pSamples, int n)</td></tr>
<tr class="separator:acc7a5597cb0b1ab519de93d8f4d2ff99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f6c705aa5b6a14f8df25c16bf1cfdf2"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#a9f6c705aa5b6a14f8df25c16bf1cfdf2">MoveSamplesFromEepromToFlash</a> (void)</td></tr>
<tr class="separator:a9f6c705aa5b6a14f8df25c16bf1cfdf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0df70bc26954e5b685293b5554e3c423"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#a0df70bc26954e5b685293b5554e3c423">ReadAndCacheSamplesFromFlash</a> (int readCursor)</td></tr>
<tr class="separator:a0df70bc26954e5b685293b5554e3c423"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab35e60a815419cac466868fe8f42a25c"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#ab35e60a815419cac466868fe8f42a25c">ValidateRecoverInfo</a> (void)</td></tr>
<tr class="separator:ab35e60a815419cac466868fe8f42a25c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28de616d2e0d635a6ca4d28238ffef79"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#a28de616d2e0d635a6ca4d28238ffef79">ValidateMarker</a> (const <a class="el" href="a00002.html#a00189">Marker_t</a> *pMarker, int expectedFlashByteCursor)</td></tr>
<tr class="separator:a28de616d2e0d635a6ca4d28238ffef79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a899e91c2dc6198f4c1a9c6f853a2b6e1"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#a899e91c2dc6198f4c1a9c6f853a2b6e1">ValidateHint</a> (const <a class="el" href="a00002.html#a00185">Hint_t</a> *pHint)</td></tr>
<tr class="separator:a899e91c2dc6198f4c1a9c6f853a2b6e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a898d33f80805fa3a63c95cc17dee54cc"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#a898d33f80805fa3a63c95cc17dee54cc">WriteHint</a> (void)</td></tr>
<tr class="separator:a898d33f80805fa3a63c95cc17dee54cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a479a6d8035834e3bfb58e04815271285"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#a479a6d8035834e3bfb58e04815271285">WriteMarker</a> (void)</td></tr>
<tr class="separator:a479a6d8035834e3bfb58e04815271285"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad04fe4fa8e78ef5572e4a39dec188c31"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00176.html#gad04fe4fa8e78ef5572e4a39dec188c31">Storage_Init</a> (void)</td></tr>
<tr class="separator:gad04fe4fa8e78ef5572e4a39dec188c31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga75abea0be7fefec6285224dc0f82f5ac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00176.html#ga75abea0be7fefec6285224dc0f82f5ac">Storage_DeInit</a> (void)</td></tr>
<tr class="separator:ga75abea0be7fefec6285224dc0f82f5ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga80e837c4eb77a8ff14057e1971e63083"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00176.html#ga80e837c4eb77a8ff14057e1971e63083">Storage_GetCount</a> (void)</td></tr>
<tr class="separator:ga80e837c4eb77a8ff14057e1971e63083"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga345ce91da83ce1cea789068dfb587ed5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00176.html#ga345ce91da83ce1cea789068dfb587ed5">Storage_Reset</a> (bool checkFlash)</td></tr>
<tr class="separator:ga345ce91da83ce1cea789068dfb587ed5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga820a105a6412fe21e8598f2c682664af"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00176.html#ga820a105a6412fe21e8598f2c682664af">Storage_Write</a> (<a class="el" href="a00177.html#gacdcc483479cdfdecfdd8908db2ad80ba">STORAGE_TYPE</a> *samples, int n)</td></tr>
<tr class="separator:ga820a105a6412fe21e8598f2c682664af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga82112f49c64c590b321e1e02caf077f5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00176.html#ga82112f49c64c590b321e1e02caf077f5">Storage_Seek</a> (int n)</td></tr>
<tr class="separator:ga82112f49c64c590b321e1e02caf077f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad82b015bb0ed48f90d9782a4b29f52ff"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00176.html#gad82b015bb0ed48f90d9782a4b29f52ff">Storage_Read</a> (<a class="el" href="a00177.html#gacdcc483479cdfdecfdd8908db2ad80ba">STORAGE_TYPE</a> *samples, int n)</td></tr>
<tr class="separator:gad82b015bb0ed48f90d9782a4b29f52ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:aec42f932dd26409b0fc9906a4219e16d"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#aec42f932dd26409b0fc9906a4219e16d">_etext</a></td></tr>
<tr class="separator:aec42f932dd26409b0fc9906a4219e16d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54781b6e6ecb68f160912244c1c7220f"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#a54781b6e6ecb68f160912244c1c7220f">_data</a></td></tr>
<tr class="separator:a54781b6e6ecb68f160912244c1c7220f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae94c84721d175f1261b8645a67f03094"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#ae94c84721d175f1261b8645a67f03094">_edata</a></td></tr>
<tr class="separator:ae94c84721d175f1261b8645a67f03094"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a400e06f2edf1ffc365a5e2e64c6d31"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#a6a400e06f2edf1ffc365a5e2e64c6d31">sStorageFlashFirstPage</a></td></tr>
<tr class="separator:a6a400e06f2edf1ffc365a5e2e64c6d31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf4ea6fab533549be15f2da4cbfbdd30"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#adf4ea6fab533549be15f2da4cbfbdd30">checkSizeOfSampleType</a> [(sizeof(<a class="el" href="a00177.html#gacdcc483479cdfdecfdd8908db2ad80ba">STORAGE_TYPE</a>) *8&lt; <a class="el" href="a00177.html#gad01e6c1296544674eb74616a97afd3fc">STORAGE_BITSIZE</a>) ? -1 :1]</td></tr>
<tr class="separator:adf4ea6fab533549be15f2da4cbfbdd30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9292a35f74c15d75bfbe8b6cfda6a3a3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#a9292a35f74c15d75bfbe8b6cfda6a3a3">checkSizeOfHint</a> [(<a class="el" href="a00002.html#a18d649f1561f0c860e484c7fdf9df74a">SIZE_OF_HINT</a>==sizeof(<a class="el" href="a00002.html#a00185">Hint_t</a>)) ? 1 :-1]</td></tr>
<tr class="separator:a9292a35f74c15d75bfbe8b6cfda6a3a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf09df21ead8191834b1eee5e7a39d0d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#aaf09df21ead8191834b1eee5e7a39d0d">checkSizeOfMarker</a> [(<a class="el" href="a00002.html#ab6a3b701867c86fd64359d2b105548b1">SIZE_OF_MARKER</a>==sizeof(<a class="el" href="a00002.html#a00189">Marker_t</a>)) ? 1 :-1]</td></tr>
<tr class="separator:aaf09df21ead8191834b1eee5e7a39d0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a734c1c9cacb668aea1416c6a99561f1f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#a734c1c9cacb668aea1416c6a99561f1f">checkSizeOfRecoverInfo</a> [sizeof(<a class="el" href="a00002.html#a00181">RecoverInfo_t</a>)==4 ? 1 :-1]</td></tr>
<tr class="separator:a734c1c9cacb668aea1416c6a99561f1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01ce7d8e7fc855bb5c49d4a50d66fc87"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="a00002.html#a00193">Storage_Instance_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#a01ce7d8e7fc855bb5c49d4a50d66fc87">sInstance</a></td></tr>
<tr class="separator:a01ce7d8e7fc855bb5c49d4a50d66fc87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a768b79d37c9c19f9e741f972789e1323"><td class="memItemLeft" align="right" valign="top">static uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#a768b79d37c9c19f9e741f972789e1323">sCache</a> [4 *(5 - <a class="el" href="a00177.html#gaa0b4af28ee1307ce6c560e71d5a6c742">STORAGE_FIRST_ALON_REGISTER</a>)]</td></tr>
<tr class="separator:a768b79d37c9c19f9e741f972789e1323"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97571bbdcaba93af46f15ce205da204d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="a00002.html#a00181">RecoverInfo_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#a97571bbdcaba93af46f15ce205da204d">spRecoverInfo</a></td></tr>
<tr class="separator:a97571bbdcaba93af46f15ce205da204d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c13128e91dc240e3ab47286463364ef"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#a1c13128e91dc240e3ab47286463364ef">sEepromBitCursorChanged</a> = false</td></tr>
<tr class="separator:a1c13128e91dc240e3ab47286463364ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d5937977dab1cbd29de86cc5e11762d"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#a2d5937977dab1cbd29de86cc5e11762d">sStorage_Workarea</a> [<a class="el" href="a00177.html#ga4b69ffeada7d6e645ed70b84786850f9">STORAGE_WORKAREA_SIZE</a>]</td></tr>
<tr class="separator:a2d5937977dab1cbd29de86cc5e11762d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95fd6ccd851ad8813a21f6ade2190084"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html#a95fd6ccd851ad8813a21f6ade2190084">STORAGE_WORKAREA</a> [<a class="el" href="a00177.html#ga4b69ffeada7d6e645ed70b84786850f9">STORAGE_WORKAREA_SIZE</a>]</td></tr>
<tr class="separator:a95fd6ccd851ad8813a21f6ade2190084"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<hr/><h2 class="groupheader">Data Structure Documentation</h2>
<a name="a00181" id="a00181"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00181">&#9670;&nbsp;</a></span>RecoverInfo_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct RecoverInfo_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>An instance of this structure is stored in the designated register of the ALON domain, and points to where to find <a class="el" href="a00002.html#a00189">Marker_t</a>. This structure is stored in ALON and allows for the fastest initialization. If all these values are 0, either no logging is ongoing, or the battery has gone empty. To discover which case holds true, first <a class="el" href="a00002.html#a00185">Hint_t</a> is checked; if that fails too, the EEPROM is checked backwards for the location of a stored instance of type <a class="el" href="a00002.html#a00189">Marker_t</a> (which is time consuming). Once found, the correct values for this structure can be reconstructed. </p>

<p class="definition">Definition at line <a class="el" href="a00002_source.html#l00422">422</a> of file <a class="el" href="a00002_source.html">storage.c</a>.</p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a19ff9eb523714c0a8ad2e9bb66bfd795"></a>unsigned int</td>
<td class="fieldname">
eepromBitCursor: 15</td>
<td class="fielddoc">
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00002.html#a58f975c639a66a20d67533f8ed60ba9f">Storage_Instance_t.eepromBitCursor</a> </dd></dl>
</td></tr>
<tr><td class="fieldtype">
<a id="a5377eeb89bb3842b973532e7d6f6783e"></a>unsigned int</td>
<td class="fieldname">
sampleCacheCount: 4</td>
<td class="fielddoc">
<p>The number of samples that are cached in the general purpose registers. These are stored starting from <code>firstBitsOfCache</code> up to the last general purpose register. A value of 0 indicates no samples are cached. </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a63ba3b8a52fff252d5ea4c4730acd0a9"></a>unsigned int</td>
<td class="fieldname">
firstBitsOfCache: <a class="el" href="a00002.html#adc9121aaa97e1eca96c84b3425032118">FIRST_BITS_OF_CACHE_SIZE</a></td>
<td class="fielddoc">
<p>A filler. It allows to perform a sanity check at compile time on the size of RecoverInfo_s. </p>
</td></tr>
</table>

</div>
</div>
<a name="a00185" id="a00185"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00185">&#9670;&nbsp;</a></span>Hint_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct Hint_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>An instance of this structure is stored at the fixed location <a class="el" href="a00002.html#aacec9cac5ccd08a849aacd321d30d25b">HINT_ABSOLUTE_BYTE_OFFSET</a>, and points to where to find <a class="el" href="a00002.html#a00189">Marker_t</a>. If all the information contained is correct (which may not be the case) it still allows for a fast initialization.</p><ul>
<li><code>eepromBitCursor</code> <b>may</b> contain correct information. If not, the EEPROM is checked backwards for the location of a stored instance of type <a class="el" href="a00002.html#a00189">Marker_t</a> (which is time consuming) and this hint structure is adapted (so a next initialization under the same circumstances is done quickly).</li>
<li>The <a class="el" href="a00002.html#a00185">Hint_t</a> instance also contains a duplicate reference to flashByteCursor. This will be used when the marker is no longer available or is corrupt.</li>
</ul>

<p class="definition">Definition at line <a class="el" href="a00002_source.html#l00473">473</a> of file <a class="el" href="a00002_source.html">storage.c</a>.</p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a9880b814e5b49acb349afeec7d6567c0"></a>uint16_t</td>
<td class="fieldname">
eepromBitCursor</td>
<td class="fielddoc">
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00002.html#a58f975c639a66a20d67533f8ed60ba9f">Storage_Instance_t.eepromBitCursor</a> </dd></dl>
</td></tr>
<tr><td class="fieldtype">
<a id="a2faebc35280cdfbcf6858666593a832a"></a>uint16_t</td>
<td class="fieldname">
flashByteCursor</td>
<td class="fielddoc">
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00002.html#ad3aa100f3d8ee9fe205c5ea72f73fc0a">Storage_Instance_t.flashByteCursor</a> </dd></dl>
</td></tr>
</table>

</div>
</div>
<a name="a00189" id="a00189"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00189">&#9670;&nbsp;</a></span>Marker_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct Marker_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>An instance of this structure is stored in EEPROM, right after the end of the last sample in EEPROM. It is used to re-create <a class="el" href="a00002.html#a01ce7d8e7fc855bb5c49d4a50d66fc87">sInstance</a> upon initialization. Since a number of false candidates may be proposed, it contains a <code>header</code> and a <code>footer</code> to have a near 100% chance of detecting erroneous information. </p>

<p class="definition">Definition at line <a class="el" href="a00002_source.html#l00487">487</a> of file <a class="el" href="a00002_source.html">storage.c</a>.</p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="aeaabe1c7b1dfa48ad148dc901da68f49"></a>const int</td>
<td class="fieldname">
header</td>
<td class="fielddoc">
<p>Must equal <a class="el" href="a00002.html#a8a0e208f7ef4eb70204794ceeeddf93c">MARKER_HEADER</a>, or <code>flashByteCursor</code> is not valid. </p>
</td></tr>
<tr><td class="fieldtype">
<a id="ad3aa100f3d8ee9fe205c5ea72f73fc0a"></a>int</td>
<td class="fieldname">
flashByteCursor</td>
<td class="fielddoc">
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00002.html#ad3aa100f3d8ee9fe205c5ea72f73fc0a">Storage_Instance_t.flashByteCursor</a> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Usage<ul>
<li>RO in <a class="el" href="a00176.html#gad04fe4fa8e78ef5572e4a39dec188c31">Storage_Init</a>,</li>
<li>WO to set the value equal to <a class="el" href="a00002.html#ad3aa100f3d8ee9fe205c5ea72f73fc0a">Storage_Instance_t.flashByteCursor</a> in <a class="el" href="a00176.html#ga75abea0be7fefec6285224dc0f82f5ac">Storage_DeInit</a>, or to clear the marker from EEPROM in <a class="el" href="a00176.html#ga345ce91da83ce1cea789068dfb587ed5">Storage_Reset</a>,</li>
<li>not to be read, not to be written to at all other times.</li>
</ul>
</dd></dl>
</td></tr>
<tr><td class="fieldtype">
<a id="afc9158c5b1ed68b02ab94f81f2c577ff"></a>const int</td>
<td class="fieldname">
footer</td>
<td class="fielddoc">
<p>Must equal <a class="el" href="a00002.html#a9932f0627c3b75f5244245d134abcc49">MARKER_FOOTER</a>, or <code>flashByteCursor</code> is not valid. </p>
</td></tr>
</table>

</div>
</div>
<a name="a00193" id="a00193"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00193">&#9670;&nbsp;</a></span>Storage_Instance_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct Storage_Instance_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Stores all meta data to perform the requested reads and writes in FLASH and EEPROM. Upon de-initialization, an updated instance of <a class="el" href="a00002.html#a00189">Marker_t</a> is updated and stored in EEPROM, and an updated instance of <a class="el" href="a00002.html#a00181">RecoverInfo_t</a> is stored in the ALON domain, using the information in this structure. </p>

<p class="definition">Definition at line <a class="el" href="a00002_source.html#l00517">517</a> of file <a class="el" href="a00002_source.html">storage.c</a>.</p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a58f975c639a66a20d67533f8ed60ba9f"></a>int</td>
<td class="fieldname">
eepromBitCursor</td>
<td class="fielddoc">
<p>The position of the first bit where new data can be stored in EEPROM, relative to <a class="el" href="a00177.html#ga89fe1736e393062639f3d7b64e76eeed">STORAGE_EEPROM_FIRST_ROW</a>. This doubles up as the start position of a stored instance of type <a class="el" href="a00002.html#a00189">Marker_t</a> in EEPROM. There are at most <code>EEPROM_NR_OF_RW_ROWS</code> rows of EEPROM that can be used for storage, thus an EEPROM bit cursor always has values less than 2**15: 15 bits are required to store this information. </p>
</td></tr>
<tr><td class="fieldtype">
<a id="ad3aa100f3d8ee9fe205c5ea72f73fc0a"></a>int</td>
<td class="fieldname">
flashByteCursor</td>
<td class="fielddoc">
<p>The position of the first byte where new data can be stored in FLASH, relative to <a class="el" href="a00177.html#gadc56bda551d9bbea8ac33ac75c98ea6a">STORAGE_FLASH_FIRST_PAGE</a>. </p><dl class="section pre"><dt>Precondition</dt><dd>Must be 32-bit word-aligned: multiple FLASH writes in the same page must occur at word boundaries. See <a class="el" href="a00002.html#a7b5a80c719faf51e26891ceb706885cd">FLASH_BLOCK_SIZE</a> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>There are at most (FLASH_NR_OF_RW_SECTORS * FLASH_PAGES_PER_SECTOR - program size) pages of FLASH that can be used for storage, thus a FLASH byte cursor always has values less than 2**15; and due to the boundary requirement, the 2 LSBits must be 0 as well: 13 bits are thus required to store this information. Masking with <a class="el" href="a00002.html#a26ce4ace770f604410e5a7be24569165">MARKER_CURSOR_ZERO_MASK</a> must thus always yield a <code>0</code> value. </dd></dl>
</td></tr>
<tr><td class="fieldtype">
<a id="a6103a665934c2fded6d0d2b7eebe4170"></a><a class="el" href="a00002.html#a9fada3091f6ac60680d7c64c2ac6c1db">LOCATION_T</a></td>
<td class="fieldname">
readLocation</td>
<td class="fielddoc">
<p>Indicates the type of memory to <code>readCursor</code> targets. It also defines the type of <code>readCursor:</code> a byte cursor or a bit cursor. </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a4148519f5b12cc7c380f98d9bb4e695c"></a>int</td>
<td class="fieldname">
readCursor</td>
<td class="fielddoc">
<ul>
<li>If <code>readLocation</code> equals <a class="el" href="a00002.html#a9fada3091f6ac60680d7c64c2ac6c1dba484c54b5bbce80e5b6bee441fc9bb1aa">LOCATION_FLASH</a>: the offset in bytes relative to <a class="el" href="a00002.html#a8a025359621a3e72503e8f5822477926">FLASH_FIRST_BYTE_ADDRESS</a> where to read next in FLASH. This points to the two-byte header that precedes a (compressed) data block, stored in FLASH.</li>
<li>If <code>readLocation</code> equals <a class="el" href="a00002.html#a9fada3091f6ac60680d7c64c2ac6c1dba113ac2c7d5cdbeff51d8b9a111efc8ca">LOCATION_EEPROM</a>: the offset in bits relative to <a class="el" href="a00002.html#a51097af3fdea45986851a90fe37982b1">EEPROM_ABSOLUTE_FIRST_BYTE_OFFSET</a> where to read next in EEPROM. This points to the position of the LSBit of the next sample to read.</li>
<li>If <code>readLocation</code> equals <a class="el" href="a00002.html#a9fada3091f6ac60680d7c64c2ac6c1dbac1d84d000f28e68468e21ab6788872b1">LOCATION_CACHE</a>: a relative index. The index of the sample that is stored in the cache. <code>0</code> indicates the oldest sample still present in the cache. <dl class="section note"><dt>Note</dt><dd>A negative value indicates nothing can be read. A call to <a class="el" href="a00176.html#ga82112f49c64c590b321e1e02caf077f5">Storage_Seek</a> is then required. </dd></dl>
</li>
</ul>
</td></tr>
<tr><td class="fieldtype">
<a id="a031518419e5ad587f3fe455a134417ff"></a>int</td>
<td class="fieldname">
readSequence</td>
<td class="fielddoc">
<p>A sequence number to help identify where the next sample, which must be read out, is located.</p><ul>
<li>In case of reading from FLASH, where (compressed) blocks of samples are stored, this is the absolute sequence number of the first sample in that block after decompressing.</li>
<li>In case of reading from EEPROM, this is the absolute sequence number of the sample <code>readCursor</code> points to.</li>
<li>In case of reading from sCache, this is the absolute sequence number of the sample <code>readCursor</code> points to. The very first sample written via <a class="el" href="a00176.html#ga820a105a6412fe21e8598f2c682664af">Storage_Write</a> has sequence number 0. <dl class="section note"><dt>Note</dt><dd>A negative value indicates nothing can be read. A call to <a class="el" href="a00176.html#ga82112f49c64c590b321e1e02caf077f5">Storage_Seek</a> is then required. </dd></dl>
</li>
</ul>
</td></tr>
<tr><td class="fieldtype">
<a id="a383f9c95e3ca53358c339bcb34d790ff"></a>int</td>
<td class="fieldname">
targetSequence</td>
<td class="fielddoc">
<p>The sequence number that was requested in the last call to <a class="el" href="a00176.html#ga82112f49c64c590b321e1e02caf077f5">Storage_Seek</a>.</p><ul>
<li>This value equals <code>readSequence</code> in case <code>readLocation</code> equals <a class="el" href="a00002.html#a9fada3091f6ac60680d7c64c2ac6c1dba113ac2c7d5cdbeff51d8b9a111efc8ca">LOCATION_EEPROM</a> or <a class="el" href="a00002.html#a9fada3091f6ac60680d7c64c2ac6c1dbac1d84d000f28e68468e21ab6788872b1">LOCATION_CACHE</a></li>
<li>This value may be equal - but is unlikely to - in case <code>readLocation</code> equals <a class="el" href="a00002.html#a9fada3091f6ac60680d7c64c2ac6c1dba484c54b5bbce80e5b6bee441fc9bb1aa">LOCATION_FLASH</a></li>
</ul>
</td></tr>
<tr><td class="fieldtype">
<a id="a36c92d4cd422f38a0ed072ba02fc1633"></a>int</td>
<td class="fieldname">
cachedBlockOffset</td>
<td class="fielddoc">
<p>Determines what contents are available in <a class="el" href="a00002.html#a95fd6ccd851ad8813a21f6ade2190084">STORAGE_WORKAREA</a>.</p><ul>
<li>The flash byte offset relative to <a class="el" href="a00002.html#a8a025359621a3e72503e8f5822477926">FLASH_FIRST_BYTE_ADDRESS</a> where the header preceding the (compressed) data block can be found; these contents are decompressed and the samples, packed without padding bits, are available from the start of <a class="el" href="a00002.html#a95fd6ccd851ad8813a21f6ade2190084">STORAGE_WORKAREA</a>.</li>
<li><code>-1</code> if <a class="el" href="a00002.html#a95fd6ccd851ad8813a21f6ade2190084">STORAGE_WORKAREA</a> does not contain samples after decompressing a data block stored in FLASH, or if <a class="el" href="a00002.html#a95fd6ccd851ad8813a21f6ade2190084">STORAGE_WORKAREA</a> is used to compress data.</li>
</ul>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a51097af3fdea45986851a90fe37982b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51097af3fdea45986851a90fe37982b1">&#9670;&nbsp;</a></span>EEPROM_ABSOLUTE_FIRST_BYTE_OFFSET</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EEPROM_ABSOLUTE_FIRST_BYTE_OFFSET&#160;&#160;&#160;(<a class="el" href="a00177.html#ga89fe1736e393062639f3d7b64e76eeed">STORAGE_EEPROM_FIRST_ROW</a> * EEPROM_ROW_SIZE)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The absolute offset to the very first byte of the assigned EEPROM region. </p><dl class="section note"><dt>Note</dt><dd>Unless explicitly specified, all bit and byte offsets referring to the EEPROM region in the code are relative to this value. </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00002_source.html#l00310">310</a> of file <a class="el" href="a00002_source.html">storage.c</a>.</p>

<p class="reference">Referenced by <a class="el" href="a00002_source.html#l00966">FindMarker()</a>, <a class="el" href="a00002_source.html#l01160">MoveSamplesFromEepromToFlash()</a>, <a class="el" href="a00002_source.html#l00942">ReadFromEeprom()</a>, <a class="el" href="a00002_source.html#l01425">Storage_Init()</a>, <a class="el" href="a00002_source.html#l01369">ValidateHint()</a>, <a class="el" href="a00002_source.html#l01397">WriteHint()</a>, and <a class="el" href="a00002_source.html#l00912">WriteToEeprom()</a>.</p>

</div>
</div>
<a id="a5d3116589e95d45f43dd42e5ba138b57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d3116589e95d45f43dd42e5ba138b57">&#9670;&nbsp;</a></span>EEPROM_ABSOLUTE_LAST_BYTE_OFFSET</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EEPROM_ABSOLUTE_LAST_BYTE_OFFSET&#160;&#160;&#160;(((<a class="el" href="a00177.html#ga601793e23c7072b845356fc186966c19">STORAGE_EEPROM_LAST_ROW</a> + 1) * EEPROM_ROW_SIZE) - 1)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The absolute offset to the very last byte of the assigned EEPROM region. </p>

<p class="definition">Definition at line <a class="el" href="a00002_source.html#l00314">314</a> of file <a class="el" href="a00002_source.html">storage.c</a>.</p>

<p class="reference">Referenced by <a class="el" href="a00002_source.html#l00966">FindMarker()</a>.</p>

</div>
</div>
<a id="a7ea11f64fe607c5e2512425195ad5d73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ea11f64fe607c5e2512425195ad5d73">&#9670;&nbsp;</a></span>FLASH_CURSOR_TO_BYTE_ADDRESS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FLASH_CURSOR_TO_BYTE_ADDRESS</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">flashByteCursor</td><td>)</td>
          <td>&#160;&#160;&#160;((uint8_t *)(FLASH_START + (<a class="el" href="a00177.html#gadc56bda551d9bbea8ac33ac75c98ea6a">STORAGE_FLASH_FIRST_PAGE</a> * FLASH_PAGE_SIZE) + (flashByteCursor)))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Translates a flash byte cursor relative to assigned FLASH region to a byte address. </p>

<p class="definition">Definition at line <a class="el" href="a00002_source.html#l00317">317</a> of file <a class="el" href="a00002_source.html">storage.c</a>.</p>

<p class="reference">Referenced by <a class="el" href="a00002_source.html#l01034">GetFlashCount()</a>, <a class="el" href="a00002_source.html#l01160">MoveSamplesFromEepromToFlash()</a>, <a class="el" href="a00002_source.html#l01300">ReadAndCacheSamplesFromFlash()</a>, <a class="el" href="a00002_source.html#l01681">Storage_Seek()</a>, and <a class="el" href="a00002_source.html#l01351">ValidateMarker()</a>.</p>

</div>
</div>
<a id="a107742a2e13dcf6270ce8da63f1784fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a107742a2e13dcf6270ce8da63f1784fb">&#9670;&nbsp;</a></span>FLASH_CURSOR_TO_PAGE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FLASH_CURSOR_TO_PAGE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">flashByteCursor</td><td>)</td>
          <td>&#160;&#160;&#160;(<a class="el" href="a00177.html#gadc56bda551d9bbea8ac33ac75c98ea6a">STORAGE_FLASH_FIRST_PAGE</a> + ((flashByteCursor) / FLASH_PAGE_SIZE))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Translates a FLASH byte cursor relative to assigned FLASH region to the number of the page the cursor refers to. </p>

<p class="definition">Definition at line <a class="el" href="a00002_source.html#l00321">321</a> of file <a class="el" href="a00002_source.html">storage.c</a>.</p>

<p class="reference">Referenced by <a class="el" href="a00002_source.html#l01160">MoveSamplesFromEepromToFlash()</a>.</p>

</div>
</div>
<a id="a83e5cf92d3e947253bc6e83c0c8d9e77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83e5cf92d3e947253bc6e83c0c8d9e77">&#9670;&nbsp;</a></span>FLASH_PAGE_TO_ADDRESS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FLASH_PAGE_TO_ADDRESS</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">type, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">flashPage&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;((type)(FLASH_START + ((flashPage) * FLASH_PAGE_SIZE)))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Translates a FLASH page number to the start address of that page. </p>

<p class="definition">Definition at line <a class="el" href="a00002_source.html#l00324">324</a> of file <a class="el" href="a00002_source.html">storage.c</a>.</p>

</div>
</div>
<a id="a8a025359621a3e72503e8f5822477926"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a025359621a3e72503e8f5822477926">&#9670;&nbsp;</a></span>FLASH_FIRST_BYTE_ADDRESS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FLASH_FIRST_BYTE_ADDRESS&#160;&#160;&#160;<a class="el" href="a00002.html#a83e5cf92d3e947253bc6e83c0c8d9e77">FLASH_PAGE_TO_ADDRESS</a>(uint8_t *, <a class="el" href="a00177.html#gadc56bda551d9bbea8ac33ac75c98ea6a">STORAGE_FLASH_FIRST_PAGE</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The very first byte address of the assigned FLASH region. </p>

<p class="definition">Definition at line <a class="el" href="a00002_source.html#l00327">327</a> of file <a class="el" href="a00002_source.html">storage.c</a>.</p>

</div>
</div>
<a id="aa1801230677612489a71fceeefadfcd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1801230677612489a71fceeefadfcd0">&#9670;&nbsp;</a></span>FLASH_LAST_BYTE_ADDRESS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FLASH_LAST_BYTE_ADDRESS&#160;&#160;&#160;(<a class="el" href="a00002.html#a83e5cf92d3e947253bc6e83c0c8d9e77">FLASH_PAGE_TO_ADDRESS</a>(uint8_t *, <a class="el" href="a00177.html#gaa9d5b61492e536833e7ae705d1888f07">STORAGE_FLASH_LAST_PAGE</a> + 1) - 1)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The very last byte address of the assigned FLASH region. </p>

<p class="definition">Definition at line <a class="el" href="a00002_source.html#l00330">330</a> of file <a class="el" href="a00002_source.html">storage.c</a>.</p>

<p class="reference">Referenced by <a class="el" href="a00002_source.html#l01160">MoveSamplesFromEepromToFlash()</a>, and <a class="el" href="a00002_source.html#l01351">ValidateMarker()</a>.</p>

</div>
</div>
<a id="a79ab8f2629e16d6de78e765b2cbbbe15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79ab8f2629e16d6de78e765b2cbbbe15">&#9670;&nbsp;</a></span>FLASH_FIRST_WORD_ADDRESS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FLASH_FIRST_WORD_ADDRESS&#160;&#160;&#160;<a class="el" href="a00002.html#a83e5cf92d3e947253bc6e83c0c8d9e77">FLASH_PAGE_TO_ADDRESS</a>(uint32_t *, <a class="el" href="a00177.html#gadc56bda551d9bbea8ac33ac75c98ea6a">STORAGE_FLASH_FIRST_PAGE</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The very first 32-bit word address of the assigned FLASH region. </p>

<p class="definition">Definition at line <a class="el" href="a00002_source.html#l00333">333</a> of file <a class="el" href="a00002_source.html">storage.c</a>.</p>

<p class="reference">Referenced by <a class="el" href="a00002_source.html#l01535">Storage_Reset()</a>.</p>

</div>
</div>
<a id="ac264ea0b58d6d8daf0b68eb8d1502233"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac264ea0b58d6d8daf0b68eb8d1502233">&#9670;&nbsp;</a></span>FLASH_LAST_WORD_ADDRESS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FLASH_LAST_WORD_ADDRESS&#160;&#160;&#160;(<a class="el" href="a00002.html#a83e5cf92d3e947253bc6e83c0c8d9e77">FLASH_PAGE_TO_ADDRESS</a>(uint32_t *, <a class="el" href="a00177.html#gaa9d5b61492e536833e7ae705d1888f07">STORAGE_FLASH_LAST_PAGE</a> + 1) - 1)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The very last WORD address of the assigned FLASH region. </p>

<p class="definition">Definition at line <a class="el" href="a00002_source.html#l00336">336</a> of file <a class="el" href="a00002_source.html">storage.c</a>.</p>

<p class="reference">Referenced by <a class="el" href="a00002_source.html#l01535">Storage_Reset()</a>.</p>

</div>
</div>
<a id="a4b7ab7ad7715d7364693a5224f85a937"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b7ab7ad7715d7364693a5224f85a937">&#9670;&nbsp;</a></span>FLASH_DATA_HEADER_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FLASH_DATA_HEADER_SIZE&#160;&#160;&#160;<a class="el" href="a00177.html#ga2cf237c4f6960deeb7e47e092b5094fc">STORAGE_BLOCK_HEADER_SIZE</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The size in bytes of the meta data stored just in front of the (compressed) data block in FLASH. The LSBit of the first byte after these header size contains the start of the (compressed) data block. This header is used to give the decompress callback the correct arguments, and to deduce where to find the next block. </p><dl class="section note"><dt>Note</dt><dd>Either this size is a value greater than 0 but less than <a class="el" href="a00177.html#ga3528a0fe95f4434f065d3824c488debc">STORAGE_UNCOMPRESSED_BLOCK_SIZE_IN_BITS</a>, which indicates the contents have been compressed; either this size is equal to <a class="el" href="a00177.html#ga3528a0fe95f4434f065d3824c488debc">STORAGE_UNCOMPRESSED_BLOCK_SIZE_IN_BITS</a> which indicates no compression/decompression algorithm was set or compression yielded bad results on this block and therefore the block was stored uncompressed. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00002.html#a7b5a80c719faf51e26891ceb706885cd">FLASH_BLOCK_SIZE</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00002_source.html#l00349">349</a> of file <a class="el" href="a00002_source.html">storage.c</a>.</p>

<p class="reference">Referenced by <a class="el" href="a00002_source.html#l01160">MoveSamplesFromEepromToFlash()</a>, and <a class="el" href="a00002_source.html#l01300">ReadAndCacheSamplesFromFlash()</a>.</p>

</div>
</div>
<a id="a7b5a80c719faf51e26891ceb706885cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b5a80c719faf51e26891ceb706885cd">&#9670;&nbsp;</a></span>FLASH_BLOCK_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FLASH_BLOCK_SIZE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">bitCount</td><td>)</td>
          <td>&#160;&#160;&#160;(4 * <a class="el" href="a00177.html#gad5156aa8d4f9dc31fcd5ff6efc9f5e42">STORAGE_IDIVUP</a>((bitCount) + <a class="el" href="a00002.html#a4b7ab7ad7715d7364693a5224f85a937">FLASH_DATA_HEADER_SIZE</a> * 8, 32))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given the header value of a (compressed) data block in FLASH, calculates the size in bytes of the complete block, <b>including</b> <a class="el" href="a00002.html#a4b7ab7ad7715d7364693a5224f85a937">FLASH_DATA_HEADER_SIZE</a>. The start of a new block <b>must</b> <code>always</code> be stored on a 32-bit word boundary: this allows to continue writing the same page without erasing. As a consequence, up to 31 padding bits after the end of previous (compressed) data block are lost. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bitCount</td><td>The size in bits of the (compressed) data block, <b>excluding</b> <a class="el" href="a00002.html#a4b7ab7ad7715d7364693a5224f85a937">FLASH_DATA_HEADER_SIZE</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>From the FLASH specification: <em>It is possible to write only a sub-set of the page (Y words), but the maximum number of times that a page can be written to, before an erase must be performed, is 16. WARNING: Writing a page more than 16 times without erasing may result in corrupting the page’s contents, due to write disturb (an intrinsic mechanism to the programming mechanism of the C14EFLASH)</em></li>
<li>From the NVMC datasheet: <em>Due to the presence of ECC, it is not allowed to modify additional bits inside a memory word where some bits have already been programmed: the resulting ECC code in memory would then be the AND of the codes for the previous and new value written, and will most likely be inconsistent with the resulting data, potentially resulting in unwanted or missing bit corrections, or spurious error conditions. [C-NODPG]</em></li>
</ul>
</dd></dl>

<p class="definition">Definition at line <a class="el" href="a00002_source.html#l00373">373</a> of file <a class="el" href="a00002_source.html">storage.c</a>.</p>

<p class="reference">Referenced by <a class="el" href="a00002_source.html#l01034">GetFlashCount()</a>, <a class="el" href="a00002_source.html#l01160">MoveSamplesFromEepromToFlash()</a>, <a class="el" href="a00002_source.html#l01300">ReadAndCacheSamplesFromFlash()</a>, and <a class="el" href="a00002_source.html#l01681">Storage_Seek()</a>.</p>

</div>
</div>
<a id="a8a0e208f7ef4eb70204794ceeeddf93c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a0e208f7ef4eb70204794ceeeddf93c">&#9670;&nbsp;</a></span>MARKER_HEADER</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MARKER_HEADER&#160;&#160;&#160;((int)0x0000FFFF)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The first of two special values that are used in <a class="el" href="a00002.html#a00189">Marker_t</a> to be able to reconstruct the EEPROM and FLASH bit cursor in case the battery has died - and thus the register value has been reset to zero. </p><dl class="section note"><dt>Note</dt><dd>These values are not chosen randomly: the code using them - <a class="el" href="a00002.html#a6a819a5d10e6edaab80a62b5832a4c59">FindMarker</a> - is depending on their specific bit values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00002_source.html#l00381">381</a> of file <a class="el" href="a00002_source.html">storage.c</a>.</p>

<p class="reference">Referenced by <a class="el" href="a00002_source.html#l01351">ValidateMarker()</a>, and <a class="el" href="a00002_source.html#l01417">WriteMarker()</a>.</p>

</div>
</div>
<a id="a9932f0627c3b75f5244245d134abcc49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9932f0627c3b75f5244245d134abcc49">&#9670;&nbsp;</a></span>MARKER_FOOTER</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MARKER_FOOTER&#160;&#160;&#160;((int)0x7FFFFFFF)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The second special value. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="a00002.html#a8a0e208f7ef4eb70204794ceeeddf93c">MARKER_HEADER</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00002_source.html#l00382">382</a> of file <a class="el" href="a00002_source.html">storage.c</a>.</p>

<p class="reference">Referenced by <a class="el" href="a00002_source.html#l01351">ValidateMarker()</a>, and <a class="el" href="a00002_source.html#l01417">WriteMarker()</a>.</p>

</div>
</div>
<a id="a26ce4ace770f604410e5a7be24569165"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26ce4ace770f604410e5a7be24569165">&#9670;&nbsp;</a></span>MARKER_CURSOR_ZERO_MASK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MARKER_CURSOR_ZERO_MASK&#160;&#160;&#160;0xFFFF8003</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The mask to use to zero out all possible 1 bits in <a class="el" href="a00002.html#ad3aa100f3d8ee9fe205c5ea72f73fc0a">Marker_t.flashByteCursor</a> </p>

<p class="definition">Definition at line <a class="el" href="a00002_source.html#l00385">385</a> of file <a class="el" href="a00002_source.html">storage.c</a>.</p>

<p class="reference">Referenced by <a class="el" href="a00002_source.html#l01351">ValidateMarker()</a>.</p>

</div>
</div>
<a id="adc56bda551d9bbea8ac33ac75c98ea6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc56bda551d9bbea8ac33ac75c98ea6a">&#9670;&nbsp;</a></span>STORAGE_FLASH_FIRST_PAGE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define STORAGE_FLASH_FIRST_PAGE&#160;&#160;&#160;<a class="el" href="a00002.html#a6a400e06f2edf1ffc365a5e2e64c6d31">sStorageFlashFirstPage</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="a00002_source.html#l00396">396</a> of file <a class="el" href="a00002_source.html">storage.c</a>.</p>

<p class="reference">Referenced by <a class="el" href="a00002_source.html#l01160">MoveSamplesFromEepromToFlash()</a>, and <a class="el" href="a00002_source.html#l01535">Storage_Reset()</a>.</p>

</div>
</div>
<a id="adc9121aaa97e1eca96c84b3425032118"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc9121aaa97e1eca96c84b3425032118">&#9670;&nbsp;</a></span>FIRST_BITS_OF_CACHE_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FIRST_BITS_OF_CACHE_SIZE&#160;&#160;&#160;13</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The size of the first bits of the cache, in the same general purpose register where <a class="el" href="a00002.html#a00181">RecoverInfo_t</a> is stored. </p>

<p class="definition">Definition at line <a class="el" href="a00002_source.html#l00412">412</a> of file <a class="el" href="a00002_source.html">storage.c</a>.</p>

<p class="reference">Referenced by <a class="el" href="a00002_source.html#l00868">CacheSample()</a>, and <a class="el" href="a00002_source.html#l00890">GetCachedSample()</a>.</p>

</div>
</div>
<a id="a18d649f1561f0c860e484c7fdf9df74a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18d649f1561f0c860e484c7fdf9df74a">&#9670;&nbsp;</a></span>SIZE_OF_HINT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SIZE_OF_HINT&#160;&#160;&#160;4</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Byte size of <a class="el" href="a00002.html#a00185">Hint_t</a>. Checked at compile time using <a class="el" href="a00002.html#a9292a35f74c15d75bfbe8b6cfda6a3a3">checkSizeOfHint</a>. </p>

<p class="definition">Definition at line <a class="el" href="a00002_source.html#l00437">437</a> of file <a class="el" href="a00002_source.html">storage.c</a>.</p>

</div>
</div>
<a id="a75ed8bd26aca85af0d2f11a01ef28880"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75ed8bd26aca85af0d2f11a01ef28880">&#9670;&nbsp;</a></span>INVERSE_HINT_ABSOLUTE_BYTE_OFFSET</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define INVERSE_HINT_ABSOLUTE_BYTE_OFFSET&#160;&#160;&#160;((<a class="el" href="a00002.html#a5d3116589e95d45f43dd42e5ba138b57">EEPROM_ABSOLUTE_LAST_BYTE_OFFSET</a> + 1 - <a class="el" href="a00002.html#a18d649f1561f0c860e484c7fdf9df74a">SIZE_OF_HINT</a>))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The absolute offset to a copy of the hint structure, to validate its contents. </p>

<p class="definition">Definition at line <a class="el" href="a00002_source.html#l00440">440</a> of file <a class="el" href="a00002_source.html">storage.c</a>.</p>

<p class="reference">Referenced by <a class="el" href="a00002_source.html#l01369">ValidateHint()</a>, and <a class="el" href="a00002_source.html#l01397">WriteHint()</a>.</p>

</div>
</div>
<a id="aacec9cac5ccd08a849aacd321d30d25b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacec9cac5ccd08a849aacd321d30d25b">&#9670;&nbsp;</a></span>HINT_ABSOLUTE_BYTE_OFFSET</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define HINT_ABSOLUTE_BYTE_OFFSET&#160;&#160;&#160;(<a class="el" href="a00002.html#a75ed8bd26aca85af0d2f11a01ef28880">INVERSE_HINT_ABSOLUTE_BYTE_OFFSET</a> - <a class="el" href="a00002.html#a18d649f1561f0c860e484c7fdf9df74a">SIZE_OF_HINT</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The absolute offset to <a class="el" href="a00002.html#a00185">Hint_t</a> at the end of the assigned EEPROM region. </p>

<p class="definition">Definition at line <a class="el" href="a00002_source.html#l00443">443</a> of file <a class="el" href="a00002_source.html">storage.c</a>.</p>

<p class="reference">Referenced by <a class="el" href="a00002_source.html#l01505">Storage_DeInit()</a>, <a class="el" href="a00002_source.html#l01425">Storage_Init()</a>, <a class="el" href="a00002_source.html#l01535">Storage_Reset()</a>, and <a class="el" href="a00002_source.html#l01397">WriteHint()</a>.</p>

</div>
</div>
<a id="a2d7b6ac9b0010a76e7219a9e45c59362"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d7b6ac9b0010a76e7219a9e45c59362">&#9670;&nbsp;</a></span>SIZE_OF_DUPLICATE_DATA</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SIZE_OF_DUPLICATE_DATA&#160;&#160;&#160;64</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Byte size of the duplicate information. </p>

<p class="definition">Definition at line <a class="el" href="a00002_source.html#l00452">452</a> of file <a class="el" href="a00002_source.html">storage.c</a>.</p>

<p class="reference">Referenced by <a class="el" href="a00002_source.html#l01425">Storage_Init()</a>, and <a class="el" href="a00002_source.html#l01397">WriteHint()</a>.</p>

</div>
</div>
<a id="a0b65ffe06d12a5ce4a0ac3dbc5184022"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b65ffe06d12a5ce4a0ac3dbc5184022">&#9670;&nbsp;</a></span>DUPLICATE_DATA_ABSOLUTE_BYTE_OFFSET</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DUPLICATE_DATA_ABSOLUTE_BYTE_OFFSET&#160;&#160;&#160;(<a class="el" href="a00002.html#a5d3116589e95d45f43dd42e5ba138b57">EEPROM_ABSOLUTE_LAST_BYTE_OFFSET</a> + 1 - (2 * EEPROM_ROW_SIZE))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The absolute offset to the recovery information at the end of the assigned EEPROM region. </p>

<p class="definition">Definition at line <a class="el" href="a00002_source.html#l00459">459</a> of file <a class="el" href="a00002_source.html">storage.c</a>.</p>

<p class="reference">Referenced by <a class="el" href="a00002_source.html#l01425">Storage_Init()</a>, and <a class="el" href="a00002_source.html#l01397">WriteHint()</a>.</p>

</div>
</div>
<a id="ab6a3b701867c86fd64359d2b105548b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6a3b701867c86fd64359d2b105548b1">&#9670;&nbsp;</a></span>SIZE_OF_MARKER</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SIZE_OF_MARKER&#160;&#160;&#160;12</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The total number of bytes in EEPROM consumed by meta-data, to be able to keep track of what is stored in FLASH and EEPROM, even after a power-off. Apart from <a class="el" href="a00002.html#a00189">Marker_t</a>, there is an additional bit that marks whether the storage in FLASH and EEPROM is empty or at least one sample is stored in EEPROM - </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="a00002.html#a00185">Hint_t</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00002_source.html#l00510">510</a> of file <a class="el" href="a00002_source.html">storage.c</a>.</p>

</div>
</div>
<a id="a756a1be4b449a2c065c2d40436328356"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a756a1be4b449a2c065c2d40436328356">&#9670;&nbsp;</a></span>EEPROM_OVERHEAD_IN_BITS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EEPROM_OVERHEAD_IN_BITS&#160;&#160;&#160;((<a class="el" href="a00002.html#ab6a3b701867c86fd64359d2b105548b1">SIZE_OF_MARKER</a> + 2 * EEPROM_ROW_SIZE) * 8)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The assigned EEPROM region cannot be used fully: there must be always room for <a class="el" href="a00002.html#a00189">Marker_t</a> and the last couple of bytes are used to <a class="el" href="a00002.html#a00185">Hint_t</a>. To avoid corruption in both the marker and the hint, the hint is placed in a separate row. The total overhead is summed up here. </p>

<p class="definition">Definition at line <a class="el" href="a00002_source.html#l00600">600</a> of file <a class="el" href="a00002_source.html">storage.c</a>.</p>

<p class="reference">Referenced by <a class="el" href="a00002_source.html#l00966">FindMarker()</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a9fada3091f6ac60680d7c64c2ac6c1db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fada3091f6ac60680d7c64c2ac6c1db">&#9670;&nbsp;</a></span>LOCATION_T</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="a00002.html#a9fada3091f6ac60680d7c64c2ac6c1db">LOCATION_T</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00002.html#a6103a665934c2fded6d0d2b7eebe4170">Storage_Instance_t.readLocation</a> </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a9fada3091f6ac60680d7c64c2ac6c1dba32ce5f5a38b3b3e48bf355fe2d5f04fe"></a>LOCATION_UNKNOWN&#160;</td><td class="fielddoc"><p>A successful call to <a class="el" href="a00176.html#ga82112f49c64c590b321e1e02caf077f5">Storage_Seek</a> is required. </p>
</td></tr>
<tr><td class="fieldname"><a id="a9fada3091f6ac60680d7c64c2ac6c1dbac1d84d000f28e68468e21ab6788872b1"></a>LOCATION_CACHE&#160;</td><td class="fielddoc"><p>Memory in the assigned general purpose registers is targeted. </p>
</td></tr>
<tr><td class="fieldname"><a id="a9fada3091f6ac60680d7c64c2ac6c1dba113ac2c7d5cdbeff51d8b9a111efc8ca"></a>LOCATION_EEPROM&#160;</td><td class="fielddoc"><p>Memory in the assigned EEPROM region is targeted. </p>
</td></tr>
<tr><td class="fieldname"><a id="a9fada3091f6ac60680d7c64c2ac6c1dba484c54b5bbce80e5b6bee441fc9bb1aa"></a>LOCATION_FLASH&#160;</td><td class="fielddoc"><p>Memory in the assigned FLASH region is targeted. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="a00002_source.html#l00402">402</a> of file <a class="el" href="a00002_source.html">storage.c</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="aaa81898e5c033740fad627b87fed62af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa81898e5c033740fad627b87fed62af">&#9670;&nbsp;</a></span>STORAGE_COMPRESS_CB()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int STORAGE_COMPRESS_CB </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>eepromByteOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bitCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pOut</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="a00002_source.html#l01160">MoveSamplesFromEepromToFlash()</a>.</p>

</div>
</div>
<a id="a6edf730655366069960c566384171a4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6edf730655366069960c566384171a4b">&#9670;&nbsp;</a></span>STORAGE_DECOMPRESS_CB()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int STORAGE_DECOMPRESS_CB </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>pData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bitCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pOut</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="a00002_source.html#l01300">ReadAndCacheSamplesFromFlash()</a>.</p>

</div>
</div>
<a id="a7234e2804def46fd82a323c29988a4ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7234e2804def46fd82a323c29988a4ea">&#9670;&nbsp;</a></span>Storage_DummyCompressCb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Storage_DummyCompressCb </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>eepromByteOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bitCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pOut</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is a dummy implementation to provoke fallback behavior: a plain copy from EEPROM to FLASH. It is only used when <a class="el" href="a00002.html#aaa81898e5c033740fad627b87fed62af">STORAGE_COMPRESS_CB</a> is not overridden in an application specific <code>app_sel.h</code> header file </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="a00176.html#gab7c664a0e73ef251f2e68bbd23d6cabb">pStorage_CompressCb_t</a> </dd>
<dd>
<a class="el" href="a00002.html#aaa81898e5c033740fad627b87fed62af">STORAGE_COMPRESS_CB</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eepromByteOffset</td><td>unused </td></tr>
    <tr><td class="paramname">bitCount</td><td>unused </td></tr>
    <tr><td class="paramname">pOut</td><td>unused </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>0</code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00002_source.html#l00681">681</a> of file <a class="el" href="a00002_source.html">storage.c</a>.</p>

</div>
</div>
<a id="aaf1fb0ad99cd535196907129c71f1e9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf1fb0ad99cd535196907129c71f1e9e">&#9670;&nbsp;</a></span>Storage_DummyDecompressCb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Storage_DummyDecompressCb </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>pData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bitCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pOut</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is a dummy implementation to provoke a failure; it should normally never be called, since the dummy compression implementation will provoke the fallback behavior: a plain copy from EEPROM to FLASH, and vice-versa while reading. It is only used when <a class="el" href="a00002.html#aaa81898e5c033740fad627b87fed62af">STORAGE_COMPRESS_CB</a> is not overridden in an application specific <code>app_sel.h</code> header file </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="a00176.html#gafb11c3cdbd067dcbbe54bac47ba3c6ff">pStorage_DecompressCb_t</a> </dd>
<dd>
<a class="el" href="a00002.html#a6edf730655366069960c566384171a4b">STORAGE_DECOMPRESS_CB</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pData</td><td>unused </td></tr>
    <tr><td class="paramname">bitCount</td><td>unused </td></tr>
    <tr><td class="paramname">pOut</td><td>unused </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>0</code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00002_source.html#l00696">696</a> of file <a class="el" href="a00002_source.html">storage.c</a>.</p>

</div>
</div>
<a id="a7f26aa199deb27574f998a3f95868d8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f26aa199deb27574f998a3f95868d8a">&#9670;&nbsp;</a></span>ResetInstance()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void ResetInstance </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Re-initializes <a class="el" href="a00002.html#a01ce7d8e7fc855bb5c49d4a50d66fc87">sInstance</a> with default values. </p><dl class="section note"><dt>Note</dt><dd>No EEPROM reads or writes, no FLASH reads or writes are done. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>sBitCursorChanged is set when samples have become inaccessible. </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00002_source.html#l00735">735</a> of file <a class="el" href="a00002_source.html">storage.c</a>.</p>

<p class="reference">Referenced by <a class="el" href="a00002_source.html#l01425">Storage_Init()</a>, and <a class="el" href="a00002_source.html#l01535">Storage_Reset()</a>.</p>

</div>
</div>
<a id="a061322d6eab88dc08412bf159efd914b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a061322d6eab88dc08412bf159efd914b">&#9670;&nbsp;</a></span>ShiftAlignedData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void ShiftAlignedData </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pTo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>pFrom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>bitAlignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>bitCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copies a number of bits of byte aligned data to a buffer, non-byte aligned. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pTo</td><td>The location to copy to. A number of LSBits of the first byte are not touched. </td></tr>
    <tr><td class="paramname">pFrom</td><td>The location to copy from. The first bit to copy will become the LSBit of the first byte in this buffer. </td></tr>
    <tr><td class="paramname">bitAlignment</td><td>The number of bits to disregard in <code>to</code>. Must be less than <code>8</code>. </td></tr>
    <tr><td class="paramname">bitCount</td><td>The number of bits to copy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><div class="fragment"><div class="line"><a class="code" href="a00177.html#gad5156aa8d4f9dc31fcd5ff6efc9f5e42">STORAGE_IDIVUP</a>(bitCount, 8) </div></div><!-- fragment --> bytes must be available in <code>from</code>. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><div class="fragment"><div class="line"><a class="code" href="a00177.html#gad5156aa8d4f9dc31fcd5ff6efc9f5e42">STORAGE_IDIVUP</a>(bitCount + bitAlignment, 8) </div></div><!-- fragment --> bytes will be written to <code>to</code>. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The first <code>bitAlignment</code> bits of the first byte written to are not touched. </dd>
<dd>
For example, use this function to move bits in this way:<ul>
<li>With <code>-</code> indicating not touched or don't care,</li>
<li><code>bitAlignment</code> equal to <code>5</code>, and</li>
<li><code>bitCount</code> equal to <code>14</code>:</li>
</ul>
<div class="fragment"><div class="line">8765 4321   --fe dcba is copied as 321- ----   cba8 7654   0000 0fed </div></div><!-- fragment --> </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00002_source.html#l00762">762</a> of file <a class="el" href="a00002_source.html">storage.c</a>.</p>

<p class="reference">Referenced by <a class="el" href="a00002_source.html#l00868">CacheSample()</a>, and <a class="el" href="a00002_source.html#l00912">WriteToEeprom()</a>.</p>

</div>
</div>
<a id="aa0c7877e80c9706dd8af4fa40c27a401"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0c7877e80c9706dd8af4fa40c27a401">&#9670;&nbsp;</a></span>ShiftUnalignedData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void ShiftUnalignedData </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pTo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>pFrom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>bitAlignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>bitCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copies a number of bits of non-byte aligned data to a buffer, byte aligned. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pTo</td><td>The location to copy to. The first bit to copy will become the LSBit of the first byte in this buffer. </td></tr>
    <tr><td class="paramname">pFrom</td><td>The location to copy from. A number of LSBits are disregarded. </td></tr>
    <tr><td class="paramname">bitAlignment</td><td>The number of bits to disregard in <code>from</code>. Must be less than <code>8</code>. </td></tr>
    <tr><td class="paramname">bitCount</td><td>The number of bits to copy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><div class="fragment"><div class="line"><a class="code" href="a00177.html#gad5156aa8d4f9dc31fcd5ff6efc9f5e42">STORAGE_IDIVUP</a>(bitCount + bitAlignment, 8) </div></div><!-- fragment --> bytes must be available in <code>from</code>. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><div class="fragment"><div class="line"><a class="code" href="a00177.html#gad5156aa8d4f9dc31fcd5ff6efc9f5e42">STORAGE_IDIVUP</a>(bitCount, 8) </div></div><!-- fragment --> bytes will be written to <code>to</code>. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The remainder bits in <code>to</code> after <code>bitCount</code> bits is set to <code>0</code>. </dd>
<dd>
For example, use this function to move bits in this way:<ul>
<li>With <code>-</code> indicating not touched or don't care,</li>
<li><code>bitAlignment</code> equal to <code>5</code>, and</li>
<li><code>bitCount</code> equal to <code>14</code>:</li>
</ul>
<div class="fragment"><div class="line">321- ----   cba8 7654   ---- -fed is copied as 8765 4321   00fe dcba </div></div><!-- fragment --> </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00002_source.html#l00817">817</a> of file <a class="el" href="a00002_source.html">storage.c</a>.</p>

<p class="reference">Referenced by <a class="el" href="a00002_source.html#l00890">GetCachedSample()</a>, <a class="el" href="a00002_source.html#l00942">ReadFromEeprom()</a>, and <a class="el" href="a00002_source.html#l01750">Storage_Read()</a>.</p>

</div>
</div>
<a id="a271ca24d6a2841a0f84ef9ef6487afda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a271ca24d6a2841a0f84ef9ef6487afda">&#9670;&nbsp;</a></span>CacheSample()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool CacheSample </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00177.html#gacdcc483479cdfdecfdd8908db2ad80ba">STORAGE_TYPE</a> *&#160;</td>
          <td class="paramname"><em>pSample</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Stores data in <a class="el" href="a00002.html#a768b79d37c9c19f9e741f972789e1323">sCache</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pSample</td><td>May not be <code>NULL</code>. The data to cache. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> when the sample was copied; <code>false</code> when it did not fit and no changes were made. </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00002_source.html#l00868">868</a> of file <a class="el" href="a00002_source.html">storage.c</a>.</p>

<p class="reference">Referenced by <a class="el" href="a00002_source.html#l01619">Storage_Write()</a>.</p>

</div>
</div>
<a id="a8bd9b376578591090fdcdb846a6815f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bd9b376578591090fdcdb846a6815f6">&#9670;&nbsp;</a></span>GetCachedSample()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool GetCachedSample </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Retrieves a sample cached in an earlier call to <a class="el" href="a00002.html#a271ca24d6a2841a0f84ef9ef6487afda">CacheSample</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>A relative index. Determines the sample to copy. A value of 0 indicates the oldest sample that is present in <a class="el" href="a00002.html#a768b79d37c9c19f9e741f972789e1323">sCache</a>. </td></tr>
    <tr><td class="paramname">pData</td><td>May not be <code>NULL</code>. The sample is copied to the array pointed to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if a sample was copied; <code>false</code> if less than <code>n</code> samples are stored in <a class="el" href="a00002.html#a768b79d37c9c19f9e741f972789e1323">sCache</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00002_source.html#l00890">890</a> of file <a class="el" href="a00002_source.html">storage.c</a>.</p>

<p class="reference">Referenced by <a class="el" href="a00002_source.html#l01750">Storage_Read()</a>, and <a class="el" href="a00002_source.html#l01619">Storage_Write()</a>.</p>

</div>
</div>
<a id="afa6e83d0957ecaca822b5e7d4742fb56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa6e83d0957ecaca822b5e7d4742fb56">&#9670;&nbsp;</a></span>WriteToEeprom()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void WriteToEeprom </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>bitCursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>pData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>bitCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section pre"><dt>Precondition</dt><dd>EEPROM is initialized </dd>
<dd>
Enough free space must be available in EEPROM starting from <code>bitCursor</code> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bitCursor</td><td>Must be positive. The first bit where to start writing. </td></tr>
    <tr><td class="paramname">pData</td><td>May not be <code>NULL</code>. </td></tr>
    <tr><td class="paramname">bitCount</td><td>Must be strict positive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="a00002.html#a01ce7d8e7fc855bb5c49d4a50d66fc87">sInstance</a> is not touched. </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00002_source.html#l00912">912</a> of file <a class="el" href="a00002_source.html">storage.c</a>.</p>

<p class="reference">Referenced by <a class="el" href="a00002_source.html#l01160">MoveSamplesFromEepromToFlash()</a>, <a class="el" href="a00002_source.html#l01535">Storage_Reset()</a>, <a class="el" href="a00002_source.html#l01110">StoreSamplesInEeprom()</a>, and <a class="el" href="a00002_source.html#l01417">WriteMarker()</a>.</p>

</div>
</div>
<a id="a01f1423a2c76032a401695d892b8b507"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01f1423a2c76032a401695d892b8b507">&#9670;&nbsp;</a></span>ReadFromEeprom()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void ReadFromEeprom </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>bitCursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>bitCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section pre"><dt>Precondition</dt><dd>EEPROM is initialized </dd>
<dd>
Enough bits to read are available in EEPROM starting from <code>bitCursor</code> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bitCursor</td><td>Must be strict positive. The bit position in EEPROM to start reading: <code>0</code> means to start reading from the very first EEPROM bit assigned for bit storage, and so on. </td></tr>
    <tr><td class="paramname">pData</td><td>May not be <code>NULL</code>. All bits are copied in the array pointed to. </td></tr>
    <tr><td class="paramname">bitCount</td><td>Must be strict positive. When not a multiple of 8, the remainder MSBits of the last byte are set to <code>0</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="a00002.html#a01ce7d8e7fc855bb5c49d4a50d66fc87">sInstance</a> is not touched. </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00002_source.html#l00942">942</a> of file <a class="el" href="a00002_source.html">storage.c</a>.</p>

<p class="reference">Referenced by <a class="el" href="a00002_source.html#l00966">FindMarker()</a>, <a class="el" href="a00002_source.html#l01425">Storage_Init()</a>, and <a class="el" href="a00002_source.html#l01750">Storage_Read()</a>.</p>

</div>
</div>
<a id="a6a819a5d10e6edaab80a62b5832a4c59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a819a5d10e6edaab80a62b5832a4c59">&#9670;&nbsp;</a></span>FindMarker()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static unsigned int FindMarker </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00002.html#a00189">Marker_t</a> *&#160;</td>
          <td class="paramname"><em>pMarker</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Search backwards in the assigned EEPROM region, looking for a valid marker. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pMarker</td><td>: Where to copy the found marker data to. If <code>0</code> is returned, this will contain an invalid marker. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The position of the first bit of a valid stored instance of type <a class="el" href="a00002.html#a00189">Marker_t</a> in EEPROM, relative to <a class="el" href="a00177.html#ga89fe1736e393062639f3d7b64e76eeed">STORAGE_EEPROM_FIRST_ROW</a>. <code>0</code> if the marker could not be found. </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00002_source.html#l00966">966</a> of file <a class="el" href="a00002_source.html">storage.c</a>.</p>

<p class="reference">Referenced by <a class="el" href="a00002_source.html#l01425">Storage_Init()</a>.</p>

</div>
</div>
<a id="a0ff8f80115386c27583029b6f01a2cf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ff8f80115386c27583029b6f01a2cf6">&#9670;&nbsp;</a></span>GetEepromCount()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int GetEepromCount </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The number of samples stored in EEPROM. </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00002_source.html#l01027">1027</a> of file <a class="el" href="a00002_source.html">storage.c</a>.</p>

<p class="reference">Referenced by <a class="el" href="a00002_source.html#l01530">Storage_GetCount()</a>, <a class="el" href="a00002_source.html#l01681">Storage_Seek()</a>, and <a class="el" href="a00002_source.html#l01110">StoreSamplesInEeprom()</a>.</p>

</div>
</div>
<a id="a25d01d6c27a3fb8f12c7e16c10714011"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25d01d6c27a3fb8f12c7e16c10714011">&#9670;&nbsp;</a></span>GetFlashCount()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int GetFlashCount </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The number of samples stored in FLASH. </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00002_source.html#l01034">1034</a> of file <a class="el" href="a00002_source.html">storage.c</a>.</p>

<p class="reference">Referenced by <a class="el" href="a00002_source.html#l01160">MoveSamplesFromEepromToFlash()</a>, and <a class="el" href="a00002_source.html#l01530">Storage_GetCount()</a>.</p>

</div>
</div>
<a id="acc7a5597cb0b1ab519de93d8f4d2ff99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc7a5597cb0b1ab519de93d8f4d2ff99">&#9670;&nbsp;</a></span>StoreSamplesInEeprom()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int StoreSamplesInEeprom </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00177.html#gacdcc483479cdfdecfdd8908db2ad80ba">STORAGE_TYPE</a> *&#160;</td>
          <td class="paramname"><em>pSamples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Stores <code>n</code> samples in EEPROM. If necessary, the oldest data is moved to FLASH. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pSamples</td><td>May not be <code>NULL</code>. Pointer to the start of the array where to copy the samples from. </td></tr>
    <tr><td class="paramname">n</td><td>The size of the array </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of samples that were stored. A value less than <code>n</code> indicates insufficient storage capacity. </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00002_source.html#l01110">1110</a> of file <a class="el" href="a00002_source.html">storage.c</a>.</p>

<p class="reference">Referenced by <a class="el" href="a00002_source.html#l01619">Storage_Write()</a>.</p>

</div>
</div>
<a id="a9f6c705aa5b6a14f8df25c16bf1cfdf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f6c705aa5b6a14f8df25c16bf1cfdf2">&#9670;&nbsp;</a></span>MoveSamplesFromEepromToFlash()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool MoveSamplesFromEepromToFlash </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Clear the assigned EEPROM region, by moving all data to assigned FLASH region. Before moving the data, the application is given the opportunity to compress the data. The (compressed) data block is then appended to the existing data in FLASH. Steps:</p><ul>
<li>Prepare <a class="el" href="a00002.html#a95fd6ccd851ad8813a21f6ade2190084">STORAGE_WORKAREA</a> for FLASH write</li>
<li>Copy data from EEPROM to <a class="el" href="a00002.html#a95fd6ccd851ad8813a21f6ade2190084">STORAGE_WORKAREA</a></li>
<li>Call <a class="el" href="a00002.html#aaa81898e5c033740fad627b87fed62af">STORAGE_COMPRESS_CB</a></li>
<li>Flash</li>
<li>Update pointers <dl class="section return"><dt>Returns</dt><dd><code>true</code> when the compression was successful and the data has been moved to FLASH, <code>false</code> when the compression callback function returned <code>false</code> or when the FLASH storage is full: nothing has been changed in FLASH or EEPROM in that case. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="a00002.html#a01ce7d8e7fc855bb5c49d4a50d66fc87">sInstance</a> is fully updated when this function returns. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Uses <a class="el" href="a00002.html#a95fd6ccd851ad8813a21f6ade2190084">STORAGE_WORKAREA</a>. Not in use anymore when this function returns. </dd></dl>
</li>
</ul>

<p class="definition">Definition at line <a class="el" href="a00002_source.html#l01160">1160</a> of file <a class="el" href="a00002_source.html">storage.c</a>.</p>

<p class="reference">Referenced by <a class="el" href="a00002_source.html#l01110">StoreSamplesInEeprom()</a>.</p>

</div>
</div>
<a id="a0df70bc26954e5b685293b5554e3c423"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0df70bc26954e5b685293b5554e3c423">&#9670;&nbsp;</a></span>ReadAndCacheSamplesFromFlash()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int ReadAndCacheSamplesFromFlash </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>readCursor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reads a block of compressed data containing <a class="el" href="a00177.html#ga9023fc3872517d220a8f817eeef29957">STORAGE_BLOCK_SIZE_IN_SAMPLES</a> samples, decompresses the data and stores the result in the workspace given by the application. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">readCursor</td><td>The offset in bytes relative to FLASH_FIRST_BYTE_ADDRESS to the header preceding the (compressed) data block that must be read. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>When the samples are available in <a class="el" href="a00002.html#a95fd6ccd851ad8813a21f6ade2190084">STORAGE_WORKAREA</a> (either when the previous decompression was still valid and the decompression callback was not called; or when decompression was successful as indicated by the returnvalue of the called decompression callback): the size of the (compressed) data block including the header. This is equal to the number of bytes to advance the read cursor to the header of the next (compressed) data block.</li>
<li><code>0</code> when the FLASH contents were invalid, or when the decompression callback function returned <code>false:</code> nothing has been changed in that case.</li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>Only <a class="el" href="a00002.html#a36c92d4cd422f38a0ed072ba02fc1633">Storage_Instance_t.cachedBlockOffset</a> is fully updated when this function returns. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Uses <a class="el" href="a00002.html#a95fd6ccd851ad8813a21f6ade2190084">STORAGE_WORKAREA</a>. Only the first <a class="el" href="a00177.html#ga03b6b7c38aff14a94b0d919538734255">STORAGE_UNCOMPRESSED_BLOCK_SIZE_IN_BYTES</a> bytes are in use when this function returns. </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00002_source.html#l01300">1300</a> of file <a class="el" href="a00002_source.html">storage.c</a>.</p>

<p class="reference">Referenced by <a class="el" href="a00002_source.html#l01750">Storage_Read()</a>.</p>

</div>
</div>
<a id="ab35e60a815419cac466868fe8f42a25c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab35e60a815419cac466868fe8f42a25c">&#9670;&nbsp;</a></span>ValidateRecoverInfo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool ValidateRecoverInfo </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Checks whether <a class="el" href="a00002.html#a97571bbdcaba93af46f15ce205da204d">spRecoverInfo</a> contains possible correct information. </p><dl class="section return"><dt>Returns</dt><dd><code>true</code> when the information contained in the structure <a class="el" href="a00002.html#a97571bbdcaba93af46f15ce205da204d">spRecoverInfo</a> points to can be used. </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00002_source.html#l01336">1336</a> of file <a class="el" href="a00002_source.html">storage.c</a>.</p>

<p class="reference">Referenced by <a class="el" href="a00002_source.html#l01425">Storage_Init()</a>.</p>

</div>
</div>
<a id="a28de616d2e0d635a6ca4d28238ffef79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28de616d2e0d635a6ca4d28238ffef79">&#9670;&nbsp;</a></span>ValidateMarker()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool ValidateMarker </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00002.html#a00189">Marker_t</a> *&#160;</td>
          <td class="paramname"><em>pMarker</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>expectedFlashByteCursor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Checks whether the given structure contains possible correct information. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pMarker</td><td>: May not be NULL. Points to the structure to check. </td></tr>
    <tr><td class="paramname">expectedFlashByteCursor</td><td>: Ignored when negative. When zero or positive, provides an additional constraint on the marker structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> when the information contained in the structure can be used. </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00002_source.html#l01351">1351</a> of file <a class="el" href="a00002_source.html">storage.c</a>.</p>

<p class="reference">Referenced by <a class="el" href="a00002_source.html#l00966">FindMarker()</a>, and <a class="el" href="a00002_source.html#l01425">Storage_Init()</a>.</p>

</div>
</div>
<a id="a899e91c2dc6198f4c1a9c6f853a2b6e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a899e91c2dc6198f4c1a9c6f853a2b6e1">&#9670;&nbsp;</a></span>ValidateHint()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool ValidateHint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00002.html#a00185">Hint_t</a> *&#160;</td>
          <td class="paramname"><em>pHint</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Checks whether the given structure contains possible correct information. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pHint</td><td>: May not be NULL. Points to the structure to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> when the information contained in the structure can be used. </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00002_source.html#l01369">1369</a> of file <a class="el" href="a00002_source.html">storage.c</a>.</p>

<p class="reference">Referenced by <a class="el" href="a00002_source.html#l01505">Storage_DeInit()</a>, and <a class="el" href="a00002_source.html#l01425">Storage_Init()</a>.</p>

</div>
</div>
<a id="a898d33f80805fa3a63c95cc17dee54cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a898d33f80805fa3a63c95cc17dee54cc">&#9670;&nbsp;</a></span>WriteHint()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void WriteHint </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Uses the information of sInstance to create a <a class="el" href="a00002.html#a00185">Hint_t</a> structure, and writes it to EEPROM. </p>

<p class="definition">Definition at line <a class="el" href="a00002_source.html#l01397">1397</a> of file <a class="el" href="a00002_source.html">storage.c</a>.</p>

<p class="reference">Referenced by <a class="el" href="a00002_source.html#l01160">MoveSamplesFromEepromToFlash()</a>, <a class="el" href="a00002_source.html#l01505">Storage_DeInit()</a>, and <a class="el" href="a00002_source.html#l01425">Storage_Init()</a>.</p>

</div>
</div>
<a id="a479a6d8035834e3bfb58e04815271285"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a479a6d8035834e3bfb58e04815271285">&#9670;&nbsp;</a></span>WriteMarker()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void WriteMarker </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Uses the information of sInstance to create a <a class="el" href="a00002.html#a00189">Marker_t</a> structure, and writes it to EEPROM. </p>

<p class="definition">Definition at line <a class="el" href="a00002_source.html#l01417">1417</a> of file <a class="el" href="a00002_source.html">storage.c</a>.</p>

<p class="reference">Referenced by <a class="el" href="a00002_source.html#l01505">Storage_DeInit()</a>, and <a class="el" href="a00002_source.html#l01425">Storage_Init()</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="aec42f932dd26409b0fc9906a4219e16d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec42f932dd26409b0fc9906a4219e16d">&#9670;&nbsp;</a></span>_etext</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int _etext</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generated by the linker, used to calculate <a class="el" href="a00002.html#adc56bda551d9bbea8ac33ac75c98ea6a">STORAGE_FLASH_FIRST_PAGE</a> </p>

<p class="reference">Referenced by <a class="el" href="a00002_source.html#l01425">Storage_Init()</a>.</p>

</div>
</div>
<a id="a54781b6e6ecb68f160912244c1c7220f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54781b6e6ecb68f160912244c1c7220f">&#9670;&nbsp;</a></span>_data</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int _data</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generated by the linker, used to calculate <a class="el" href="a00002.html#adc56bda551d9bbea8ac33ac75c98ea6a">STORAGE_FLASH_FIRST_PAGE</a> </p>

<p class="reference">Referenced by <a class="el" href="a00002_source.html#l01425">Storage_Init()</a>.</p>

</div>
</div>
<a id="ae94c84721d175f1261b8645a67f03094"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae94c84721d175f1261b8645a67f03094">&#9670;&nbsp;</a></span>_edata</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int _edata</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generated by the linker, used to calculate <a class="el" href="a00002.html#adc56bda551d9bbea8ac33ac75c98ea6a">STORAGE_FLASH_FIRST_PAGE</a> </p>

<p class="reference">Referenced by <a class="el" href="a00002_source.html#l01425">Storage_Init()</a>.</p>

</div>
</div>
<a id="a6a400e06f2edf1ffc365a5e2e64c6d31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a400e06f2edf1ffc365a5e2e64c6d31">&#9670;&nbsp;</a></span>sStorageFlashFirstPage</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int sStorageFlashFirstPage</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="a00002_source.html#l00394">394</a> of file <a class="el" href="a00002_source.html">storage.c</a>.</p>

<p class="reference">Referenced by <a class="el" href="a00002_source.html#l01425">Storage_Init()</a>.</p>

</div>
</div>
<a id="adf4ea6fab533549be15f2da4cbfbdd30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf4ea6fab533549be15f2da4cbfbdd30">&#9670;&nbsp;</a></span>checkSizeOfSampleType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int checkSizeOfSampleType[(sizeof(<a class="el" href="a00177.html#gacdcc483479cdfdecfdd8908db2ad80ba">STORAGE_TYPE</a>) *8&lt; <a class="el" href="a00177.html#gad01e6c1296544674eb74616a97afd3fc">STORAGE_BITSIZE</a>) ? -1 :1]</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If this construct doesn't compile, <a class="el" href="a00177.html#gacdcc483479cdfdecfdd8908db2ad80ba">STORAGE_TYPE</a> can not hold <a class="el" href="a00177.html#gad01e6c1296544674eb74616a97afd3fc">STORAGE_BITSIZE</a> bits. </p>

<p class="definition">Definition at line <a class="el" href="a00002_source.html#l00611">611</a> of file <a class="el" href="a00002_source.html">storage.c</a>.</p>

</div>
</div>
<a id="a9292a35f74c15d75bfbe8b6cfda6a3a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9292a35f74c15d75bfbe8b6cfda6a3a3">&#9670;&nbsp;</a></span>checkSizeOfHint</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int checkSizeOfHint[(<a class="el" href="a00002.html#a18d649f1561f0c860e484c7fdf9df74a">SIZE_OF_HINT</a>==sizeof(<a class="el" href="a00002.html#a00185">Hint_t</a>)) ? 1 :-1]</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If this construct doesn't compile, the define <a class="el" href="a00002.html#ab6a3b701867c86fd64359d2b105548b1">SIZE_OF_MARKER</a> is no longer equal to <code>sizeof</code>(<a class="el" href="a00002.html#a00185">Hint_t</a>) </p>

<p class="definition">Definition at line <a class="el" href="a00002_source.html#l00614">614</a> of file <a class="el" href="a00002_source.html">storage.c</a>.</p>

</div>
</div>
<a id="aaf09df21ead8191834b1eee5e7a39d0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf09df21ead8191834b1eee5e7a39d0d">&#9670;&nbsp;</a></span>checkSizeOfMarker</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int checkSizeOfMarker[(<a class="el" href="a00002.html#ab6a3b701867c86fd64359d2b105548b1">SIZE_OF_MARKER</a>==sizeof(<a class="el" href="a00002.html#a00189">Marker_t</a>)) ? 1 :-1]</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If this construct doesn't compile, the define <a class="el" href="a00002.html#ab6a3b701867c86fd64359d2b105548b1">SIZE_OF_MARKER</a> is no longer equal to <code>sizeof</code>(<a class="el" href="a00002.html#a00189">Marker_t</a>) </p>

<p class="definition">Definition at line <a class="el" href="a00002_source.html#l00617">617</a> of file <a class="el" href="a00002_source.html">storage.c</a>.</p>

</div>
</div>
<a id="a734c1c9cacb668aea1416c6a99561f1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a734c1c9cacb668aea1416c6a99561f1f">&#9670;&nbsp;</a></span>checkSizeOfRecoverInfo</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int checkSizeOfRecoverInfo[sizeof(<a class="el" href="a00002.html#a00181">RecoverInfo_t</a>)==4 ? 1 :-1]</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If this construct doesn't compile, adjust <a class="el" href="a00002.html#adc9121aaa97e1eca96c84b3425032118">FIRST_BITS_OF_CACHE_SIZE</a>. <a class="el" href="a00002.html#a00181">RecoverInfo_t</a> must be exactly 32 bits in size </p>

<p class="definition">Definition at line <a class="el" href="a00002_source.html#l00620">620</a> of file <a class="el" href="a00002_source.html">storage.c</a>.</p>

</div>
</div>
<a id="a01ce7d8e7fc855bb5c49d4a50d66fc87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01ce7d8e7fc855bb5c49d4a50d66fc87">&#9670;&nbsp;</a></span>sInstance</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00002.html#a00193">Storage_Instance_t</a> sInstance</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The module's instance information, where recovered information is copied to, and where all updates are stored. In <a class="el" href="a00176.html#ga75abea0be7fefec6285224dc0f82f5ac">Storage_DeInit</a>, this information is copied to more permanent storage. </p>

<p class="definition">Definition at line <a class="el" href="a00002_source.html#l00637">637</a> of file <a class="el" href="a00002_source.html">storage.c</a>.</p>

<p class="reference">Referenced by <a class="el" href="a00002_source.html#l01027">GetEepromCount()</a>, <a class="el" href="a00002_source.html#l01034">GetFlashCount()</a>, <a class="el" href="a00002_source.html#l01160">MoveSamplesFromEepromToFlash()</a>, <a class="el" href="a00002_source.html#l01300">ReadAndCacheSamplesFromFlash()</a>, <a class="el" href="a00002_source.html#l00735">ResetInstance()</a>, <a class="el" href="a00002_source.html#l01505">Storage_DeInit()</a>, <a class="el" href="a00002_source.html#l01425">Storage_Init()</a>, <a class="el" href="a00002_source.html#l01750">Storage_Read()</a>, <a class="el" href="a00002_source.html#l01535">Storage_Reset()</a>, <a class="el" href="a00002_source.html#l01681">Storage_Seek()</a>, <a class="el" href="a00002_source.html#l01619">Storage_Write()</a>, <a class="el" href="a00002_source.html#l01110">StoreSamplesInEeprom()</a>, <a class="el" href="a00002_source.html#l01397">WriteHint()</a>, and <a class="el" href="a00002_source.html#l01417">WriteMarker()</a>.</p>

</div>
</div>
<a id="a768b79d37c9c19f9e741f972789e1323"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a768b79d37c9c19f9e741f972789e1323">&#9670;&nbsp;</a></span>sCache</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t sCache[4 *(5 - <a class="el" href="a00177.html#gaa0b4af28ee1307ce6c560e71d5a6c742">STORAGE_FIRST_ALON_REGISTER</a>)]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>To reduce the call count to <code>Chip_PMU_GetRetainedData</code> and <code>Chip_PMU_SetRetainedData</code>, data is copied to SRAM in <a class="el" href="a00176.html#gad04fe4fa8e78ef5572e4a39dec188c31">Storage_Init</a> once, and copied back to GPREG in <a class="el" href="a00176.html#ga75abea0be7fefec6285224dc0f82f5ac">Storage_DeInit</a> once. </p>

<p class="definition">Definition at line <a class="el" href="a00002_source.html#l00644">644</a> of file <a class="el" href="a00002_source.html">storage.c</a>.</p>

<p class="reference">Referenced by <a class="el" href="a00002_source.html#l00868">CacheSample()</a>, <a class="el" href="a00002_source.html#l00890">GetCachedSample()</a>, <a class="el" href="a00002_source.html#l01505">Storage_DeInit()</a>, and <a class="el" href="a00002_source.html#l01425">Storage_Init()</a>.</p>

</div>
</div>
<a id="a97571bbdcaba93af46f15ce205da204d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97571bbdcaba93af46f15ce205da204d">&#9670;&nbsp;</a></span>spRecoverInfo</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00002.html#a00181">RecoverInfo_t</a>* spRecoverInfo</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initialized in <a class="el" href="a00176.html#gad04fe4fa8e78ef5572e4a39dec188c31">Storage_Init</a> to points to the recovery structure in <a class="el" href="a00002.html#a768b79d37c9c19f9e741f972789e1323">sCache</a>. </p>

<p class="definition">Definition at line <a class="el" href="a00002_source.html#l00650">650</a> of file <a class="el" href="a00002_source.html">storage.c</a>.</p>

<p class="reference">Referenced by <a class="el" href="a00002_source.html#l00868">CacheSample()</a>, <a class="el" href="a00002_source.html#l00890">GetCachedSample()</a>, <a class="el" href="a00002_source.html#l01505">Storage_DeInit()</a>, <a class="el" href="a00002_source.html#l01530">Storage_GetCount()</a>, <a class="el" href="a00002_source.html#l01425">Storage_Init()</a>, <a class="el" href="a00002_source.html#l01535">Storage_Reset()</a>, <a class="el" href="a00002_source.html#l01619">Storage_Write()</a>, and <a class="el" href="a00002_source.html#l01336">ValidateRecoverInfo()</a>.</p>

</div>
</div>
<a id="a1c13128e91dc240e3ab47286463364ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c13128e91dc240e3ab47286463364ef">&#9670;&nbsp;</a></span>sEepromBitCursorChanged</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool sEepromBitCursorChanged = false</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set to <code>true</code> after writing a new sample in EEPROM, used in <a class="el" href="a00176.html#ga75abea0be7fefec6285224dc0f82f5ac">Storage_DeInit</a> to know when to write the marker. Not set when resetting the module; as there is no need for a marker in that case. </p>

<p class="definition">Definition at line <a class="el" href="a00002_source.html#l00658">658</a> of file <a class="el" href="a00002_source.html">storage.c</a>.</p>

<p class="reference">Referenced by <a class="el" href="a00002_source.html#l01505">Storage_DeInit()</a>, and <a class="el" href="a00002_source.html#l01110">StoreSamplesInEeprom()</a>.</p>

</div>
</div>
<a id="a2d5937977dab1cbd29de86cc5e11762d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d5937977dab1cbd29de86cc5e11762d">&#9670;&nbsp;</a></span>sStorage_Workarea</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t sStorage_Workarea[<a class="el" href="a00177.html#ga4b69ffeada7d6e645ed70b84786850f9">STORAGE_WORKAREA_SIZE</a>]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="a00002_source.html#l00662">662</a> of file <a class="el" href="a00002_source.html">storage.c</a>.</p>

</div>
</div>
<a id="a95fd6ccd851ad8813a21f6ade2190084"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95fd6ccd851ad8813a21f6ade2190084">&#9670;&nbsp;</a></span>STORAGE_WORKAREA</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t STORAGE_WORKAREA[<a class="el" href="a00177.html#ga4b69ffeada7d6e645ed70b84786850f9">STORAGE_WORKAREA_SIZE</a>]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="a00002_source.html#l01160">MoveSamplesFromEepromToFlash()</a>, <a class="el" href="a00002_source.html#l01300">ReadAndCacheSamplesFromFlash()</a>, and <a class="el" href="a00002_source.html#l01750">Storage_Read()</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_01fcd3835fb4e7d9331b722d86291b65.html">sw</a></li><li class="navelem"><a class="el" href="dir_f643af3405d44c87806a004ea9d85fcb.html">nss</a></li><li class="navelem"><a class="el" href="dir_e4201def0db509365eefa385ff809fc0.html">mods</a></li><li class="navelem"><a class="el" href="dir_5922c764dea65d8f389f9304c919579a.html">storage</a></li><li class="navelem"><a class="el" href="a00002.html">storage.c</a></li>
    <li class="footer">Generated on Tue Oct 20 2020 08:24:37 for NHS31xx storage - Maximizing storage for equisized samples by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.14 </li>
  </ul>
</div>
</body>
</html>
