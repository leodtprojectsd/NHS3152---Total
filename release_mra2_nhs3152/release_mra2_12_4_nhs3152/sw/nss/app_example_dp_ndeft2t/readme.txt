/**
 * @defgroup APP_NSS_NDEFT2T ndeft2t: NDEF message creator/parser example application
 * @ingroup APPS_NSS
 * Demo application that demonstrates the NDEF message creation and parsing using the
 * @ref MODS_NSS_NDEFT2T "NDEFT2T module".
 *
 * @par Introduction
 *  The example application demonstrates the usage of the @ref MODS_NSS_NDEFT2T "NDEFT2T module". It shows how to:
 *  - React on callbacks issued by the NDEFT2T module: #NDEFT2T_FIELD_STATUS_CB and #NDEFT2T_MSG_AVAILABLE_CB.
 *  - Create different NDEF messages containing records of type #NDEFT2T_RECORD_TYPE_URI, #NDEFT2T_RECORD_TYPE_TEXT and 
 *      #NDEFT2T_RECORD_TYPE_MIME.
 *  - Parse NDEF messages and extract the payloads of all records contained within.
 *  .
 *
 *  User interaction is possible via:
 *  - the WAKEUP button, connected to PIO0
 *  - the LED, connected to PIO7 (on the NHS3100TEMODB)
 *  - the NFC interface
 *  .
 *
 * @par Functionality
 *  - The LED is lit when an NFC field is detected and the tag is selected; it is turned off again when the NFC field
 *      disappears. 
 *  - The NFC memory is populated with a dual-record NDEF message containing a TEXT record and a MIME record.
 *  - Each time the tag is re-tapped, a slighty changed TEXT record and MIME record can be read out.
 *  - When the WAKEUP button is pressed, the NFC memory will be populated with an single-record NDEF message contaning
 *       a fixed URL. Pressing the button a second time switches back to the dual-record NDEF message.
 *  - The payloads of the TEXT and MIME records can be changed by writing an NDEF message. When the tag reader writes
 *      an NDEF message, its contents are immediately parsed. Any TEXT record's payload is copied and used therafter in
 *      subsequent messages generated by the tag; as is the case for any MIME record's payload.
 *      Resetting the IC will revert back to the orginal payload set.
 *  .
 *
 * @par Application flow
 *  The top level flow of the application is captured in the diagram below:
 *
 *  @dot
 *      digraph {
 *          graph [rank = TB];
 *          concentrate = true;
 *          splines = compound;
 *          ranksep = 0.6;
 *
 *          node [shape = circle, style = filled];
 *          start [label = " "];
 *
 *          node [shape = box, style = rounded];
 *          init [label = "Initialize app, LED, pins and NFC"];
 *
 *          subgraph a {
 *              rank = LR;
 *              rank = same;
 *
 *              node [shape = diamond, style = filled];
 *              nfcfield1 [label = "NFC FIELD\nPRESENT?"];
 *
 *              node [shape = box, style=rounded];
 *              generate [label = "Write NDEF message \n in NFC memory \n \n TEXT and MIME \n or URL"];
 *          }
 *
 *          subgraph b {
 *              rank = LR;
 *              rank = same;
 *
 *              x1 [style = invisible];
 *
 *              node [shape = diamond, style = filled];
 *              nfcfield2 [label = "NFC FIELD\nPRESENT?"];
 *
 *              node [shape = diamond, style = filled];
 *              nfcwrite [label = "NEW MSG\nWRITTEN?"];
 *
 *              node [shape = box, style=rounded];
 *              parse [label = "Read NDEF message \n in NFC memory \n \n Update TEXT and MIME payloads"];
 *          }
 *
 *          subgraph c {
 *              rank = LR ;
 *              rank = same;
 *
 *              x2 [style = invisible];
 *
 *              node [shape = diamond, style = filled];
 *              button [label = "BUTTON\nPRESSED?"];
 *
 *              node [shape = box, style=rounded];
 *              switch [label = "Switch NDEF message contents \n \n Used upon next tap by tag reader"];
 *          }
 *
 *          start -> init;
 *          init -> nfcfield1;
 *          nfcfield1 -> generate [taillabel = " yes"];
 *          generate:s -> nfcfield2;
 *          nfcfield1 -> nfcfield2 [taillabel = " \n no"];
 *          nfcfield2:se -> nfcwrite [label = " yes"];
 *          nfcwrite -> parse [taillabel = " yes"];
 *          parse -> nfcfield2:n;
 *          nfcwrite:n -> nfcfield2 [label = " no"];
 *          nfcfield2 -> button [label = " no"];
 *          button -> switch [taillabel = " yes"];
 *          switch -> sleep;
 *          button -> sleep [label = " no"];
 *          sleep -> nfcfield1 [label = " upon any NFC interrupt \n or a push of the button"];
 *
 *          generate -> x1 [style = invis];
 *          x1 -> nfcfield2 [style = invis];
 *          x1 -> x2 [style = invis];
 *          x2 -> button [style = invis];
 *      }
 *  @enddot 
 *
 * @par Tag reader
 *  - on Android:
 *      - Any NFC-enabled Android phone can be used to read out the data generated by the tag, even without any APP
 *          installed or active.
 *      - NXP's <a href="https://play.google.com/store/apps/details?id=com.nxp.taginfolite">NFC TagInfo</a> APP
 *          can be used to inspect the data in close detail.
 *      - NXP's <a href="https://play.google.com/store/apps/details?id=com.nxp.nfc.tagwriter">NFC TagWriter</a> APP
 *          can be used to write NDEF messages, changing the data generated by the tag thereafter.
 *      .
 *  - on iOS:
 *      - NXP's <a href="https://itunes.apple.com/us/app/nfc-taginfo-by-nxp/id1246143596">NFC TagInfo</a> APP
 *          can be used to read out the data generated by the tag.
 *      .
 *  - on Windows and macOS:
 *      - The <em>NTAG SmartSensor Automator</em> application, available in the SDK under <em>sw/crossplatform/comm</em>,
 *          can be used to read out the data generated by the tag, and to inspect the data in close detail. It can also
 *          be used to write NDEF messages containing MIME records, changing the data generated by the tag thereafter.
 *      .
 *  .
 */
