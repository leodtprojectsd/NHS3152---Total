<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NHS31xx SW API: event: event bookkeeping module</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="nxp-logo_small.jpg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NHS31xx SW API
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('a00471.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">event: event bookkeeping module<div class="ingroups"><a class="el" href="a00425.html">Modules</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>This block of code allows an application to store disjoint events. Events can be retrieved using a few basic filtering techniques. <br />
 Events can:</p><ul>
<li>are stored with a timestamp</li>
<li>can be retrieved in various ways</li>
<li>not be deleted</li>
<li>be changed, in a limited way (only the extra optional data section, if provided for).</li>
</ul>
<p>It will use the designated portion of the EEPROM to:</p><ul>
<li>store data of arbitrary size together with a timestamp and an unrestricted tag value.</li>
<li>allow retrieval of data sequentially, based on a time range, or a specific tag value.</li>
</ul>
<p>The event bookkeeping module main purpose is to store sparse but noteworthy events. Only EEPROM is used, and only a limited portion thereof. Events also take considerable space; once the assigned memory is full, no new events can be stored. Typically, only a handful events of each 'type' - each is then given a different tag value is expected to be stored.</p>
<p>Examples are:</p><ul>
<li>Storing configuration, start and stop times.</li>
<li>Storing error conditions such as memory full or BOD.</li>
<li>Storing read-out moments</li>
<li>Storing use case specific data, such as location-aware data given by an NFC reader a few times during the active lifetime of the IC.</li>
<li>Storing the time of the first excursions, and/or the time when the validation algorithm decided the product is no longer fit for consumption.</li>
<li>Storing any application-specific data, that is not required for the temperature logging and monitoring functionality, but is necessary to better integrate within the full solution. When reporting events, a lot of extra information is provided, allowing an application to easily fetch similar events, or neighboring events.</li>
</ul>
<p>It is expected that each application that requires this module includes it and configures the diversity settings of the module according to its specific needs.</p>
<dl class="section user"><dt>Diversity</dt><dd>This module supports diversity: settings to define the type and size of the EEPROM region placed under control of this module. Check <a class="el" href="a00472.html">Diversity Settings</a> for all diversity parameters.</dd></dl>
<dl class="section user"><dt>How to use the module</dt><dd><ol type="1">
<li>First call <a class="el" href="a00471.html#gad63e2b558b5d2bb05f98baf9bfc2b6c9">Event_Init</a> to prepare the module.</li>
<li>After that, at any time, call <a class="el" href="a00471.html#gabbc0bc36e15a85c7652b1b59d18a49a7">Event_Set</a> to append a new event.</li>
<li>To retrieve data, use one of the <a class="el" href="a00471.html#gaf615596332fc39cfa72e50a513cb65c8">Event_GetByIndex</a>, <a class="el" href="a00471.html#ga81e694932be77242fac0b4531ddeb8e8">Event_GetByTime</a>, or <a class="el" href="a00471.html#ga999bbb1611c796e2d404400432dccbae">Event_GetByTag</a>. The configured callback will be called for each event that matches the given constraints until all memory has been searched.</li>
<li>To ensure that all data is flushed in EEPROM, call <a class="el" href="a00471.html#gafa80726fa596bfea905e84979079dca4">Event_DeInit</a> as the last call between two sessions</li>
</ol>
</dd></dl>
<dl class="section user"><dt>Example</dt><dd>We define two different values to be used as 'tag': <div class="fragment"><div class="line"><span class="preprocessor">#define GOOD 0x12</span></div><div class="line"><span class="preprocessor">#define BAD 0x34</span></div></div><!-- fragment --> Two variables are used to check the outcome of the calls to the callback: <div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> sTimestamp;</div><div class="line"><span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> sCallCount;</div></div><!-- fragment --> The function <code>EventCb</code> is defined as value for <code>EVENT_CB</code> in the diversity settings: <div class="fragment"><div class="line"></div><div class="line"><span class="keywordtype">void</span> EventCb(uint8_t tag, <span class="keywordtype">int</span> offset, uint8_t len, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> index, uint32_t timestamp, uint32_t context)</div><div class="line">{</div><div class="line">    sCallCount++;</div><div class="line">    <span class="keywordflow">switch</span> (context) {</div><div class="line">        <span class="keywordflow">case</span> 0xAB: <span class="comment">/* Retrieved by index. */</span></div><div class="line">            sTimestamp = timestamp;</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line"></div><div class="line">        <span class="keywordflow">case</span> 0xCD: <span class="comment">/* Retrieved by timestamp. */</span></div><div class="line">            <a class="code" href="a00433.html#ga28301f76c53b643912da7c538f74e2c6">ASSERT</a>((index == 2) || (index == 3) || (index == 4));</div><div class="line">            <span class="comment">/* Retrieving &quot;gOoD&quot;, &quot;bAd&quot; and &quot;BAD&quot;, in that order. */</span></div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line"></div><div class="line">        <span class="keywordflow">case</span> 0xEF: <span class="comment">/* Retrieved by tag. */</span></div><div class="line">            <a class="code" href="a00433.html#ga28301f76c53b643912da7c538f74e2c6">ASSERT</a>(tag == GOOD);</div><div class="line">            <a class="code" href="a00433.html#ga28301f76c53b643912da7c538f74e2c6">ASSERT</a>(len == 4);</div><div class="line">            <a class="code" href="a00433.html#ga28301f76c53b643912da7c538f74e2c6">ASSERT</a>(offset &gt; 0);</div><div class="line">            <span class="comment">/* Retrieving &quot;good&quot;, &quot;gOoD&quot;, and &quot;GOOD&quot;, in that order. */</span></div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --> The main code is then storing and checking a total of 6 datasets at three distinct times. <div class="fragment"><div class="line">    <a class="code" href="a00471.html#gad63e2b558b5d2bb05f98baf9bfc2b6c9">Event_Init</a>(<span class="keyword">true</span>);</div><div class="line"></div><div class="line">    <a class="code" href="a00434.html#ga30f8dffbc3aff9e560b8609c6ca80c13">Chip_Clock_System_BusyWait_ms</a>(4000);</div><div class="line">    <a class="code" href="a00471.html#gabbc0bc36e15a85c7652b1b59d18a49a7">Event_Set</a>(GOOD, <span class="stringliteral">&quot;good&quot;</span>, 4);</div><div class="line">    <a class="code" href="a00471.html#gabbc0bc36e15a85c7652b1b59d18a49a7">Event_Set</a>(BAD, <span class="stringliteral">&quot;bad&quot;</span>, 3);</div><div class="line"></div><div class="line">    <a class="code" href="a00434.html#ga30f8dffbc3aff9e560b8609c6ca80c13">Chip_Clock_System_BusyWait_ms</a>(4000);</div><div class="line">    <a class="code" href="a00471.html#gabbc0bc36e15a85c7652b1b59d18a49a7">Event_Set</a>(GOOD, <span class="stringliteral">&quot;gOoD&quot;</span>, 4);</div><div class="line">    <a class="code" href="a00471.html#gabbc0bc36e15a85c7652b1b59d18a49a7">Event_Set</a>(BAD, <span class="stringliteral">&quot;bAd&quot;</span>, 3);</div><div class="line">    <a class="code" href="a00471.html#gabbc0bc36e15a85c7652b1b59d18a49a7">Event_Set</a>(BAD, NULL, 0);</div><div class="line"></div><div class="line">    <a class="code" href="a00434.html#ga30f8dffbc3aff9e560b8609c6ca80c13">Chip_Clock_System_BusyWait_ms</a>(4000);</div><div class="line">    <a class="code" href="a00471.html#gabbc0bc36e15a85c7652b1b59d18a49a7">Event_Set</a>(GOOD, <span class="stringliteral">&quot;GOOD&quot;</span>, 4);</div><div class="line"></div><div class="line">    <span class="comment">/* Retrieving one dataset by index. */</span></div><div class="line">    sCallCount = 0;</div><div class="line">    <a class="code" href="a00471.html#gaf615596332fc39cfa72e50a513cb65c8">Event_GetByIndex</a>(0, 0, 0xAB);</div><div class="line">    <a class="code" href="a00433.html#ga28301f76c53b643912da7c538f74e2c6">ASSERT</a>(sCallCount == 1);</div><div class="line"></div><div class="line">    <span class="comment">/* Retrieving a few datasets by timestamp. */</span></div><div class="line">    sCallCount = 0;</div><div class="line">    sTimestamp += 4;</div><div class="line">    <a class="code" href="a00471.html#ga81e694932be77242fac0b4531ddeb8e8">Event_GetByTime</a>(sTimestamp - 1, sTimestamp + 1, 0xCD);</div><div class="line">    <a class="code" href="a00433.html#ga28301f76c53b643912da7c538f74e2c6">ASSERT</a>(sCallCount == 3);</div><div class="line"></div><div class="line">    <span class="comment">/* Retrieving a few datasets by tag. */</span></div><div class="line">    sCallCount = 0;</div><div class="line">    <a class="code" href="a00471.html#ga999bbb1611c796e2d404400432dccbae">Event_GetByTag</a>(GOOD, 0xEF);</div><div class="line">    <a class="code" href="a00433.html#ga28301f76c53b643912da7c538f74e2c6">ASSERT</a>(sCallCount == 3);</div></div><!-- fragment --></dd></dl>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:a00472"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00472.html">Diversity Settings</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga00398cdfb65083a366cb99f3321a0142"><td class="memItemLeft" align="right" valign="top">typedef bool(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00471.html#ga00398cdfb65083a366cb99f3321a0142">pEvent_Cb_t</a>) (uint8_t tag, int offset, uint8_t len, unsigned int index, uint32_t timestamp, uint32_t context)</td></tr>
<tr class="separator:ga00398cdfb65083a366cb99f3321a0142"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gad63e2b558b5d2bb05f98baf9bfc2b6c9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00471.html#gad63e2b558b5d2bb05f98baf9bfc2b6c9">Event_Init</a> (bool reset)</td></tr>
<tr class="separator:gad63e2b558b5d2bb05f98baf9bfc2b6c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa80726fa596bfea905e84979079dca4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00471.html#gafa80726fa596bfea905e84979079dca4">Event_DeInit</a> (void)</td></tr>
<tr class="separator:gafa80726fa596bfea905e84979079dca4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga11926b17bf30e1e2e65edcef3c9bcaf1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00471.html#ga00398cdfb65083a366cb99f3321a0142">pEvent_Cb_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00471.html#ga11926b17bf30e1e2e65edcef3c9bcaf1">Event_SetCb</a> (<a class="el" href="a00471.html#ga00398cdfb65083a366cb99f3321a0142">pEvent_Cb_t</a> cb)</td></tr>
<tr class="separator:ga11926b17bf30e1e2e65edcef3c9bcaf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabbc0bc36e15a85c7652b1b59d18a49a7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00471.html#gabbc0bc36e15a85c7652b1b59d18a49a7">Event_Set</a> (uint8_t tag, void *data, uint8_t len)</td></tr>
<tr class="separator:gabbc0bc36e15a85c7652b1b59d18a49a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf615596332fc39cfa72e50a513cb65c8"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00471.html#gaf615596332fc39cfa72e50a513cb65c8">Event_GetByIndex</a> (unsigned int first, unsigned int last, uint32_t context)</td></tr>
<tr class="separator:gaf615596332fc39cfa72e50a513cb65c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga81e694932be77242fac0b4531ddeb8e8"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00471.html#ga81e694932be77242fac0b4531ddeb8e8">Event_GetByTime</a> (unsigned int begin, unsigned int end, uint32_t context)</td></tr>
<tr class="separator:ga81e694932be77242fac0b4531ddeb8e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga999bbb1611c796e2d404400432dccbae"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00471.html#ga999bbb1611c796e2d404400432dccbae">Event_GetByTag</a> (uint8_t tag, uint32_t context)</td></tr>
<tr class="separator:ga999bbb1611c796e2d404400432dccbae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4bd1bb9b6270d6fc532a1caf54aeeffc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00471.html#ga4bd1bb9b6270d6fc532a1caf54aeeffc">Event_GetFirstByTag</a> (uint8_t tag, int *pOffset, uint8_t *pLen, unsigned int *pIndex, uint32_t *pTimestamp)</td></tr>
<tr class="separator:ga4bd1bb9b6270d6fc532a1caf54aeeffc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafdbf977b529a2d4d9d29fa915716a389"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00471.html#gafdbf977b529a2d4d9d29fa915716a389">Event_GetLastByTag</a> (uint8_t tag, int *pOffset, uint8_t *pLen, unsigned int *pIndex, uint32_t *pTimestamp)</td></tr>
<tr class="separator:gafdbf977b529a2d4d9d29fa915716a389"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga00398cdfb65083a366cb99f3321a0142"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga00398cdfb65083a366cb99f3321a0142">&#9670;&nbsp;</a></span>pEvent_Cb_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef bool(* pEvent_Cb_t) (uint8_t tag, int offset, uint8_t len, unsigned int index, uint32_t timestamp, uint32_t context)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Whenever data is requested via a call to <a class="el" href="a00471.html#gaf615596332fc39cfa72e50a513cb65c8">Event_GetByIndex</a>, <a class="el" href="a00471.html#ga81e694932be77242fac0b4531ddeb8e8">Event_GetByTime</a> or <a class="el" href="a00471.html#ga999bbb1611c796e2d404400432dccbae">Event_GetByTag</a>, the function pointed to by <a class="el" href="a00472.html#ga6d9e60c6a3dbb735290e679fc3379bd4">EVENT_CB</a> is called for each matching event. The callback must have this prototype. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>The tag value associated with the data. </td></tr>
    <tr><td class="paramname">offset</td><td>Absolute EEPROM Offset, in bytes, from where to start reading the associated data. The offset is relative to <a class="el" href="a00433.html#ga19220ff77b3f420a71eddcfcb2534a52">EEPROM_START</a> and can be given unmodified as <code>offset</code> argument in a call to <a class="el" href="a00450.html#gaa1c58c0b15c9c96074499efc2c65780f">Chip_EEPROM_Read</a> If this value equals <code>-1</code>, it signifies no data was associated with the tag value. The callback still reports a valid event in that case. </td></tr>
    <tr><td class="paramname">len</td><td>The size of the associated data pointed at, in bytes. </td></tr>
    <tr><td class="paramname">index</td><td>The sequential number of the event. The very first event stored will have index <code>0</code>. There are two special values, <a class="el" href="a00472.html#ga66861fef852669d7c1abb6c8889f81f8">EVENT_CB_OPENING_INDEX</a> and <a class="el" href="a00472.html#ga8ef536b68e457ad8c9d8f3fb58d9d8de">EVENT_CB_CLOSING_INDEX</a>, whose usage can be controlled via <a class="el" href="a00472.html#ga5acad8f16a868b51c87fdbb3cdf7b701">EVENT_CB_OPENING_CALL</a> and <a class="el" href="a00472.html#ga268ca33f9a58ed9f6000a2bd92f1d171">EVENT_CB_CLOSING_CALL</a>. When used, an extra call is made, <b>not</b> indicating a valid event. Use these extra calls for preparing or concluding running activities. </td></tr>
    <tr><td class="paramname">timestamp</td><td>The RTC value at the time the data was stored. </td></tr>
    <tr><td class="paramname">context</td><td>The value as given in the call to <a class="el" href="a00471.html#gaf615596332fc39cfa72e50a513cb65c8">Event_GetByIndex</a>, <a class="el" href="a00471.html#ga81e694932be77242fac0b4531ddeb8e8">Event_GetByTime</a> or <a class="el" href="a00471.html#ga999bbb1611c796e2d404400432dccbae">Event_GetByTag</a> that triggered this callback. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Events are <b>always</b> reported ordered by time: the oldest events are always reported first. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>true</code> to indicate searching must continue;</li>
<li><code>false</code> to stop searching and end the call to <a class="el" href="a00471.html#gaf615596332fc39cfa72e50a513cb65c8">Event_GetByIndex</a>, <a class="el" href="a00471.html#ga999bbb1611c796e2d404400432dccbae">Event_GetByTag</a> or <a class="el" href="a00471.html#ga81e694932be77242fac0b4531ddeb8e8">Event_GetByTime</a> immediately. In that case, a possible closing call will also <b>not</b> be made. </li>
</ul>
</dd></dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gad63e2b558b5d2bb05f98baf9bfc2b6c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad63e2b558b5d2bb05f98baf9bfc2b6c9">&#9670;&nbsp;</a></span>Event_Init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Event_Init </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reset</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function must be the first function to call in this module after going to deep power down or power-off power save mode. Not calling this function will result at best in random data being written and read, and possibly generate hard faults. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reset</td><td><ul>
<li>If <code>true</code>, any possible existing data stored in EEPROM is disregarded and becomes irretrievable. When this function returns, <code>0</code> events are available and the entire assigned EEPROM memory is empty.</li>
<li>If <code>false</code>, any possible existing data stored in EEPROM is kept. When this function returns, all events are available and can be fetched. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>EEPROM is initialized </dd>
<dd>
RTC is initialized </dd></dl>

</div>
</div>
<a id="gafa80726fa596bfea905e84979079dca4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafa80726fa596bfea905e84979079dca4">&#9670;&nbsp;</a></span>Event_DeInit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Event_DeInit </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function must be the last function to call in this module before going to deep power down or power-off power save mode. </p><dl class="section pre"><dt>Precondition</dt><dd>EEPROM is initialized and is ready to be used. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>Possibly, an EEPROM flush was necessary, but that has finished when this function returns. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Loss of power before end of this call might result in loss of the newly added samples. </dd></dl>

</div>
</div>
<a id="ga11926b17bf30e1e2e65edcef3c9bcaf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga11926b17bf30e1e2e65edcef3c9bcaf1">&#9670;&nbsp;</a></span>Event_SetCb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00471.html#ga00398cdfb65083a366cb99f3321a0142">pEvent_Cb_t</a> Event_SetCb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00471.html#ga00398cdfb65083a366cb99f3321a0142">pEvent_Cb_t</a>&#160;</td>
          <td class="paramname"><em>cb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The callback function as set at compile time using the diversity setting <a class="el" href="a00472.html#ga6d9e60c6a3dbb735290e679fc3379bd4">EVENT_CB</a> can be overridden dynamically here. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cb</td><td>The new function that is able to receive the events requested by calling <a class="el" href="a00471.html#gaf615596332fc39cfa72e50a513cb65c8">Event_GetByIndex</a>, <a class="el" href="a00471.html#ga81e694932be77242fac0b4531ddeb8e8">Event_GetByTime</a> or <a class="el" href="a00471.html#ga999bbb1611c796e2d404400432dccbae">Event_GetByTag</a>. Providing <code>NULL</code> will reset the callback function to <a class="el" href="a00472.html#ga6d9e60c6a3dbb735290e679fc3379bd4">EVENT_CB</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The callback function that was previously set. </dd></dl>

</div>
</div>
<a id="gabbc0bc36e15a85c7652b1b59d18a49a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabbc0bc36e15a85c7652b1b59d18a49a7">&#9670;&nbsp;</a></span>Event_Set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Event_Set </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stores <code>n</code> samples in persistent storage. The RTC value is used as timestamp and stored together with the data. </p><dl class="section pre"><dt>Precondition</dt><dd>EEPROM is initialized </dd>
<dd>
RTC is initialized </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>: A value holding meaning for the application only. The value is stored as is and will be returned when the data is retrieved. Use this value to provide enough information to allow a correct interpretation of that retrieved data. </td></tr>
    <tr><td class="paramname">data</td><td>: A pointer to the associated data to store. May be <code>NULL</code>. </td></tr>
    <tr><td class="paramname">len</td><td>: The length of the associated data pointed to, in bytes. May be <code>0</code>. The maximum length is restricted by the type and the overhead: the maximum value is restricted to a maximum of <code>255</code> - <a class="el" href="a00472.html#gae1354c8abd42ab31bac5a8efd86a5993">EVENT_OVERHEAD</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>true</code> when the data is stored - possibly not yet flushed - in EEPROM.</li>
<li><code>false</code> when not enough space was available to store the data.</li>
</ul>
</dd></dl>

</div>
</div>
<a id="gaf615596332fc39cfa72e50a513cb65c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf615596332fc39cfa72e50a513cb65c8">&#9670;&nbsp;</a></span>Event_GetByIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int Event_GetByIndex </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieves events previously stored with a call to <a class="el" href="a00471.html#gabbc0bc36e15a85c7652b1b59d18a49a7">Event_Set</a>. Events are returned one at a time by calling <a class="el" href="a00472.html#ga6d9e60c6a3dbb735290e679fc3379bd4">EVENT_CB</a> repetitively, until no more events match the constraints.</p><ul>
<li>Using the diversity setting <a class="el" href="a00472.html#ga5acad8f16a868b51c87fdbb3cdf7b701">EVENT_CB_OPENING_CALL</a>, the application can control whether <a class="el" href="a00472.html#ga6d9e60c6a3dbb735290e679fc3379bd4">EVENT_CB</a> is called one extra time with empty data before the search for matching event starts.</li>
<li>Using the diversity setting <a class="el" href="a00472.html#ga268ca33f9a58ed9f6000a2bd92f1d171">EVENT_CB_CLOSING_CALL</a>, the application can control whether <a class="el" href="a00472.html#ga6d9e60c6a3dbb735290e679fc3379bd4">EVENT_CB</a> is called one last time with empty data to signify the end of the retrieval.</li>
</ul>
<p>This is a synchronous function: it only returns after all calls to that callback have finished. </p><dl class="section pre"><dt>Precondition</dt><dd>EEPROM is initialized </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>: the sequence number of the event to retrieve first. A value of <code>0</code> will retrieve the very first event stored. </td></tr>
    <tr><td class="paramname">last</td><td>: the sequence number of the event to retrieve last.<ul>
<li>If this value equals <code>first</code>, precisely one event will be returned. In this case, the callback will be called twice: the first time reporting the single matched event, the second time with empty data.</li>
<li>If this value is strictly smaller than <code>first</code>, no events will be returned. In this case, the callback will be called once with empty data. </li>
</ul>
</td></tr>
    <tr><td class="paramname">context</td><td>May be any number. Is not stored or looked at, only passed on as last argument in every call to <a class="el" href="a00472.html#ga6d9e60c6a3dbb735290e679fc3379bd4">EVENT_CB</a>. Use for your own housekeeping, as a means to provide contextual information to the callback. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of events reported, not including the possible opening and closing calls. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00471.html#ga00398cdfb65083a366cb99f3321a0142">pEvent_Cb_t</a> </dd></dl>

</div>
</div>
<a id="ga81e694932be77242fac0b4531ddeb8e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga81e694932be77242fac0b4531ddeb8e8">&#9670;&nbsp;</a></span>Event_GetByTime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int Event_GetByTime </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieves events previously stored with a call to <a class="el" href="a00471.html#gabbc0bc36e15a85c7652b1b59d18a49a7">Event_Set</a>. Events are returned one at a time by calling <a class="el" href="a00472.html#ga6d9e60c6a3dbb735290e679fc3379bd4">EVENT_CB</a> repetitively, until no more events match the constraints.</p><ul>
<li>Using the diversity setting <a class="el" href="a00472.html#ga5acad8f16a868b51c87fdbb3cdf7b701">EVENT_CB_OPENING_CALL</a>, the application can control whether <a class="el" href="a00472.html#ga6d9e60c6a3dbb735290e679fc3379bd4">EVENT_CB</a> is called one extra time with empty data before the search for matching event starts.</li>
<li>Using the diversity setting <a class="el" href="a00472.html#ga268ca33f9a58ed9f6000a2bd92f1d171">EVENT_CB_CLOSING_CALL</a>, the application can control whether <a class="el" href="a00472.html#ga6d9e60c6a3dbb735290e679fc3379bd4">EVENT_CB</a> is called one last time with empty data to signify the end of the retrieval.</li>
</ul>
<p>This is a synchronous function: it only returns after all calls to that callback have finished. </p><dl class="section pre"><dt>Precondition</dt><dd>EEPROM is initialized </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>: events are only reported when they have a timestamp equal to or later than <code>begin</code>. A value of <code>0</code> will disable this check. </td></tr>
    <tr><td class="paramname">end</td><td>: events are only reported when they have a timestamp equal to or earlier than <code>end</code>. A value of <code>0xFFFFFFFF</code> will disable this check. </td></tr>
    <tr><td class="paramname">context</td><td>May be any number. Is not stored or looked at, only passed on as last argument in every call to <a class="el" href="a00472.html#ga6d9e60c6a3dbb735290e679fc3379bd4">EVENT_CB</a>. Use for your own housekeeping, as a means to provide contextual information to the callback. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Since the RTC value is used as timestamp, it is possible that events that are stored at a later time have a timestamp that is smaller than an earlier event. This function will scan <b>all</b> events and report <b>all</b> those that have a timestamp between (and including) <code>begin</code> and <code>end</code>. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The number of events reported, not including the possible opening and closing calls. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00471.html#ga00398cdfb65083a366cb99f3321a0142">pEvent_Cb_t</a> </dd></dl>

</div>
</div>
<a id="ga999bbb1611c796e2d404400432dccbae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga999bbb1611c796e2d404400432dccbae">&#9670;&nbsp;</a></span>Event_GetByTag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int Event_GetByTag </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieves events previously stored with a call to <a class="el" href="a00471.html#gabbc0bc36e15a85c7652b1b59d18a49a7">Event_Set</a>. Events are returned one at a time by calling <a class="el" href="a00472.html#ga6d9e60c6a3dbb735290e679fc3379bd4">EVENT_CB</a> repetitively, until no more events match the constraints.</p><ul>
<li>Using the diversity setting <a class="el" href="a00472.html#ga5acad8f16a868b51c87fdbb3cdf7b701">EVENT_CB_OPENING_CALL</a>, the application can control whether <a class="el" href="a00472.html#ga6d9e60c6a3dbb735290e679fc3379bd4">EVENT_CB</a> is called one extra time with empty data before the search for matching event starts.</li>
<li>Using the diversity setting <a class="el" href="a00472.html#ga268ca33f9a58ed9f6000a2bd92f1d171">EVENT_CB_CLOSING_CALL</a>, the application can control whether <a class="el" href="a00472.html#ga6d9e60c6a3dbb735290e679fc3379bd4">EVENT_CB</a> is called one last time with empty data to signify the end of the retrieval.</li>
</ul>
<p>This is a synchronous function: it only returns after all calls to that callback have finished. </p><dl class="section pre"><dt>Precondition</dt><dd>EEPROM is initialized </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>: only events which have the same tag value are reported. </td></tr>
    <tr><td class="paramname">context</td><td>May be any number. Is not stored or looked at, only passed on as last argument in every call to <a class="el" href="a00472.html#ga6d9e60c6a3dbb735290e679fc3379bd4">EVENT_CB</a>. Use for your own housekeeping, as a means to provide contextual information to the callback. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of events reported, not including the possible opening and closing calls. </dd></dl>

</div>
</div>
<a id="ga4bd1bb9b6270d6fc532a1caf54aeeffc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4bd1bb9b6270d6fc532a1caf54aeeffc">&#9670;&nbsp;</a></span>Event_GetFirstByTag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Event_GetFirstByTag </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>pIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>pTimestamp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenience function to retrieve information about the first event that matches the given tag value. <b>No</b> callback function is called. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>: the first event which has the same tag value is reported. </td></tr>
    <tr><td class="paramname">pOffset</td><td>: May be <code>NULL</code>. Only touched when a matching event is found. See <a class="el" href="a00471.html#ga00398cdfb65083a366cb99f3321a0142">pEvent_Cb_t</a> </td></tr>
    <tr><td class="paramname">pLen</td><td>: May be <code>NULL</code>. Only touched when a matching event is found. See <a class="el" href="a00471.html#ga00398cdfb65083a366cb99f3321a0142">pEvent_Cb_t</a> </td></tr>
    <tr><td class="paramname">pIndex</td><td>: May be <code>NULL</code>. Only touched when a matching event is found. See <a class="el" href="a00471.html#ga00398cdfb65083a366cb99f3321a0142">pEvent_Cb_t</a> </td></tr>
    <tr><td class="paramname">pTimestamp</td><td>: May be <code>NULL</code>. Only touched when a matching event is found. See <a class="el" href="a00471.html#ga00398cdfb65083a366cb99f3321a0142">pEvent_Cb_t</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if a matching event was found. If <code>false</code>, the arguments have not been written to. </dd></dl>

</div>
</div>
<a id="gafdbf977b529a2d4d9d29fa915716a389"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafdbf977b529a2d4d9d29fa915716a389">&#9670;&nbsp;</a></span>Event_GetLastByTag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Event_GetLastByTag </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>pIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>pTimestamp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenience function to retrieve information about the last event that matches the given tag value. <b>No</b> callback function is called. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>: the last event which has the same tag value is reported. </td></tr>
    <tr><td class="paramname">pOffset</td><td>: May be <code>NULL</code>. Only touched when a matching event is found. See <a class="el" href="a00471.html#ga00398cdfb65083a366cb99f3321a0142">pEvent_Cb_t</a> </td></tr>
    <tr><td class="paramname">pLen</td><td>: May be <code>NULL</code>. Only touched when a matching event is found. See <a class="el" href="a00471.html#ga00398cdfb65083a366cb99f3321a0142">pEvent_Cb_t</a> </td></tr>
    <tr><td class="paramname">pIndex</td><td>: May be <code>NULL</code>. Only touched when a matching event is found. See <a class="el" href="a00471.html#ga00398cdfb65083a366cb99f3321a0142">pEvent_Cb_t</a> </td></tr>
    <tr><td class="paramname">pTimestamp</td><td>: May be <code>NULL</code>. Only touched when a matching event is found. See <a class="el" href="a00471.html#ga00398cdfb65083a366cb99f3321a0142">pEvent_Cb_t</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if a matching event was found. If <code>false</code>, the arguments have not been written to. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Tue Oct 20 2020 08:24:34 for NHS31xx SW API by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.14 </li>
  </ul>
</div>
</body>
</html>
