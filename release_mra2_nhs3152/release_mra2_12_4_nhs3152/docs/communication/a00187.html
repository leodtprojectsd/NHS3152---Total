<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NHS31xx msg - Message Handler Protocol: msg: Message Handler</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="nxp-logo_small.jpg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NHS31xx msg - Message Handler Protocol
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('a00187.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#enum-members">Enumerations</a>  </div>
  <div class="headertitle">
<div class="title">msg: Message Handler</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>The message handler is a module which provides a command - response message mechanism to help an upper layer to communicate with an external device. It is purely a software implementation without any direct dependency on hardware or transport layer. Using the message handler module, the upper layer can easily add or remove commands and responses, both at compile time and at runtime - by tweaking the diversity settings the module offers. At all times, the upper layer retains full control on what is received, what is parsed, what is generated and what is sent.</p>
<dl class="section user"><dt>Definitions</dt><dd>A few definitions make the explanations below more clear: <dl>
<dt>Command</dt>
<dd>A sequence of bytes following a <a class="el" href="a00187.html#msg_anchor_protocol">Protocol</a> that is given to the message handler module that forms an instruction to perform an action. <br />
 When looking at system level, commands are typically sent by the tag reader via the NFC interface. On a few occasions, the application may generate commands itself, based on some events or interrupts, and then feed that to the message handler module. </dd>
<dt>Response</dt>
<dd>A sequence of bytes following a <a class="el" href="a00187.html#msg_anchor_protocol">Protocol</a> that is generated to partially or fully complete the action(s) requested by a previously received command and that is to be sent out via any transport layer. <br />
 When looking at system level, responses are always generated by some handler function, called by the message handler module. When generated, the message handler module will present it to the application, who then typically wraps them in an NDEF message and copied it to the NFC shared memory. On a few occasions, the application may decide to not forward the response, or to hold off forwarding the response to a later time. </dd>
<dt>Message</dt>
<dd>A command or a response. A more generic term when the directionality of the communication path is not important. </dd>
<dt>Command generator</dt>
<dd>A part of the upper layer that somehow gets hold of a command. That command may be originating from a phone, who has copied data to the NFC shared memory, which is then in turn copied by the firmware application to eventually feed it to the message handler module. The module does not know nor care: the part of the application that feeds the commands to the message handler module is designated as the 'command generator'. </dd>
<dt>Command handler</dt>
<dd>A function, either part of the message handler module or the upper layer, that interprets the content enclosed in a specific command, takes the appropriate actions and generates the corresponding responses. The output of the command handler, the response, is given back to the message handler module who is responsible for further distribution. <br />
 The message handler module has built-in support for handling commands that are deemed not specific for an application. For example <a class="el" href="a00187.html#ggade7075e3d56378af75d2c2dd4110ddd7acf2027afe00dc0d127e562519f67fc5e">MSG_ID_GETVERSION</a>. Others can be enabled or disabled at compile time </dd>
<dt>Response handler</dt>
<dd>A part of the upper layer that receives responses via a designated callback, and that is responsible for sending out the generated responses to the originator of the corresponding command. The response handler is called by the message handler module. </dd>
<dt>Immediate response</dt>
<dd>The message handler module will ensure that for every command it receives, at least one response is generated and returned to the upper layer <a class="el" href="a00187.html#msg_anchor_one_response">(*)</a>. This first guaranteed response will become available in a synchronous way, i.e. before the call has ended, and will be made available to the upper layer in the same CPU context as where the command has been given. This means that in case a specific command handler does not create a response - one may not be available or the designated message handler may reject generating any response - the message handler module will create one on that specific command handler's behalf. This first guaranteed response is called the immediate response. Additional responses may or may not be generated immediately or later - this is command and application specific. </dd>
<dt>Response generator</dt>
<dd>Either the message module itself, or the designated command handler. The block that will generate the immediate response. <a class="anchor" id="msg_anchor_direction"></a> </dd>
<dt>Directionality</dt>
<dd>Each message requires the presence of a directionality field as part of the <a class="el" href="a00187.html#msg_anchor_protocol">Protocol</a>.</dd>
</dl>
</dd></dl>
<dl class="section user"><dt>Overview</dt><dd>The message handler module does not run in its own thread and will not react to interrupts: it has to be explicitly triggered to do something.</dd></dl>
<p>When the upper layer delivers a sequence of bytes to the message handler module, i.e. the upper layer acts as a <em>Command generator</em>, the message handler module tries to interpret this as a command. Each sequence of bytes is supposed to constitute one command.</p>
<p>The message handler module maintains a list of known commands and tries to match the incoming command with this list. If a match is found, i.e. there is a <em>Command handler</em> for this specific command, the corresponding handler is called. At that point either the handler generates at least one response, i.e. it is also the response generator, after which the message handler module considers the command handling complete; or no response is generated, after which the message handler module will generate an immediate response itself, i.e. the message handler module will take over the role of <em>Response generator</em>.</p>
<p><a class="anchor" id="msg_anchor_protocol"></a></p><dl class="section user"><dt>Protocol</dt><dd>The message handler module uses the following communication protocol for commands and responses. The first byte shall indicate the message id. The second byte shall indicate the direction of transfer as mentioned below:<ul>
<li>value of 0x0 for commands coming into message mod</li>
<li>value of 0x1 for responses going out from message mod</li>
</ul>
This is followed by the optional payload specific for each command/response. Details of the commands and responses are captured in the following sections. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The NTAG SmartSensor family uses the NFC as a bi-directional communication path. But using the NFC technology it is not possible to flag the presence of new data to the tag reader: it is up to the tag reader to decide when to read. Waiting too long slows down communication, waiting a too short time results in reading out the previous data, likely the command bytes that the tag reader itself wrote in the NFC memory. Since it is possible that the exact same bytes constitute the response from the tag, the directionality byte is added as a means to distinguish commands from responses unambiguously. This byte is added as an aid for the tag reader: the tag itself has sufficient interrupt option at his disposal to know when a new message was written by the tag.</dd></dl>
<dl class="section user"><dt>Commands</dt><dd>A command can be any sequence of bytes, that adheres to the <a class="el" href="a00187.html#msg_anchor_protocol">Protocol</a>.</dd></dl>
<dl class="section user"><dt>Handlers</dt><dd>The message handler module has a default list of commands and corresponding command handlers - which can be enabled and disabled at compile time. The upper layer can at compile time add handlers for specific commands, or it can make use of a catch-all command handler to dynamically change the way it handles commands at runtime.<br />
 Apart from some minimal rules, no predefined formats exist, leaving the application with full freedom how to implement and handle its own specific commands.</dd></dl>
<dl class="section user"><dt>Responses</dt><dd>Responses are typically generated in a command handler. Generated responses are given to the message handler module, which then attempts to have them sent by calling a designated callback. That callback can either immediately send the response over the transport layer of its choosing back to the originator of the command; or reject the response. When rejected, the message handler module will store the response in its internal buffer; a special command is available to retrieve them at a later time.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The device(s), layer(s) or block(s) that creates commands and handles responses can be considered to be the counter-part of the message handler module. The limitations imposed by the message handler module and the precise format of each command and response must be known by respected by that counter-part. Changes made to this on one side must be made as well on the other side.</dd></dl>
<p><a class="anchor" id="msg_anchor_one_response"></a></p><dl class="section note"><dt>Note</dt><dd>All commands generate one immediate response. This includes a response for the <a class="el" href="a00187.html#ggade7075e3d56378af75d2c2dd4110ddd7a3bf58e035a33e2c3267b498fd3316247">MSG_ID_RESET</a> command, but a subsequent reset will re-initialize all peripherals, including the NFC controller and it NFC shared memory. All commands may subsequently generate zero, one or multiple additional responses at a later time.</dd>
<dd>
Some commands are asynchronous in nature: in that case a response still must be immediately returned, denoting only the acceptance of the command, and subsequent responses provide the requested result.</dd></dl>
<p><br />
<br />
 </p><dl class="section user"><dt>Sequence diagrams</dt><dd>The following example sequence diagrams provide a quick insight in the different interactions.</dd></dl>
<dl>
<dt>Command - response</dt>
<dd><p class="startdd">The full communication flow between the tag reader and the tag largely follows a strict command - response sequence. Although the protocol can be used to communicate over any HW block, it is assumed that the NFC memory is used as transport layer. <br />
</p><ul>
<li><p class="startli">Each time the NHS31xx IC starts, an initial NDEF message must be generated. This is necessary to correctly identify the IC as an NDEF tag (not just an NDEF-formatable tag) and to provide the application running on the tag reader with enough information to get started: think of firmware type indication through the MIME string, version information to unlock all possible functionality, and status information to display a report to the end-user as fast as possible. </p><dl class="section note"><dt>Note</dt><dd>The generation of the initial NDEF message is a responsibility of the application: it must internally generate a command and feed that to the message handler module. The response can then be used to initialize the NFC shared memory appropriately.</dd></dl>
<div class="mscgraph">
<img src="msc_inline_mscgraph_2.png" alt="msc_inline_mscgraph_2" border="0" usemap="#msc_inline_mscgraph_2.map"/>
<map name="msc_inline_mscgraph_2.map" id="msc_inline_mscgraph_2.map"></map>
</div>
<dl class="section note"><dt>Note</dt><dd>It is the responsibility of the application to generate the initial message as soon as possible, to ensure that the desired information is present in the NFC memory at the moment that the tag reader starts reading out the NFC contents.</dd></dl>
<p><br />
 <br />
</p>
</li>
<li>From then on, the application firmware waits for an incoming command: an NDEF message, written by the tag reader, overwriting the initial message. For each command that is written, one response will be created and stored in the same NFC shared memory, for the tag reader to read out.<br />
 Also if a command is unknown, badly formatted, or not allowed (for instance, due to access restrictions), one response will be made available by the tag reader.</li>
</ul>
<div class="mscgraph">
<img src="msc_inline_mscgraph_3.png" alt="msc_inline_mscgraph_3" border="0" usemap="#msc_inline_mscgraph_3.map"/>
<map name="msc_inline_mscgraph_3.map" id="msc_inline_mscgraph_3.map"></map>
</div>
<dl class="section note"><dt>Note</dt><dd>It is not possible to notify the tag reader when a response is available in NFC memory. The tag reader must poll by continually reading the NFC memory until a memory change is detected.</dd></dl>
<p><br />
 <br />
</p><ul>
<li>Some commands take a long time to complete. Even then, one response will be made available immediately. This immediate response then only acknowledges the acceptance of the command. The requested response can then later be fetched using the command <a class="el" href="a00187.html#ggade7075e3d56378af75d2c2dd4110ddd7ac6247e0367baa5ca8abdf3711dad9f62">MSG_ID_GETRESPONSE</a>. Also when commands trigger multiple responses, the subsequent responses can be fetched be repetitively issuing the command <a class="el" href="a00187.html#ggade7075e3d56378af75d2c2dd4110ddd7ac6247e0367baa5ca8abdf3711dad9f62">MSG_ID_GETRESPONSE</a>.</li>
</ul>
<div class="mscgraph">
<img src="msc_inline_mscgraph_4.png" alt="msc_inline_mscgraph_4" border="0" usemap="#msc_inline_mscgraph_4.map"/>
<map name="msc_inline_mscgraph_4.map" id="msc_inline_mscgraph_4.map"></map>
</div>
<dl class="section note"><dt>Note</dt><dd>It requires precise knowledge of the exact command being sent, to know whether a delayed response or multiple responses will be made available, and to estimate when these responses are ready to be sent out.</dd></dl>
<p><br />
 <br />
 </p>
</dd>
<dt>Automatic responses</dt>
<dd><p class="startdd">Not all tag readers are capable of writing to a tag but can only read from one. For example, an iPhone 7 running iOS 11 will not be able to write configuration data to the tag and start a demonstration session around the temperature logging use case. A true command - response sequence is in this case not possible. <br />
 However, the full communication layer present in the SDK can still be used. The communication module is fully agnostic of the physical transport layer, the firmware application can thus feed it with self-generated commands each time the NFC HW block reports that the tag reader has read out the NFC memory. The firmware application can then follow a script, where a sequence of commands is listed that is to be followed in case the tag reader is incapable of writing and controlling the data flow itself.</p>
<p>This approach is implemented in the <em>NHS3100 temperature logger demo</em>: the firmware application can switch between an 'automatic' mode, where it generates the commands himself, and the normal 'response' mode, where it waits for commands written by the tag reader, only reacting on them.</p><ul>
<li>The Android APP - available in the Google Play Store - will take control, and will write commands to fetch the data it wants to know.</li>
<li>The iOS APP - available in the Apple APP store - will repetitively read the NFC memory until no more new data is being fed by the application firmware. Although the functionality to configure and start a temperature monitoring session is lacking, it can still do a full data readout of tens of thousands of measurements points, together with the current status and the conclusion as calculated on the NTAG SmartSensor</li>
</ul>
<p>A sequence diagram of such an application, where the application firmware implements an 'automatic' mode, can look as follows:</p>
<div class="mscgraph">
<img src="msc_inline_mscgraph_5.png" alt="msc_inline_mscgraph_5" border="0" usemap="#msc_inline_mscgraph_5.map"/>
<map name="msc_inline_mscgraph_5.map" id="msc_inline_mscgraph_5.map"></map>
</div>
<dl class="section note"><dt>Note</dt><dd>Synchronization of the read and write actions in the communication flow is not guaranteed anymore:<ul>
<li>if the tag reader reads too fast during a time consuming response generation, the tag reader may erroneously decide the script execution has finished.</li>
<li>Vice versa, when reading has finished, but a reading error has occurred causing a few bytes to have reversed bits, the application firmware cannot be informed to pause its script execution, needed to give the necessary time to the tag reader to read the response a second time.</li>
</ul>
This means that some redundancy and leniency must be implemented on both sides to still ensure a full correct readout of all the data provided by the implemented use case.</dd></dl>
<p><br />
 <br />
 </p>
</dd>
</dl>
<dl class="section user"><dt>Internal messages / custom messages</dt><dd>A number of commands and corresponding responses have been predefined by the message handler module. They can be found in the enumeration <a class="el" href="a00187.html#gade7075e3d56378af75d2c2dd4110ddd7">MSG_ID_T</a>. By default only one of them is compiled in to save code space: <a class="el" href="a00187.html#ggade7075e3d56378af75d2c2dd4110ddd7acf2027afe00dc0d127e562519f67fc5e">MSG_ID_GETVERSION</a>.</dd></dl>
<p>Each command has a corresponding command structure <code>MSG_CMD_xxxx_T</code> that describes the fields which are packed into the command payload, and one or possibly two response structures <code>MSG_RESPONSE_xxxx_T</code> that describe which fields to expect in return, as part of the response payload.</p>
<p>By default, there exist no custom messages: it is up to the application to define and implement them, and to connect them at compile time. </p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:a00252"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00187.html#a00252">MSG_CMD_READREGISTER_T</a></td></tr>
<tr class="separator:a00252"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00256"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00187.html#a00256">MSG_CMD_WRITEREGISTER_T</a></td></tr>
<tr class="separator:a00256"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00260"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00187.html#a00260">MSG_CMD_READMEMORY_T</a></td></tr>
<tr class="separator:a00260"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00264"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00187.html#a00264">MSG_CMD_WRITEMEMORY_T</a></td></tr>
<tr class="separator:a00264"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00268"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00187.html#a00268">MSG_RESPONSE_RESULTONLY_T</a></td></tr>
<tr class="separator:a00268"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00272"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00187.html#a00272">MSG_RESPONSE_GETVERSION_T</a></td></tr>
<tr class="separator:a00272"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00276"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00187.html#a00276">MSG_RESPONSE_READREGISTER_T</a></td></tr>
<tr class="separator:a00276"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00280"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00187.html#a00280">MSG_RESPONSE_READMEMORY_T</a></td></tr>
<tr class="separator:a00280"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00284"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00187.html#a00284">MSG_RESPONSE_GETUID_T</a></td></tr>
<tr class="separator:a00284"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00288"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00187.html#a00288">MSG_RESPONSE_GETNFCUID_T</a></td></tr>
<tr class="separator:a00288"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00292"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00187.html#a00292">MSG_RESPONSE_CHECKBATTERY_T</a></td></tr>
<tr class="separator:a00292"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga0248ef44b6dac231165ddc7d5307bf4b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00187.html#ga0248ef44b6dac231165ddc7d5307bf4b">MSG_API_MAJOR_VERSION</a>&#160;&#160;&#160;(0x6)</td></tr>
<tr class="separator:ga0248ef44b6dac231165ddc7d5307bf4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e54c3655143e65b486041fbb9495dd7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00187.html#ga4e54c3655143e65b486041fbb9495dd7">MSG_API_MINOR_VERSION</a>&#160;&#160;&#160;(0x1)</td></tr>
<tr class="separator:ga4e54c3655143e65b486041fbb9495dd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gade7075e3d56378af75d2c2dd4110ddd7"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00187.html#gade7075e3d56378af75d2c2dd4110ddd7">MSG_ID_T</a> { <br />
&#160;&#160;<a class="el" href="a00187.html#ggade7075e3d56378af75d2c2dd4110ddd7ac6247e0367baa5ca8abdf3711dad9f62">MSG_ID_GETRESPONSE</a> = 0x01, 
<br />
&#160;&#160;<a class="el" href="a00187.html#ggade7075e3d56378af75d2c2dd4110ddd7acf2027afe00dc0d127e562519f67fc5e">MSG_ID_GETVERSION</a> = 0x02, 
<br />
&#160;&#160;<a class="el" href="a00187.html#ggade7075e3d56378af75d2c2dd4110ddd7a3bf58e035a33e2c3267b498fd3316247">MSG_ID_RESET</a> = 0x03, 
<br />
&#160;&#160;<a class="el" href="a00187.html#ggade7075e3d56378af75d2c2dd4110ddd7a8f3dd5bfaa47e8b850625548cb188949">MSG_ID_READREGISTER</a> = 0x04, 
<br />
&#160;&#160;<a class="el" href="a00187.html#ggade7075e3d56378af75d2c2dd4110ddd7a2dce36d3a10962f8c442796565673d21">MSG_ID_WRITEREGISTER</a> = 0x05, 
<br />
&#160;&#160;<a class="el" href="a00187.html#ggade7075e3d56378af75d2c2dd4110ddd7afa343aeadb8e072e4d410ee78a413d4a">MSG_ID_READMEMORY</a> = 0x06, 
<br />
&#160;&#160;<a class="el" href="a00187.html#ggade7075e3d56378af75d2c2dd4110ddd7a4fc3462ad23093891a0e350c2df257ca">MSG_ID_WRITEMEMORY</a> = 0x07, 
<br />
&#160;&#160;<a class="el" href="a00187.html#ggade7075e3d56378af75d2c2dd4110ddd7a9bd9f498b8f9a5b955f3c7005fa36e17">MSG_ID_PREPAREDEBUG</a> = 0x08, 
<br />
&#160;&#160;<a class="el" href="a00187.html#ggade7075e3d56378af75d2c2dd4110ddd7a5d65ba46817125e29fa7e98bdd23b6e4">MSG_ID_GETUID</a> = 0x09, 
<br />
&#160;&#160;<a class="el" href="a00187.html#ggade7075e3d56378af75d2c2dd4110ddd7a980715d23a96a03e1da157040b961f76">MSG_ID_GETNFCUID</a> = 0x0a, 
<br />
&#160;&#160;<a class="el" href="a00187.html#ggade7075e3d56378af75d2c2dd4110ddd7a58a0ffc4072e37fb58411bf724354a13">MSG_ID_CHECKBATTERY</a> = 0x0b, 
<br />
&#160;&#160;<a class="el" href="a00187.html#ggade7075e3d56378af75d2c2dd4110ddd7ae3359e88c6f64e52a958ae5b299e1eea">MSG_ID_GETCALIBRATIONTIMESTAMP</a> = 0x0c, 
<br />
&#160;&#160;<a class="el" href="a00187.html#ggade7075e3d56378af75d2c2dd4110ddd7a5702e7509a5ae498d2144338489b5539">MSG_ID_GETDIAGDATA</a> = 0x3E, 
<br />
&#160;&#160;<a class="el" href="a00187.html#ggade7075e3d56378af75d2c2dd4110ddd7a9187cb780e8c0547614f8f811e5389e3">MSG_ID_LASTRESERVED</a> = 0x3F
<br />
 }</td></tr>
<tr class="separator:gade7075e3d56378af75d2c2dd4110ddd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac3a37ecb0a07b0937ff46b3f4ae8a1ee"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00187.html#gac3a37ecb0a07b0937ff46b3f4ae8a1ee">MSG_ERR_T</a> { <br />
&#160;&#160;<a class="el" href="a00187.html#ggac3a37ecb0a07b0937ff46b3f4ae8a1eea7db209a18c6374183567534787dccc1b">MSG_OK</a> = 0, 
<br />
&#160;&#160;<a class="el" href="a00187.html#ggac3a37ecb0a07b0937ff46b3f4ae8a1eea12c639ca7e6f25cee0e4e718d9295488">MSG_ERR_UNKNOWN_COMMAND</a> = 0x10007, 
<br />
&#160;&#160;<a class="el" href="a00187.html#ggac3a37ecb0a07b0937ff46b3f4ae8a1eead3e97244f77e53026b8e935c3f99faf9">MSG_ERR_NO_RESPONSE</a> = 0x1000B, 
<br />
&#160;&#160;<a class="el" href="a00187.html#ggac3a37ecb0a07b0937ff46b3f4ae8a1eea4619c227e4354854d1c46b782d3abee3">MSG_ERR_INVALID_COMMAND_SIZE</a> = 0x1000D, 
<br />
&#160;&#160;<a class="el" href="a00187.html#ggac3a37ecb0a07b0937ff46b3f4ae8a1eea049363b30fe169c7ff542e3c0fb7a80f">MSG_ERR_INVALID_PARAMETER</a> = 0x1000E, 
<br />
&#160;&#160;<a class="el" href="a00187.html#ggac3a37ecb0a07b0937ff46b3f4ae8a1eeada8577afb9741fca23e048a17a2cb581">MSG_ERR_INVALID_PRECONDITION</a> = 0x1000F, 
<br />
&#160;&#160;<a class="el" href="a00187.html#ggac3a37ecb0a07b0937ff46b3f4ae8a1eea22a4e1b9cb7c2a35f21bc39d61186f2f">MSG_ERR_INVALID_NYI</a> = 0x10010, 
<br />
&#160;&#160;<a class="el" href="a00187.html#ggac3a37ecb0a07b0937ff46b3f4ae8a1eea750c656d7ebb7a302c55b8c928520d9b">MSG_ERR_LASTRESERVED</a> = 0x1003F
<br />
 }</td></tr>
<tr class="separator:gac3a37ecb0a07b0937ff46b3f4ae8a1ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<hr/><h2 class="groupheader">Data Structure Documentation</h2>
<a name="a00252" id="a00252"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00252">&#9670;&nbsp;</a></span>MSG_CMD_READREGISTER_T</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct MSG_CMD_READREGISTER_T</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><dl class="section see"><dt>See also</dt><dd><a class="el" href="a00187.html#ggade7075e3d56378af75d2c2dd4110ddd7a8f3dd5bfaa47e8b850625548cb188949">MSG_ID_READREGISTER</a> </dd></dl>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="ac0d31ca829f934cccd89f8054e02773e"></a>uint32_t</td>
<td class="fieldname">
address</td>
<td class="fielddoc">
<p>Register address to read from. </p>
</td></tr>
</table>

</div>
</div>
<a name="a00256" id="a00256"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00256">&#9670;&nbsp;</a></span>MSG_CMD_WRITEREGISTER_T</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct MSG_CMD_WRITEREGISTER_T</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><dl class="section see"><dt>See also</dt><dd><a class="el" href="a00187.html#ggade7075e3d56378af75d2c2dd4110ddd7a2dce36d3a10962f8c442796565673d21">MSG_ID_WRITEREGISTER</a> </dd></dl>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="ac0d31ca829f934cccd89f8054e02773e"></a>uint32_t</td>
<td class="fieldname">
address</td>
<td class="fielddoc">
<p>Register address to write to. </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a1e43bf7d608e87228b625cca2c04d641"></a>uint32_t</td>
<td class="fieldname">
data</td>
<td class="fielddoc">
<p>Data to write to the ARM register. </p>
</td></tr>
</table>

</div>
</div>
<a name="a00260" id="a00260"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00260">&#9670;&nbsp;</a></span>MSG_CMD_READMEMORY_T</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct MSG_CMD_READMEMORY_T</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><dl class="section see"><dt>See also</dt><dd><a class="el" href="a00187.html#ggade7075e3d56378af75d2c2dd4110ddd7afa343aeadb8e072e4d410ee78a413d4a">MSG_ID_READMEMORY</a> </dd></dl>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="ac0d31ca829f934cccd89f8054e02773e"></a>uint32_t</td>
<td class="fieldname">
address</td>
<td class="fielddoc">
<p>Byte offset in the ARM RAM to start reading from. </p>
</td></tr>
<tr><td class="fieldtype">
<a id="ab2b3adeb2a67e656ff030b56727fd0ac"></a>uint8_t</td>
<td class="fieldname">
length</td>
<td class="fielddoc">
<p>The number of consecutive bytes to read with a maximum of 32. </p>
</td></tr>
</table>

</div>
</div>
<a name="a00264" id="a00264"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00264">&#9670;&nbsp;</a></span>MSG_CMD_WRITEMEMORY_T</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct MSG_CMD_WRITEMEMORY_T</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><dl class="section see"><dt>See also</dt><dd><a class="el" href="a00187.html#ggade7075e3d56378af75d2c2dd4110ddd7a4fc3462ad23093891a0e350c2df257ca">MSG_ID_WRITEMEMORY</a> </dd></dl>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="ac0d31ca829f934cccd89f8054e02773e"></a>uint32_t</td>
<td class="fieldname">
address</td>
<td class="fielddoc">
<p>Byte offset in the ARM RAM to start writing to. </p>
</td></tr>
<tr><td class="fieldtype">
<a id="ab2b3adeb2a67e656ff030b56727fd0ac"></a>uint8_t</td>
<td class="fieldname">
length</td>
<td class="fielddoc">
<p>The number of consecutive bytes to write with a maximum of 32. </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a6460a21fbea84550b8bf9c7ce257e4ed"></a>uint8_t</td>
<td class="fieldname">
data[32]</td>
<td class="fielddoc">
<p>A container for the data to write. </p>
</td></tr>
</table>

</div>
</div>
<a name="a00268" id="a00268"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00268">&#9670;&nbsp;</a></span>MSG_RESPONSE_RESULTONLY_T</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct MSG_RESPONSE_RESULTONLY_T</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Used whenever no other information is required to be returned except the outcome of a command. </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a36692bbc61358ebc0e37a6fc6a395d28"></a>uint32_t</td>
<td class="fieldname">
result</td>
<td class="fielddoc">
<p>The command result. </p><dl class="section note"><dt>Note</dt><dd>If this structure is used to return an immediate result, the interpretation of the result value is different, depending on the type of command: synchronous or asynchronous:<ul>
<li>For synchronous commands, the result indicates the result of executing the command. The command has been fully executed. <a class="el" href="a00187.html#ggac3a37ecb0a07b0937ff46b3f4ae8a1eea7db209a18c6374183567534787dccc1b">MSG_OK</a> means that the command was successfully executed, any other value indicates an error code and signifies that the command has been partially executed or not at all.</li>
<li>For asynchronous commands the result only indicates the result of receiving the command and checking its pre-conditions. <a class="el" href="a00187.html#ggac3a37ecb0a07b0937ff46b3f4ae8a1eea7db209a18c6374183567534787dccc1b">MSG_OK</a> means that the commands was successfully received and execution of the command has started, any other value indicates an error code and signifies that the command will be partially executed or not at all. The final result of the execution of the command will be part of the response that will be queued later.</li>
</ul>
</dd>
<dd>
If this structure is used to respond to the command <a class="el" href="a00187.html#ggade7075e3d56378af75d2c2dd4110ddd7ac6247e0367baa5ca8abdf3711dad9f62">MSG_ID_GETRESPONSE</a>, it signifies the final result of the execution of an asynchronous command. </dd></dl>
</td></tr>
</table>

</div>
</div>
<a name="a00272" id="a00272"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00272">&#9670;&nbsp;</a></span>MSG_RESPONSE_GETVERSION_T</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct MSG_RESPONSE_GETVERSION_T</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><dl class="section see"><dt>See also</dt><dd><a class="el" href="a00187.html#ggade7075e3d56378af75d2c2dd4110ddd7acf2027afe00dc0d127e562519f67fc5e">MSG_ID_GETVERSION</a> </dd></dl>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a0fc429b055e74830a4583ec37f5c3846"></a>uint16_t</td>
<td class="fieldname">
reserved2</td>
<td class="fielddoc">
<p>Reserved for future use. Must be 0. Does not bear any significance. </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a1091c1725794f79dff1772e544cf4d10"></a>uint16_t</td>
<td class="fieldname">
swMajorVersion</td>
<td class="fielddoc">
<p>The software major version </p>
</td></tr>
<tr><td class="fieldtype">
<a id="ae81df9b4aba1c86ab8dbef8177a25409"></a>uint16_t</td>
<td class="fieldname">
swMinorVersion</td>
<td class="fielddoc">
<p>The software minor version </p>
</td></tr>
<tr><td class="fieldtype">
<a id="aa05ecf2cd4bc24cfd163a5d06adc5b30"></a>uint16_t</td>
<td class="fieldname">
apiMajorVersion</td>
<td class="fielddoc">
<p>Equal to <a class="el" href="a00187.html#ga0248ef44b6dac231165ddc7d5307bf4b">MSG_API_MAJOR_VERSION</a> </p>
</td></tr>
<tr><td class="fieldtype">
<a id="ac38d834dbff84b55b6d7348f7a06f5ff"></a>uint16_t</td>
<td class="fieldname">
apiMinorVersion</td>
<td class="fielddoc">
<p>Equal to <a class="el" href="a00187.html#ga4e54c3655143e65b486041fbb9495dd7">MSG_API_MINOR_VERSION</a> </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a21079ffa80688b89c7dd4ba646a55283"></a>uint32_t</td>
<td class="fieldname">
deviceId</td>
<td class="fielddoc">
<p>This value will be equal to:</p><ul>
<li><code>0x4E310020</code> for NHS3100 devices</li>
<li><code>0x4E315220</code> for NHS3152 devices</li>
</ul>
</td></tr>
</table>

</div>
</div>
<a name="a00276" id="a00276"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00276">&#9670;&nbsp;</a></span>MSG_RESPONSE_READREGISTER_T</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct MSG_RESPONSE_READREGISTER_T</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><dl class="section see"><dt>See also</dt><dd><a class="el" href="a00187.html#ggade7075e3d56378af75d2c2dd4110ddd7a8f3dd5bfaa47e8b850625548cb188949">MSG_ID_READREGISTER</a> </dd></dl>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a36692bbc61358ebc0e37a6fc6a395d28"></a>uint32_t</td>
<td class="fieldname">
result</td>
<td class="fielddoc">
<p>The command result. Only when <code>result</code> equals <a class="el" href="a00187.html#ggac3a37ecb0a07b0937ff46b3f4ae8a1eea7db209a18c6374183567534787dccc1b">MSG_OK</a>, the contents of <code>data</code> is valid. </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a1e43bf7d608e87228b625cca2c04d641"></a>uint32_t</td>
<td class="fieldname">
data</td>
<td class="fielddoc">
<p>The value read from the ARM Register </p>
</td></tr>
</table>

</div>
</div>
<a name="a00280" id="a00280"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00280">&#9670;&nbsp;</a></span>MSG_RESPONSE_READMEMORY_T</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct MSG_RESPONSE_READMEMORY_T</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><dl class="section see"><dt>See also</dt><dd><a class="el" href="a00187.html#ggade7075e3d56378af75d2c2dd4110ddd7afa343aeadb8e072e4d410ee78a413d4a">MSG_ID_READMEMORY</a> </dd></dl>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a36692bbc61358ebc0e37a6fc6a395d28"></a>uint32_t</td>
<td class="fieldname">
result</td>
<td class="fielddoc">
<p>The command result. Only when <code>result</code> equals <a class="el" href="a00187.html#ggac3a37ecb0a07b0937ff46b3f4ae8a1eea7db209a18c6374183567534787dccc1b">MSG_OK</a>, the contents of <code>data</code> is valid. </p>
</td></tr>
<tr><td class="fieldtype">
<a id="ab2b3adeb2a67e656ff030b56727fd0ac"></a>uint8_t</td>
<td class="fieldname">
length</td>
<td class="fielddoc">
<p>The number of consecutive bytes read. </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a6460a21fbea84550b8bf9c7ce257e4ed"></a>uint8_t</td>
<td class="fieldname">
data[32]</td>
<td class="fielddoc">
<p>The values read from the ARM memory. The extraneous array elements - where the index is greater than <code>length</code> - are set to 0. </p>
</td></tr>
</table>

</div>
</div>
<a name="a00284" id="a00284"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00284">&#9670;&nbsp;</a></span>MSG_RESPONSE_GETUID_T</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct MSG_RESPONSE_GETUID_T</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><dl class="section see"><dt>See also</dt><dd><a class="el" href="a00187.html#ggade7075e3d56378af75d2c2dd4110ddd7a5d65ba46817125e29fa7e98bdd23b6e4">MSG_ID_GETUID</a> </dd></dl>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a85767879ec473da0d1013ee35b8e7e61"></a>uint32_t</td>
<td class="fieldname">
uid[4]</td>
<td class="fielddoc">
<p>The sequence of 4 32-bit words (LSByte first) is guaranteed unique among all NHS31xx ICs. </p>
</td></tr>
</table>

</div>
</div>
<a name="a00288" id="a00288"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00288">&#9670;&nbsp;</a></span>MSG_RESPONSE_GETNFCUID_T</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct MSG_RESPONSE_GETNFCUID_T</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><dl class="section see"><dt>See also</dt><dd><a class="el" href="a00187.html#ggade7075e3d56378af75d2c2dd4110ddd7a980715d23a96a03e1da157040b961f76">MSG_ID_GETNFCUID</a> </dd></dl>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="aa9aacba25c4393f3e85c22e520de03f6"></a>uint8_t</td>
<td class="fieldname">
nfcuid[8]</td>
<td class="fielddoc">
<p>The sequence of bytes as assigned to the NFC controller. </p>
</td></tr>
</table>

</div>
</div>
<a name="a00292" id="a00292"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00292">&#9670;&nbsp;</a></span>MSG_RESPONSE_CHECKBATTERY_T</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct MSG_RESPONSE_CHECKBATTERY_T</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><dl class="section see"><dt>See also</dt><dd><a class="el" href="a00187.html#ggade7075e3d56378af75d2c2dd4110ddd7a58a0ffc4072e37fb58411bf724354a13">MSG_ID_CHECKBATTERY</a> </dd></dl>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a36692bbc61358ebc0e37a6fc6a395d28"></a>uint32_t</td>
<td class="fieldname">
result</td>
<td class="fielddoc">
<p>The command result. Only when <code>result</code> equals <a class="el" href="a00187.html#ggac3a37ecb0a07b0937ff46b3f4ae8a1eea7db209a18c6374183567534787dccc1b">MSG_OK</a>, the contents of <code>data</code> is valid. </p>
</td></tr>
<tr><td class="fieldtype">
<a id="ac6bb16831f8103061e123864d8a65b9b"></a>int32_t</td>
<td class="fieldname">
threshold</td>
<td class="fielddoc">
<p>Extra current consumption is enabled in progressive steps. The extra current consumption which triggered the BOD is returned here. A negative value indicates BOD could not be triggered. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga0248ef44b6dac231165ddc7d5307bf4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0248ef44b6dac231165ddc7d5307bf4b">&#9670;&nbsp;</a></span>MSG_API_MAJOR_VERSION</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MSG_API_MAJOR_VERSION&#160;&#160;&#160;(0x6)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Defines the major API version. This should be incremented each time the API changes. </p>

</div>
</div>
<a id="ga4e54c3655143e65b486041fbb9495dd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4e54c3655143e65b486041fbb9495dd7">&#9670;&nbsp;</a></span>MSG_API_MINOR_VERSION</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MSG_API_MINOR_VERSION&#160;&#160;&#160;(0x1)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Defines the minor API version. This should be reset each time the API changes, and incremented each time the API doesn't change but the implementation or documentation changes. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="gade7075e3d56378af75d2c2dd4110ddd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gade7075e3d56378af75d2c2dd4110ddd7">&#9670;&nbsp;</a></span>MSG_ID_T</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="a00187.html#gade7075e3d56378af75d2c2dd4110ddd7">MSG_ID_T</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Supported messages. </p><dl class="section note"><dt>Note</dt><dd>Each message comprises of a command and a response. For each command and response a corresponding struct exists which explains the parameters, their sizes and their use. </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggade7075e3d56378af75d2c2dd4110ddd7ac6247e0367baa5ca8abdf3711dad9f62"></a>MSG_ID_GETRESPONSE&#160;</td><td class="fielddoc"><p><code>0x01</code> <br />
The message handler module holds a queue of responses. Each time a response is created which cannot be sent back immediately (in response to a command), it is queued. It's the task of the host to use this command to retrieve the queued responses. </p><dl class="section note"><dt>Note</dt><dd>When the host doesn't retrieve the responses fast enough, the buffer gets filled up. When a new response can not be stored any more, the oldest responses are discarded until sufficient room is available to store the newest response. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Header</td><td>: Sequence of bytes as per the <a class="el" href="a00187.html#msg_anchor_protocol">Protocol</a>. </td></tr>
    <tr><td class="paramname">Payload</td><td>: <b>No</b> payload. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The response is returned immediately.<ul>
<li>If a response was queued and available for retrieval: the type of the response is determined by the first byte and is equal to the message id which triggered the generation of this response.</li>
<li>If no response was queued: <a class="el" href="a00187.html#a00268">MSG_RESPONSE_RESULTONLY_T</a> with <a class="el" href="a00187.html#a36692bbc61358ebc0e37a6fc6a395d28">MSG_RESPONSE_RESULTONLY_T.result</a> equal to <a class="el" href="a00187.html#ggac3a37ecb0a07b0937ff46b3f4ae8a1eead3e97244f77e53026b8e935c3f99faf9">MSG_ERR_NO_RESPONSE</a></li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>synchronous command </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="ggade7075e3d56378af75d2c2dd4110ddd7acf2027afe00dc0d127e562519f67fc5e"></a>MSG_ID_GETVERSION&#160;</td><td class="fielddoc"><p><code>0x02</code> <br />
This message id allows the host to determine the version of the firmware. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Header</td><td>: Sequence of bytes as per the <a class="el" href="a00187.html#msg_anchor_protocol">Protocol</a>. </td></tr>
    <tr><td class="paramname">Payload</td><td>: <b>No</b> payload. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="a00187.html#a00272">MSG_RESPONSE_GETVERSION_T</a> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>synchronous command </dd>
<dd>
This command is always available. </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="ggade7075e3d56378af75d2c2dd4110ddd7a3bf58e035a33e2c3267b498fd3316247"></a>MSG_ID_RESET&#160;</td><td class="fielddoc"><p><code>0x03</code> <br />
Generate a SW reset of the digital part of the system. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Header</td><td>: Sequence of bytes as per the <a class="el" href="a00187.html#msg_anchor_protocol">Protocol</a>. </td></tr>
    <tr><td class="paramname">Payload</td><td>: <b>No</b> payload. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="a00187.html#a00268">MSG_RESPONSE_RESULTONLY_T</a>. This response will be available for 500 milliseconds. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>synchronous command </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="ggade7075e3d56378af75d2c2dd4110ddd7a8f3dd5bfaa47e8b850625548cb188949"></a>MSG_ID_READREGISTER&#160;</td><td class="fielddoc"><p><code>0x04</code> <br />
Read and return the value from the selected ARM register address. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Header</td><td>: Sequence of bytes as per the <a class="el" href="a00187.html#msg_anchor_protocol">Protocol</a>. </td></tr>
    <tr><td class="paramname">Payload</td><td>: <a class="el" href="a00187.html#a00252">MSG_CMD_READREGISTER_T</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="a00187.html#a00276">MSG_RESPONSE_READREGISTER_T</a> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>synchronous command </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="ggade7075e3d56378af75d2c2dd4110ddd7a2dce36d3a10962f8c442796565673d21"></a>MSG_ID_WRITEREGISTER&#160;</td><td class="fielddoc"><p><code>0x05</code> <br />
Write the data supplied by the host to the selected ARM register address. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Header</td><td>: Sequence of bytes as per the <a class="el" href="a00187.html#msg_anchor_protocol">Protocol</a>. </td></tr>
    <tr><td class="paramname">Payload</td><td>: <a class="el" href="a00187.html#a00256">MSG_CMD_WRITEREGISTER_T</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="a00187.html#a00268">MSG_RESPONSE_RESULTONLY_T</a>. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>synchronous command </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="ggade7075e3d56378af75d2c2dd4110ddd7afa343aeadb8e072e4d410ee78a413d4a"></a>MSG_ID_READMEMORY&#160;</td><td class="fielddoc"><p><code>0x06</code> <br />
Read and return the value from the selected address. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Header</td><td>: Sequence of bytes as per the <a class="el" href="a00187.html#msg_anchor_protocol">Protocol</a>. </td></tr>
    <tr><td class="paramname">Payload</td><td>: <a class="el" href="a00187.html#a00260">MSG_CMD_READMEMORY_T</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="a00187.html#a00280">MSG_RESPONSE_READMEMORY_T</a>. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>synchronous command </dd>
<dd>
The address range may be part of SRAM, Flash or EEPROM. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>It is assumed the address region is accessible and can be read. This is <b>not</b> checked for. e.g. This implies it is the application's responsibility to ensure the EEPROM is initialized when reading EEPROM data, and that it is the caller's responsibility to ensure the range can be mapped to valid addresses. </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="ggade7075e3d56378af75d2c2dd4110ddd7a4fc3462ad23093891a0e350c2df257ca"></a>MSG_ID_WRITEMEMORY&#160;</td><td class="fielddoc"><p><code>0x07</code> <br />
Write the data supplied by the host to the selected ARM memory address. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Header</td><td>: Sequence of bytes as per the <a class="el" href="a00187.html#msg_anchor_protocol">Protocol</a>. </td></tr>
    <tr><td class="paramname">Payload</td><td>: <a class="el" href="a00187.html#a00264">MSG_CMD_WRITEMEMORY_T</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="a00187.html#a00268">MSG_RESPONSE_RESULTONLY_T</a>. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>synchronous command </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Only SRAM can be written to. It is assumed the address region which is referred to is fully part of SRAM. This is <b>not</b> checked for. </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="ggade7075e3d56378af75d2c2dd4110ddd7a9bd9f498b8f9a5b955f3c7005fa36e17"></a>MSG_ID_PREPAREDEBUG&#160;</td><td class="fielddoc"><p><code>0x08</code> <br />
Configures and enables the SWD lines, then waits in an endless while loop. This allows a developer to attach a debugger to the running device. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Header</td><td>: Sequence of bytes as per the <a class="el" href="a00187.html#msg_anchor_protocol">Protocol</a>. </td></tr>
    <tr><td class="paramname">Payload</td><td>: <b>No</b> payload. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="a00187.html#a00268">MSG_RESPONSE_RESULTONLY_T</a>. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>synchronous command </dd>
<dd>
When a debugging session has been established, set the boolean <code>gMsgWaitForDebugConnection</code> to <code>false</code> to return from the command handler. </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="ggade7075e3d56378af75d2c2dd4110ddd7a5d65ba46817125e29fa7e98bdd23b6e4"></a>MSG_ID_GETUID&#160;</td><td class="fielddoc"><p><code>0x09</code> <br />
Retrieve the unique identifier of the IC. This is the device serial number guaranteed unique among all NHS31xx ICs. </p><dl class="section note"><dt>Note</dt><dd>This is <b>not</b> equal to the NFC ID, which is a randomly assigned number. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Header</td><td>: Sequence of bytes as per the <a class="el" href="a00187.html#msg_anchor_protocol">Protocol</a>. </td></tr>
    <tr><td class="paramname">Payload</td><td>: <b>No</b> payload. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="a00187.html#a00284">MSG_RESPONSE_GETUID_T</a> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>synchronous command </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="ggade7075e3d56378af75d2c2dd4110ddd7a980715d23a96a03e1da157040b961f76"></a>MSG_ID_GETNFCUID&#160;</td><td class="fielddoc"><p><code>0x0a</code> <br />
Retrieve the NFC identifier of the IC. This is the serial number assigned to the NFC controller and stored in the first two pages of the NFC shared memory. </p><dl class="section note"><dt>Note</dt><dd>This is a random number assigned during production of the IC. It is <b>not</b> guaranteed unique among all NHS31xx ICs. </dd>
<dd>
This is <b>not</b> equal to the device UID. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Header</td><td>: Sequence of bytes as per the <a class="el" href="a00187.html#msg_anchor_protocol">Protocol</a>. </td></tr>
    <tr><td class="paramname">Payload</td><td>: <b>No</b> payload. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="a00187.html#a00284">MSG_RESPONSE_GETUID_T</a> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>synchronous command </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="ggade7075e3d56378af75d2c2dd4110ddd7a58a0ffc4072e37fb58411bf724354a13"></a>MSG_ID_CHECKBATTERY&#160;</td><td class="fielddoc"><p><code>0x0b</code> <br />
Generates whether the BOD is triggered under extra load. Use this to check battery impedance. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Header</td><td>: Sequence of bytes as per the <a class="el" href="a00187.html#msg_anchor_protocol">Protocol</a>. </td></tr>
    <tr><td class="paramname">Payload</td><td>: <b>No</b> payload. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="a00187.html#a00268">MSG_RESPONSE_RESULTONLY_T</a> immediately; <br />
 If <code>result</code> was equal to <a class="el" href="a00187.html#ggac3a37ecb0a07b0937ff46b3f4ae8a1eea7db209a18c6374183567534787dccc1b">MSG_OK</a>, <a class="el" href="a00187.html#a00292">MSG_RESPONSE_CHECKBATTERY_T</a> thereafter. This may take several 100 ms. This second response must be fetched by issuing a command with <a class="el" href="a00187.html#ggade7075e3d56378af75d2c2dd4110ddd7ac6247e0367baa5ca8abdf3711dad9f62">MSG_ID_GETRESPONSE</a> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>asynchronous command </dd>
<dd>
For this command to become available, define <code>MSG_ENABLE_CHECKBATTERY</code> </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This check has a (small) negative impact on the battery. And, this check potentially can cause a reset. An application may be prudent by blocking this message while a reset is not desired, e.g. during a monitoring session in a logger application. This can be done by implementing <code>MSG_COMMAND_ACCEPT_CB</code> </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="ggade7075e3d56378af75d2c2dd4110ddd7ae3359e88c6f64e52a958ae5b299e1eea"></a>MSG_ID_GETCALIBRATIONTIMESTAMP&#160;</td><td class="fielddoc"><p><code>0x0b</code> <br />
Retrieves the timestamps of when the temperature calibration took place (at 30C and 85C). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Header</td><td>: Sequence of bytes as per the <a class="el" href="a00187.html#msg_anchor_protocol">Protocol</a>. </td></tr>
    <tr><td class="paramname">Payload</td><td>: <b>No</b> payload. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>MSG_RESPONSE_GETDIAGDATA_T </dd></dl>
<dl class="section note"><dt>Note</dt><dd>synchronous command </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="ggade7075e3d56378af75d2c2dd4110ddd7a5702e7509a5ae498d2144338489b5539"></a>MSG_ID_GETDIAGDATA&#160;</td><td class="fielddoc"><p><code>0x3E</code> <br />
Retrieve diagnostics information as gathered by the diag module. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Header</td><td>: Sequence of bytes as per the <a class="el" href="a00187.html#msg_anchor_protocol">Protocol</a>. </td></tr>
    <tr><td class="paramname">Payload</td><td>: <b>No</b> payload. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>MSG_RESPONSE_GETDIAGDATA_T </dd></dl>
<dl class="section note"><dt>Note</dt><dd>synchronous command </dd>
<dd>
For this command to become available, define <code>ENABLE_DIAG_MODULE</code>. </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="ggade7075e3d56378af75d2c2dd4110ddd7a9187cb780e8c0547614f8f811e5389e3"></a>MSG_ID_LASTRESERVED&#160;</td><td class="fielddoc"><p><code>0x3F</code> <br />
This message id does not encompass a command or a response. It is used to signify the highest id that is reserved for use by the message handler itself. All application specific commands - which are to be handled by setting a specific handler - must use id's greater than this value. </p><dl class="section note"><dt>Note</dt><dd>Only to be used as an offset for your own application specific commands and responses. </dd></dl>
<dl class="section see"><dt>See also</dt><dd>Cmd_SetApplicationHandler </dd></dl>
</td></tr>
</table>

</div>
</div>
<a id="gac3a37ecb0a07b0937ff46b3f4ae8a1ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac3a37ecb0a07b0937ff46b3f4ae8a1ee">&#9670;&nbsp;</a></span>MSG_ERR_T</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="a00187.html#gac3a37ecb0a07b0937ff46b3f4ae8a1ee">MSG_ERR_T</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Lists all possible error codes that may be returned. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggac3a37ecb0a07b0937ff46b3f4ae8a1eea7db209a18c6374183567534787dccc1b"></a>MSG_OK&#160;</td><td class="fielddoc"><p><code>0x00000000</code> <br />
 No error was found. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac3a37ecb0a07b0937ff46b3f4ae8a1eea12c639ca7e6f25cee0e4e718d9295488"></a>MSG_ERR_UNKNOWN_COMMAND&#160;</td><td class="fielddoc"><p><code>0x00010007</code> or <code> [07h 00h 01h 00h] </code> <br />
 No suitable command handler could be found for this id </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac3a37ecb0a07b0937ff46b3f4ae8a1eead3e97244f77e53026b8e935c3f99faf9"></a>MSG_ERR_NO_RESPONSE&#160;</td><td class="fielddoc"><p><code>0x0001000B</code> or <code> [0Bh 00h 01h 00h] </code> <br />
 Only used in the response to a command with id <a class="el" href="a00187.html#ggade7075e3d56378af75d2c2dd4110ddd7ac6247e0367baa5ca8abdf3711dad9f62">MSG_ID_GETRESPONSE</a>, to indicate no stored responses are available in the buffer. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac3a37ecb0a07b0937ff46b3f4ae8a1eea4619c227e4354854d1c46b782d3abee3"></a>MSG_ERR_INVALID_COMMAND_SIZE&#160;</td><td class="fielddoc"><p><code>0x0001000D</code> or <code> [0Dh 00h 01h 00h] </code> <br />
 A number of parameters are lacking or were given in excess. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac3a37ecb0a07b0937ff46b3f4ae8a1eea049363b30fe169c7ff542e3c0fb7a80f"></a>MSG_ERR_INVALID_PARAMETER&#160;</td><td class="fielddoc"><p><code>0x0001000E</code> or <code> [0Eh 00h 01h 00h] </code> <br />
 At least one parameter was missing or had an invalid value. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac3a37ecb0a07b0937ff46b3f4ae8a1eeada8577afb9741fca23e048a17a2cb581"></a>MSG_ERR_INVALID_PRECONDITION&#160;</td><td class="fielddoc"><p><code>0x0001000F</code> or <code> [0Fh 00h 01h 00h] </code> <br />
 The command can now not be handled. Check the documentation for a correct command sequence. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac3a37ecb0a07b0937ff46b3f4ae8a1eea22a4e1b9cb7c2a35f21bc39d61186f2f"></a>MSG_ERR_INVALID_NYI&#160;</td><td class="fielddoc"><p><code>0x00010010</code> or <code> [10h 00h 01h 00h] </code> <br />
 The handler of the command is a stub and still needs to be implemented; or the implementation to handle the given combination of parameters is incomplete and a work in progress. Check with the developer to retrieve updated firmware. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac3a37ecb0a07b0937ff46b3f4ae8a1eea750c656d7ebb7a302c55b8c928520d9b"></a>MSG_ERR_LASTRESERVED&#160;</td><td class="fielddoc"><p><code>0x0001003F</code> <br />
This error code does not encompass an error. It is used to signify the highest id that is reserved for use by the message handler itself. All application specific error codes must use id's greater than this value. </p><dl class="section note"><dt>Note</dt><dd>Only to be used as an offset for your own application specific error codes. </dd></dl>
</td></tr>
</table>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Tue Oct 20 2020 08:24:36 for NHS31xx msg - Message Handler Protocol by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.14 </li>
  </ul>
</div>
</body>
</html>
