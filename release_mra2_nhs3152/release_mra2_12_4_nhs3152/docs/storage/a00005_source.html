<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NHS31xx storage - Maximizing storage for equisized samples: storage.h Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="nxp-logo_small.jpg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NHS31xx storage - Maximizing storage for equisized samples
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('a00005_source.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">storage.h</div>  </div>
</div><!--header-->
<div class="contents">
<a href="a00005.html">Go to the documentation of this file.</a><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;<span class="comment">/*</span></div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;<span class="comment"> * Copyright 2016-2020 NXP</span></div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;<span class="comment"> * This software is owned or controlled by NXP and may only be used strictly</span></div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;<span class="comment"> * in accordance with the applicable license terms.  By expressly accepting</span></div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;<span class="comment"> * such terms or by downloading, installing, activating and/or otherwise using</span></div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;<span class="comment"> * the software, you are agreeing that you have read, and that you agree to</span></div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;<span class="comment"> * comply with and are bound by, such license terms.  If you do not agree to</span></div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;<span class="comment"> * be bound by the applicable license terms, then you may not retain, install,</span></div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;<span class="comment"> * activate or otherwise use the software.</span></div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;<span class="comment"> */</span></div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;<span class="preprocessor">#ifndef __STORAGE_H_</span></div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;<span class="preprocessor">#define __STORAGE_H_</span></div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;<span class="comment">/**</span></div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;<span class="comment"> * @defgroup MODS_NSS_STORAGE storage: NVM Storage module</span></div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;<span class="comment"> * @ingroup MODS_NSS</span></div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;<span class="comment"> * The storage module allows an application to store samples &lt;strong&gt; all of identical size&lt;/strong&gt; in non-volatile</span></div><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;<span class="comment"> * memories EEPROM and FLASH.</span></div><div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;<span class="comment"> * It will:</span></div><div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;<span class="comment"> * - abstract away where and how the samples are stored</span></div><div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;<span class="comment"> * - provide an easy interface via which samples can be written to and read from</span></div><div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;<span class="comment"> * - utilize all bits, placing all samples back to back, maximizing storage capacity</span></div><div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;<span class="comment"> * - minimize FLASH program operations, thereby avoiding the time penalty, voltage drop and current consumption that</span></div><div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;<span class="comment"> *  comes with every FLASH program operation</span></div><div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;<span class="comment"> * - move data from EEPROM to FLASH automatically whenever necessary to make sure the newest data is always in EEPROM</span></div><div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;<span class="comment"> * - allow application-specific compression of the data just before moving data from EEPROM to FLASH</span></div><div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;<span class="comment"> * - allow application-specific decompression of the data before they are read out again</span></div><div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;<span class="comment"> * - recover its full state based on the contents of the non-volatile memory alone</span></div><div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;<span class="comment"> * The storage module will use general purpose registers, EEPROM and FLASH to store bits of data. The usage of the</span></div><div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;<span class="comment"> * three types of memories is prioritized. When a new sample is to be stored:</span></div><div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;<span class="comment"> * - first an attempt is made to store it in the general purpose registers (&quot;cached&quot;).</span></div><div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;<span class="comment"> * - when this is not possible, the storage module tries to store it (together with all the cached samples) in EEPROM</span></div><div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;<span class="comment"> *  @n After moving data to EEPROM, the general purpose registers are re-used.</span></div><div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;<span class="comment"> * - only when a sufficient amount of samples are stored in EEPROM, all the data is moved to FLASH.</span></div><div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;<span class="comment"> *  @n After moving data to FLASH, the EEPROM is re-used.</span></div><div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;<span class="comment"> * .</span></div><div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;<span class="comment"> * Writing samples always means appending them to the already written samples; it is not possible to edit the already</span></div><div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;<span class="comment"> * written stream of bits.</span></div><div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;<span class="comment"> * When reading out, the user can control the starting read position using a sequence number. It is automatically</span></div><div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;<span class="comment"> * deduced where the corresponding sample is written, whether it is compressed, and what needs to be done to be able to</span></div><div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;<span class="comment"> * return the requested sample(s).</span></div><div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;<span class="comment"> * @par Hardening</span></div><div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;<span class="comment"> *  The storage module provides a ready-made solution to maximize storage of samples in persistent memory. It can:</span></div><div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;<span class="comment"> *  - store more than 10.000 samples without hitting the write endurance limit of both EEPROM and FLASH</span></div><div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;<span class="comment"> *  - recover state from unexpected resets</span></div><div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;<span class="comment"> *  - recover all or most of the samples in case of data corruption (this may occur when the battery is degraded and</span></div><div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;<span class="comment"> *      can no longer supply the minimum voltage when the load increases during a write operation in EEPROM or FLASH)</span></div><div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;<span class="comment"> *  .</span></div><div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;<span class="comment"> *  It is not possible to fully recover data under all circumstances. The storage module guarantees that only the last</span></div><div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;<span class="comment"> *  few samples may get lost. The number is dependent on the number of the reserved general purpose registers and the</span></div><div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;<span class="comment"> *  size of a sample, both of which (and more) can be tweaked using diversity settings.</span></div><div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;<span class="comment"> * @par Diversity</span></div><div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;<span class="comment"> *  This module supports diversity settings. Some settings define the type and size of the sample. Others define the</span></div><div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;<span class="comment"> *  EEPROM and FLASH regions placed under control of this module. The rest of the settings control the behavior of the</span></div><div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;<span class="comment"> *  module. Check @ref MODS_NSS_STORAGE_DFT for all diversity settings.</span></div><div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;<span class="comment"> *  @n</span></div><div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;<span class="comment"> *  It is expected that each application that requires this module includes it and configures the diversity settings of</span></div><div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;<span class="comment"> *  the module according to its specific needs.</span></div><div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;<span class="comment"> * @par Memory Requirements</span></div><div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;<span class="comment"> *  The storage module requires a large chunk of SRAM, called its workarea - see #STORAGE_WORKAREA and</span></div><div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;<span class="comment"> *  #STORAGE_WORKAREA_SIZE. This is used for two purposes:</span></div><div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;<span class="comment"> *  - When storing samples, and a move from EEPROM to FLASH is required, the assigned compress callback - see</span></div><div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;<span class="comment"> *      #STORAGE_COMPRESS_CB - is given a pointer inside this SRAM memory. The output is then stored in FLASH.</span></div><div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;<span class="comment"> *  - When reading samples from FLASH, the assigned decompress callback - see #STORAGE_DECOMPRESS_CB - is called as</span></div><div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;<span class="comment"> *      little as possible: its output is cached in the work area to speed up subsequent reads.</span></div><div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;<span class="comment"> *  .</span></div><div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;<span class="comment"> *  If two operations in your code require such a big chunk of memory, you can overlap them if they don&#39;t have to</span></div><div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;<span class="comment"> *  operate concurrently. Diversity setting #STORAGE_WORKAREA can be used for this.</span></div><div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;<span class="comment"> * @par How to use the module</span></div><div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;<span class="comment"> *  -# Define the best diversity settings for your application or accept the default ones.</span></div><div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;<span class="comment"> *  -# Initialize the EEPROM driver and the storage module, in that order.</span></div><div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;<span class="comment"> *  -# Read and write samples as necessary, in any order or quantity that is required for your use case.</span></div><div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;<span class="comment"> *  -# De-initialize the storage module and the EEPROM driver, in that order.</span></div><div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;<span class="comment"> *  .</span></div><div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;<span class="comment"> * @par Example</span></div><div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;<span class="comment"> *  @snippet storage_mod_example_1.c storage_mod_example_1</span></div><div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;<span class="comment"> * @warning These functions are not re-entrant. Calling these functions from multiple threads or in an interrupt is</span></div><div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;<span class="comment"> *  highly discouraged.</span></div><div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;<span class="comment"> * @warning The storage module requires the exclusive use of @em at @em least @em one register in the always-on domain</span></div><div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;<span class="comment"> *  (see #STORAGE_FIRST_ALON_REGISTER). Under no circumstance may the reserved registers be touched from outside the</span></div><div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;<span class="comment"> *  storage module.</span></div><div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;<span class="comment"> * @warning Although the storage module is able to recover after a power loss or going to Power-off, it is slow in doing</span></div><div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;<span class="comment"> *  so. The slow recovery time only occurs once as long as no changes to the NVM are made (e.g. by calling</span></div><div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;<span class="comment"> *  #Storage_Write).</span></div><div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;<span class="comment"> * @{</span></div><div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;<span class="comment"> */</span></div><div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;</div><div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;<span class="preprocessor">#include &quot;board.h&quot;</span></div><div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="a00008.html">storage_dft.h</a>&quot;</span></div><div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;</div><div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;<span class="comment">/* ------------------------------------------------------------------------- */</span></div><div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;<span class="comment">/**</span></div><div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;<span class="comment"> * Whenever data is about to be moved from EEPROM to FLASH, the application is notified via a callback of this</span></div><div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;<span class="comment"> * prototype. It then has a chance to compress the data before it is written to FLASH.</span></div><div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;<span class="comment"> * The application is in charge of:</span></div><div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;<span class="comment"> * - reading the data from EEPROM using @c eepromByteOffset as starting point,</span></div><div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;<span class="comment"> * - compressing exactly @c bitCount bits,</span></div><div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;<span class="comment"> * - storing the end result in @c out and</span></div><div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;<span class="comment"> * - returning the size of the data written in @c pOut, expressed in @b bits.</span></div><div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;<span class="comment"> * @param eepromByteOffset The absolute offset in bytes to the EEPROM where the first sample is stored.</span></div><div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;<span class="comment"> * @param bitCount An exact total of #STORAGE_BLOCK_SIZE_IN_SAMPLES samples are stored. They are</span></div><div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;<span class="comment"> *  packed together, i.e. without any padding bits. This argument will @b always equal</span></div><div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;<span class="comment"> *  @c #STORAGE_UNCOMPRESSED_BLOCK_SIZE_IN_BITS.</span></div><div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;<span class="comment"> * @param pOut A pointer to SRAM where the compressed data must be stored in. The buffer has a size of</span></div><div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;<span class="comment"> *  @c #STORAGE_UNCOMPRESSED_BLOCK_SIZE_IN_BYTES bytes.</span></div><div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;<span class="comment"> * @return The size of the compressed data @b in @b bits. When @c 0 is returned, or a value bigger than or equal to</span></div><div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;<span class="comment"> *  @c #STORAGE_UNCOMPRESSED_BLOCK_SIZE_IN_BITS, the uncompressed data will be stored instead, and the corresponding</span></div><div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;<span class="comment"> *  decompression callback of type #pStorage_DecompressCb_t will not be called when reading out the data later.</span></div><div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;<span class="comment"> * @warning It is @b not allowed to call any function of this module during the lifetime of the callback.</span></div><div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;<span class="comment"> * @see STORAGE_COMPRESS_CB</span></div><div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;<span class="comment"> */</span></div><div class="line"><a name="l00123"></a><span class="lineno"><a class="line" href="a00176.html#gab7c664a0e73ef251f2e68bbd23d6cabb">  123</a></span>&#160;<span class="keyword">typedef</span> int (*<a class="code" href="a00176.html#gab7c664a0e73ef251f2e68bbd23d6cabb">pStorage_CompressCb_t</a>)(<span class="keywordtype">int</span> eepromByteOffset, <span class="keywordtype">int</span> bitCount, <span class="keywordtype">void</span> * pOut);</div><div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;<span class="comment">/**</span></div><div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;<span class="comment"> * Whenever data is read from FLASH, the application is notified via a callback of this prototype. It then has a chance</span></div><div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;<span class="comment"> * to decompress the data before it is used to fulfill the read request #Storage_Read.</span></div><div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;<span class="comment"> * The application is in charge of:</span></div><div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;<span class="comment"> * - reading the data from FLASH using @c data as starting point,</span></div><div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;<span class="comment"> * - decompressing one block of compressed data stored from that point with size @c bitCount,</span></div><div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;<span class="comment"> * - storing the end result - #STORAGE_BLOCK_SIZE_IN_SAMPLES samples - in @c out. The samples @b must be written</span></div><div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;<span class="comment"> *  packed together, i.e. without any padding bits.</span></div><div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;<span class="comment"> * @param pData The absolute byte address to FLASH memory where the start of the (compressed) data block is found.</span></div><div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;<span class="comment"> * @param bitCount The size in bits of the (compressed) data block.</span></div><div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;<span class="comment"> * @param pOut A pointer to SRAM where the compressed data must be stored in. The buffer has a size of</span></div><div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;<span class="comment"> *  @c #STORAGE_UNCOMPRESSED_BLOCK_SIZE_IN_BYTES bytes.</span></div><div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;<span class="comment"> * @return The number of bits written to in @c pOut.</span></div><div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;<span class="comment"> *  If @c #STORAGE_UNCOMPRESSED_BLOCK_SIZE_IN_BITS is returned, the operation is assumed to be</span></div><div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;<span class="comment"> *  successful and the decompressed samples are now available. @c Any other value indicates a decompression failure:</span></div><div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;<span class="comment"> *  the samples stored in that block can @b not be retrieved any more, and the call to #Storage_Read which initiated</span></div><div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;<span class="comment"> *  this callback will fail.</span></div><div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;<span class="comment"> * @warning It is @b not allowed to call any function of this module during the lifetime of the callback.</span></div><div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;<span class="comment"> * @see STORAGE_DECOMPRESS_CB</span></div><div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;<span class="comment"> */</span></div><div class="line"><a name="l00145"></a><span class="lineno"><a class="line" href="a00176.html#gafb11c3cdbd067dcbbe54bac47ba3c6ff">  145</a></span>&#160;<span class="keyword">typedef</span> int (*<a class="code" href="a00176.html#gafb11c3cdbd067dcbbe54bac47ba3c6ff">pStorage_DecompressCb_t</a>)(<span class="keyword">const</span> uint8_t * pData, <span class="keywordtype">int</span> bitCount, <span class="keywordtype">void</span> * pOut);</div><div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;</div><div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;<span class="comment">/* ------------------------------------------------------------------------- */</span></div><div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;<span class="comment">/**</span></div><div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;<span class="comment"> * This function must be the first function to call in this module after going to deep power down or power-off power</span></div><div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;<span class="comment"> * save mode. Not calling this function will result at best in random data being written and read, and possibly generate</span></div><div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;<span class="comment"> * hard faults.</span></div><div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;<span class="comment"> * @pre The value written in #STORAGE_FIRST_ALON_REGISTER and beyond is either exactly what was stored after leaving</span></div><div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;<span class="comment"> *  #Storage_DeInit, or equal to @c 0.</span></div><div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;<span class="comment"> * @pre EEPROM is initialized and is ready to be used.</span></div><div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;<span class="comment"> * @post When this function returns, #Storage_Seek still needs to be called before being able to read samples. This is</span></div><div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;<span class="comment"> *  also required when reading from the start of the memory, i.e. when reading the oldest stored sample referred to as</span></div><div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;<span class="comment"> *  index 0.</span></div><div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;<span class="comment"> * @warning This function can run for a long time before completion when it is forced to scan the assigned EEPROM</span></div><div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;<span class="comment"> *  region to recover the data that is stored in EEPROM and/or FLASH. The time spent is depending on both the assigned</span></div><div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;<span class="comment"> *  EEPROM region and the number of samples stored in EEPROM: the longer the region, the more time spent; the more</span></div><div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;<span class="comment"> *  samples stored in EEPROM, the less time spent recovering. Under worst case conditions using a system clock of</span></div><div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;<span class="comment"> *  0.5 MHz, this may last more than 10 msec.</span></div><div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;<span class="comment"> *  This penalty only occurs under these combined conditions:</span></div><div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;<span class="comment"> *  - the IC went to power-off, losing all information stored in the register #STORAGE_FIRST_ALON_REGISTER and beyond.</span></div><div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;<span class="comment"> *  - data was added to the storage module after leaving a previous power-off mode</span></div><div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;<span class="comment"> *  .</span></div><div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;<span class="comment"> */</span></div><div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;<span class="keywordtype">void</span> <a class="code" href="a00176.html#gad04fe4fa8e78ef5572e4a39dec188c31">Storage_Init</a>(<span class="keywordtype">void</span>);</div><div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;<span class="comment">/**</span></div><div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;<span class="comment"> * This function must be the last function to call in this module before going to deep power down or power-off power</span></div><div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;<span class="comment"> * save mode.</span></div><div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;<span class="comment"> * @pre EEPROM is still initialized and ready to be used.</span></div><div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;<span class="comment"> * @post Possibly, an EEPROM flush was necessary, but that has finished when this function returns.</span></div><div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;<span class="comment"> * @warning Loss of power before or during this call may result in loss of some or all of the newly added samples.</span></div><div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;<span class="comment"> */</span></div><div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;<span class="keywordtype">void</span> <a class="code" href="a00176.html#ga75abea0be7fefec6285224dc0f82f5ac">Storage_DeInit</a>(<span class="keywordtype">void</span>);</div><div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;<span class="comment">/**</span></div><div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;<span class="comment"> * @return The total number of samples currently stored, in EEPROM and FLASH combined.</span></div><div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;<span class="comment"> */</span></div><div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;<span class="keywordtype">int</span> <a class="code" href="a00176.html#ga80e837c4eb77a8ff14057e1971e63083">Storage_GetCount</a>(<span class="keywordtype">void</span>);</div><div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;<span class="comment">/**</span></div><div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;<span class="comment"> * Resets the storage module to a pristine state.</span></div><div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;<span class="comment"> * @param checkFlash The contents in FLASH must have been erased before it can be written to. An erase operation is</span></div><div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;<span class="comment"> *  costly and time-consuming and is preferably avoided.</span></div><div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;<span class="comment"> *  - When @c true is given, @b all words of the FLASH memory assigned for sample storage are checked.</span></div><div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;<span class="comment"> *      If one checked word does not contain the erased value (@c 0xFFFFFFFF), all FLASH memory is erased. This</span></div><div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;<span class="comment"> *      can possibly take up to 3 erase cycles. Aligning #STORAGE_FLASH_FIRST_PAGE and #STORAGE_FLASH_LAST_PAGE to</span></div><div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;<span class="comment"> *      sector boundaries can reduce this to the minimum of 1 erase cycle.</span></div><div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;<span class="comment"> *  - When @c false is given, FLASH memory is not checked and not erased.</span></div><div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;<span class="comment"> *  .</span></div><div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;<span class="comment"> * @note Provide @c true as argument for @c checkFlash when the intention is to store new samples afterwards.</span></div><div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;<span class="comment"> */</span></div><div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;<span class="keywordtype">void</span> <a class="code" href="a00176.html#ga345ce91da83ce1cea789068dfb587ed5">Storage_Reset</a>(<span class="keywordtype">bool</span> checkFlash);</div><div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;<span class="comment">/**</span></div><div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;<span class="comment"> * Stores @c n samples.</span></div><div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;<span class="comment"> * @pre EEPROM is initialized</span></div><div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;<span class="comment"> * @param pSamples Pointer to the start of the array where to copy the samples from. For each element of the array,</span></div><div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;<span class="comment"> *  only the #STORAGE_BITSIZE LSBits are copied.</span></div><div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;<span class="comment"> * @param n The size of the array @c pSamples points to, in number of #STORAGE_TYPE elements.</span></div><div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;<span class="comment"> * @return The number of samples written. This value may be @c 0 or any number of samples less than or equal to @c n.</span></div><div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;<span class="comment"> * @note When a value less than @c n is returned, at least one of these errors occurred:</span></div><div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;<span class="comment"> *  - There is insufficient storage capacity</span></div><div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;<span class="comment"> *  - Compressing of samples was necessary during the call, but that operation yielded an error.</span></div><div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;<span class="comment"> *  .</span></div><div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;<span class="comment"> * @note A prior call to #Storage_Seek is @b not required, as writing will always @b append the new samples.</span></div><div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;<span class="comment"> * @post A later call to #Storage_DeInit is necessary to ensure the data can survive Deep power down state.</span></div><div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;<span class="comment"> * @warning Data is not guaranteed to be stored in EEPROM or FLASH: reset can lose some of the last samples written.</span></div><div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;<span class="comment"> */</span></div><div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;<span class="keywordtype">int</span> <a class="code" href="a00176.html#ga820a105a6412fe21e8598f2c682664af">Storage_Write</a>(<a class="code" href="a00177.html#gacdcc483479cdfdecfdd8908db2ad80ba">STORAGE_TYPE</a> * pSamples, <span class="keywordtype">int</span> n);</div><div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;<span class="comment">/**</span></div><div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;<span class="comment"> * Determines which sample is read out next in a future call to #Storage_Read. This call is</span></div><div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;<span class="comment"> * required to be called once before calling #Storage_Read one or multiple times.</span></div><div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;<span class="comment"> * @param n Must be a positive number. A value of @c 0 indicates the oldest sample, which was written first.</span></div><div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;<span class="comment"> * @return @c true when the sought for sequence number was found; @c false otherwise.</span></div><div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;<span class="comment"> * @post the next call to #Storage_Read will either return at least one sample - the value</span></div><div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;<span class="comment"> *  which was stored as the @c n-th sample - or fail - when less than @c n samples are being stored at the time of</span></div><div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;<span class="comment"> *  calling this function.</span></div><div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;<span class="comment"> * @note After initialization, the default sequence number is @em not @c 0. First, a call to this function is required</span></div><div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;<span class="comment"> *  before #Storage_Read can retrieve samples.</span></div><div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;<span class="comment"> */</span></div><div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;<span class="keywordtype">bool</span> <a class="code" href="a00176.html#ga82112f49c64c590b321e1e02caf077f5">Storage_Seek</a>(<span class="keywordtype">int</span> n);</div><div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;<span class="comment">/**</span></div><div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;<span class="comment"> * Reads @c n samples from persistent storage, starting from the sequence number set in #Storage_Seek.</span></div><div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;<span class="comment"> * @pre EEPROM is initialized</span></div><div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;<span class="comment"> * @pre A prior successful call to #Storage_Seek is required before this function can succeed.</span></div><div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;<span class="comment"> * @note Multiple reads can be issued after calling #Storage_Seek once, each time fetching samples in sequence.</span></div><div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;<span class="comment"> * @param [out] pSamples : Pointer to an array of @n elements, where the read samples are copied to. Upon successful</span></div><div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;<span class="comment"> *  completion, each element will contain one sample, where only the #STORAGE_BITSIZE LSBits are used per</span></div><div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;<span class="comment"> *  element; the remainder MSBits are set to 0.</span></div><div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;<span class="comment"> * @param n : The size of the array @c samples points to, in number of #STORAGE_TYPE elements.</span></div><div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;<span class="comment"> * @return The number of samples read. This value may be @c 0 or any number of samples less than @c n.</span></div><div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;<span class="comment"> *  The remainder of the elements with a higher index may have been written to, but must be ignored.</span></div><div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;<span class="comment"> * @note When a value less than @c n is returned, at least one of these errors occurred:</span></div><div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;<span class="comment"> *  - There was no prior successful call to #Storage_Seek</span></div><div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;<span class="comment"> *  - Decompressing of samples was necessary during the call, but that operation yielded an error.</span></div><div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;<span class="comment"> *  - There are no more samples stored.</span></div><div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;<span class="comment"> */</span></div><div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;<span class="keywordtype">int</span> <a class="code" href="a00176.html#gad82b015bb0ed48f90d9782a4b29f52ff">Storage_Read</a>(<a class="code" href="a00177.html#gacdcc483479cdfdecfdd8908db2ad80ba">STORAGE_TYPE</a> * pSamples, <span class="keywordtype">int</span> n);</div><div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;<span class="comment">/**</span></div><div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160;<span class="comment"> * @cond STORAGE_DOC</span></div><div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;<span class="comment"> * @mainpage storage: NVM Storage module</span></div><div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160;<span class="comment"> * @copydoc MODS_NSS_STORAGE</span></div><div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;<span class="comment"> * @endcond</span></div><div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;<span class="comment"> */</span></div><div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;<span class="preprocessor">#endif </span><span class="comment">/** @} */</span><span class="preprocessor"></span></div><div class="ttc" id="a00176_html_ga80e837c4eb77a8ff14057e1971e63083"><div class="ttname"><a href="a00176.html#ga80e837c4eb77a8ff14057e1971e63083">Storage_GetCount</a></div><div class="ttdeci">int Storage_GetCount(void)</div><div class="ttdef"><b>Definition:</b> <a href="a00002_source.html#l01530">storage.c:1530</a></div></div>
<div class="ttc" id="a00176_html_ga345ce91da83ce1cea789068dfb587ed5"><div class="ttname"><a href="a00176.html#ga345ce91da83ce1cea789068dfb587ed5">Storage_Reset</a></div><div class="ttdeci">void Storage_Reset(bool checkFlash)</div><div class="ttdef"><b>Definition:</b> <a href="a00002_source.html#l01535">storage.c:1535</a></div></div>
<div class="ttc" id="a00176_html_ga82112f49c64c590b321e1e02caf077f5"><div class="ttname"><a href="a00176.html#ga82112f49c64c590b321e1e02caf077f5">Storage_Seek</a></div><div class="ttdeci">bool Storage_Seek(int n)</div><div class="ttdef"><b>Definition:</b> <a href="a00002_source.html#l01681">storage.c:1681</a></div></div>
<div class="ttc" id="a00176_html_ga75abea0be7fefec6285224dc0f82f5ac"><div class="ttname"><a href="a00176.html#ga75abea0be7fefec6285224dc0f82f5ac">Storage_DeInit</a></div><div class="ttdeci">void Storage_DeInit(void)</div><div class="ttdef"><b>Definition:</b> <a href="a00002_source.html#l01505">storage.c:1505</a></div></div>
<div class="ttc" id="a00176_html_gad04fe4fa8e78ef5572e4a39dec188c31"><div class="ttname"><a href="a00176.html#gad04fe4fa8e78ef5572e4a39dec188c31">Storage_Init</a></div><div class="ttdeci">void Storage_Init(void)</div><div class="ttdef"><b>Definition:</b> <a href="a00002_source.html#l01425">storage.c:1425</a></div></div>
<div class="ttc" id="a00176_html_gab7c664a0e73ef251f2e68bbd23d6cabb"><div class="ttname"><a href="a00176.html#gab7c664a0e73ef251f2e68bbd23d6cabb">pStorage_CompressCb_t</a></div><div class="ttdeci">int(* pStorage_CompressCb_t)(int eepromByteOffset, int bitCount, void *pOut)</div><div class="ttdef"><b>Definition:</b> <a href="a00005_source.html#l00123">storage.h:123</a></div></div>
<div class="ttc" id="a00177_html_gacdcc483479cdfdecfdd8908db2ad80ba"><div class="ttname"><a href="a00177.html#gacdcc483479cdfdecfdd8908db2ad80ba">STORAGE_TYPE</a></div><div class="ttdeci">#define STORAGE_TYPE</div><div class="ttdef"><b>Definition:</b> <a href="a00008_source.html#l00264">storage_dft.h:264</a></div></div>
<div class="ttc" id="a00176_html_gad82b015bb0ed48f90d9782a4b29f52ff"><div class="ttname"><a href="a00176.html#gad82b015bb0ed48f90d9782a4b29f52ff">Storage_Read</a></div><div class="ttdeci">int Storage_Read(STORAGE_TYPE *pSamples, int n)</div><div class="ttdef"><b>Definition:</b> <a href="a00002_source.html#l01750">storage.c:1750</a></div></div>
<div class="ttc" id="a00008_html"><div class="ttname"><a href="a00008.html">storage_dft.h</a></div></div>
<div class="ttc" id="a00176_html_ga820a105a6412fe21e8598f2c682664af"><div class="ttname"><a href="a00176.html#ga820a105a6412fe21e8598f2c682664af">Storage_Write</a></div><div class="ttdeci">int Storage_Write(STORAGE_TYPE *pSamples, int n)</div><div class="ttdef"><b>Definition:</b> <a href="a00002_source.html#l01619">storage.c:1619</a></div></div>
<div class="ttc" id="a00176_html_gafb11c3cdbd067dcbbe54bac47ba3c6ff"><div class="ttname"><a href="a00176.html#gafb11c3cdbd067dcbbe54bac47ba3c6ff">pStorage_DecompressCb_t</a></div><div class="ttdeci">int(* pStorage_DecompressCb_t)(const uint8_t *pData, int bitCount, void *pOut)</div><div class="ttdef"><b>Definition:</b> <a href="a00005_source.html#l00145">storage.h:145</a></div></div>
</div><!-- fragment --></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_01fcd3835fb4e7d9331b722d86291b65.html">sw</a></li><li class="navelem"><a class="el" href="dir_f643af3405d44c87806a004ea9d85fcb.html">nss</a></li><li class="navelem"><a class="el" href="dir_e4201def0db509365eefa385ff809fc0.html">mods</a></li><li class="navelem"><a class="el" href="dir_5922c764dea65d8f389f9304c919579a.html">storage</a></li><li class="navelem"><a class="el" href="a00005.html">storage.h</a></li>
    <li class="footer">Generated on Tue Oct 20 2020 08:24:36 for NHS31xx storage - Maximizing storage for equisized samples by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.14 </li>
  </ul>
</div>
</body>
</html>
